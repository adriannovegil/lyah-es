
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Funtores, funtores aplicativos y monoides &#8212; documentación de ¡Aprende Haskell por el bien de todos! - 0.1</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Un puñado de mónadas" href="monadas.html" />
    <link rel="prev" title="Resolviendo problemas de forma funcional" href="problemas.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="monadas.html" title="Un puñado de mónadas"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="problemas.html" title="Resolviendo problemas de forma funcional"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="funtores-funtores-aplicativos-y-monoides">
<span id="cfuntores"></span><h1>Funtores, funtores aplicativos y monoides<a class="headerlink" href="#funtores-funtores-aplicativos-y-monoides" title="Enlazar permanentemente con este título">¶</a></h1>
<p>La combinación de Haskell de la pureza, las funciones de orden superior,
tipos de datos algebraicos con parámetros, y clases de tipos nos permite
implementar el polimorfismo a un nivel superior al que pueden alcanzar otros
lenguajes. No tenemos que ver los tipos como si pertenecieran a una gran
jerarquía de tipos. En lugar de eso, vemos como pueden actuar los tipos y
luego los conectamos con las clases de tipos apropiadas. Un <code class="docutils literal notranslate"><span class="pre">Int</span></code> puede
actuar como un montón de cosas. Puede actuar como algo equiparable, como algo
ordenable, como algo enumerable, etc.</p>
<p>Las clases de tipos son abiertas, lo que significa que podemos definir nuestro
propio tipo de dato, razonar en como éste actúa y conectarlo con la clase de
tipos que define ese comportamiento. Por este motivo, y porque el fabuloso
sistema de tipos de Haskell nos permite saber mucho acerca de una función con
tan solo sabiendo su declaración de tipo, podemos crear clases de tipos que
definen comportamientos muy generales y abstractos. Ya vimos que las clases de
tipos definen operaciones para ver si dos cosas son iguales o comparar dos
cosas por un cierto orden. Son comportamientos muy abstractos a la vez que
elegantes, pero no los vemos como algo especial ya que hemos estado tratando
con ellos a lo largo de nuestras vidas. Hace poco conocimos los funtores, que
son básicamente cosas que se pueden mapear. Esto es un ejemplo de algo útil y
a la vez bastante abstracto de lo que pueden describir las clases de tipos. En
este capítulo veremos más de cerca los funtores, junto a una versión más
fuerte y útil de los funtores llamados funtores aplicativos. También daremos
un vistazo a los monoides.</p>
<div class="section" id="de-vuelta-con-los-funtores">
<h2>De vuelta con los funtores<a class="headerlink" href="#de-vuelta-con-los-funtores" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="La ranas ni siquiera necesitan dinero." class="align-right" src="../_images/frogtor.png" />
<p>Ya hablamos de los funtores en su pequeña <a class="reference internal" href="clasesdetipos.html#funtores"><span class="std std-ref">sección</span></a>. Si
todavía no la has leído, probablemente deberías darle un vistazo ahora mismo,
o quizá luego cuando tengas más tiempo. O simplemente puedes hacer como si ya
la hubieses leído.</p>
<p>Aun así, vamos a recordar algo: los funtores son cosas que se puede mapear,
como las listas, <code class="docutils literal notranslate"><span class="pre">Maybe``s,</span> <span class="pre">árboles,</span> <span class="pre">etc.</span> <span class="pre">En</span> <span class="pre">Haskell,</span> <span class="pre">son</span> <span class="pre">descritos</span> <span class="pre">con</span> <span class="pre">la</span>
<span class="pre">clase</span> <span class="pre">de</span> <span class="pre">tipos</span> <span class="pre">``Functor</span></code>, la cual solo contiene un método de clase,
<code class="docutils literal notranslate"><span class="pre">fmap</span></code>, que tiene como tipo <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code>. Dice algo
como: dame una función que tome un <code class="docutils literal notranslate"><span class="pre">a</span></code> y devuelva un <code class="docutils literal notranslate"><span class="pre">b</span></code> y una caja con
una <code class="docutils literal notranslate"><span class="pre">a</span></code> (o varias de ellas) dentro y yo te daré una caja con una <code class="docutils literal notranslate"><span class="pre">b</span></code> (o
varias de ellas) dentro. En cierto modo es como si aplicará la función dentro
de la caja.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Muchas veces utilizamos la analogía de la caja para hacernos una
idea de como funcionan los funtores, luego, probablemente
usemos la misma analogía para los funtores aplicativos y las
mónadas. Al principio es una buena analogía que ayuda a la gente a
entender los funtores, pero no la tomes al pie de la letra, ya que
para algunos funtores la analogía de la caja tiene que ser ajusta al
milímetro para que siga siendo verdad. Un término más correcto para
definir lo que es un funtor sería <em>contexto</em> <em>computacional</em>. El
contexto sería que la computación podría tener un valor, o podría
fallar (<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code>) o que podría tener más valores
(listas) o cosas por el estilo.</p>
</div>
<p>Si queremos que un constructor de tipos sea una instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, tiene
que pertenecer a la familia de tipos <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>, lo que significa que debe
tomar exactamente un tipo concreto como parámetro.  Por ejemplo, <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
puede ser una instancia ya que tome un tipo como parámetro para producir un
nuevo tipo concreto, como <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code> o <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">String</span></code>. Si un constructor
de tipos toma dos parámetros, como <code class="docutils literal notranslate"><span class="pre">Either</span></code>, tenemos que aplicar
parcialmente el constructor de tipos hasta que solo acepte un parámetro. Así
que no podemos usar <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">Either</span> <span class="pre">where</span></code> pero si podemos utilizar
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Either</span> <span class="pre">a)</span> <span class="pre">where</span></code> y luego podemos pensar que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es
solo para <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code>, por lo que tendría una declaración de tipo como
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">c</span></code>. Como puedes ver, la parte
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> es fija, ya que <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> toma solo un parámetro, mientras que
<code class="docutils literal notranslate"><span class="pre">Either</span></code> toma dos parámetros así que
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">c</span></code> no tendría mucho sentido.</p>
<p>Hasta ahora hemos aprendido como unos cuantos tipos (bueno, en realidad
constructores de tipos) son instancias de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, como <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>,
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> y el tipo <code class="docutils literal notranslate"><span class="pre">Tree</span></code> que creamos nosotros mismos. Vimos como
podíamos mapear funciones sobre ellos. En esta sección, veremos dos instancias
más de la clase funtor, en concreto <code class="docutils literal notranslate"><span class="pre">IO</span></code> y <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>.</p>
<p>Si un valor tiene el tipo, digamos, <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>, significa que es una acción
que, cuando sea ejecutada, saldrá al mundo real y nos traerá una cadena, que
será devuelta como resultado. Podemos usar <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code> dentro de un bloque <code class="docutils literal notranslate"><span class="pre">do</span></code>
para ligar ese resultado a un nombre. Mencionamos que las acciones E/S son
como cajas con sus pequeñitos pies que se encargan de salir al mundo real y
traernos algún valor. Podemos inspeccionar lo que nos han traído, pero si lo
hacemos el valor que devolvamos tiene que estar dentro de <code class="docutils literal notranslate"><span class="pre">IO</span></code>. Si pensamos
en esta analogía de la caja con pies, podemos ver que <code class="docutils literal notranslate"><span class="pre">IO</span></code> se comporta como
un funtor.</p>
<p>Vamos a ver como <code class="docutils literal notranslate"><span class="pre">IO</span></code> es una instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. Cuando aplicamos
<code class="docutils literal notranslate"><span class="pre">fmap</span></code> con una función sobre una acción de E/S, queremos obtener una acción
de E/S que haga lo mismo, pero que tenga la función anterior aplicada a su
resultado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">action</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">action</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>El resultado de mapear algo sobre una acción de E/S será una acción de E/S,
así que justo después de la declaración usamos un bloque <code class="docutils literal notranslate"><span class="pre">do</span></code> para juntar
dos acciones de E/S en una nueva. En la implementación de <code class="docutils literal notranslate"><span class="pre">fmap</span></code>, creamos
una nueva acción de E/S que primero ejecutará la acción de E/S original y
llamará a su resultado <code class="docutils literal notranslate"><span class="pre">result</span></code>. Luego, hacemos <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(f</span> <span class="pre">result)</span></code>.
<code class="docutils literal notranslate"><span class="pre">return</span></code> es, como ya sabes, una función que crear una acción de E/S que no
hace nada salvo tener algo como resultado. La acción que produce un bloque
<code class="docutils literal notranslate"><span class="pre">do</span></code> siempre tendrá como resultado el resultado de su última acción. Por ese
motivo utilizamos <code class="docutils literal notranslate"><span class="pre">return</span></code> para crear una acción de E/S que en realidad no
hace nada, salvo contener <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">result</span></code> como resultado.</p>
<p>Podemos jugar con él para ver como funciona. En realidad es bastante simple.
Fíjate en el siguiente trozo de código:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
          <span class="kr">let</span> <span class="n">line&#39;</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="n">line</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;You said &quot;</span> <span class="o">++</span> <span class="n">line&#39;</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Yes, you really said&quot;</span> <span class="o">++</span> <span class="n">line&#39;</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
</pre></div>
</div>
<p>Se le pregunta al usuario por una nueva línea y luego se la devolvemos al
usuario, aunque invertida. Así sería como escribiríamos lo mismo utilizando
<code class="docutils literal notranslate"><span class="pre">fmap</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="n">reverse</span> <span class="n">getLine</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;You said &quot;</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Yes, you really said&quot;</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
</pre></div>
</div>
<img alt="w00ooOoooOO" class="align-left" src="../_images/alien.png" />
<p>De la misma forma que cuando usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">reverse</span></code> sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;blah&quot;</span></code>
obtenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;halb&quot;</span></code>, podemos utilizar <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">reverse</span></code> sobre
<code class="docutils literal notranslate"><span class="pre">getLine</span></code>. <code class="docutils literal notranslate"><span class="pre">getLine</span></code> es una acción de E/S que tiene el tipo <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>
y al mapear <code class="docutils literal notranslate"><span class="pre">reverse</span></code> sobre ella nos devuelve una acción que viajará al
mundo real y nos traerá una línea de texto, a la que luego dará la vuelta
aplicando <code class="docutils literal notranslate"><span class="pre">reverse</span></code> a su resultado. De la misma forma que podemos aplicar
una función a algo contenido en una caja <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, podemos aplicar una
función a lo que hay dentro de una caja <code class="docutils literal notranslate"><span class="pre">IO</span></code>, solo que tiene que viajar al
mundo real para obtener ese algo. Luego lo ligamos a un nombre usando <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>,
dicho nombre será asociado al resultado que ya se le ha aplicado <code class="docutils literal notranslate"><span class="pre">reverse</span></code>.</p>
<p>La acción de E/S <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(++&quot;!&quot;)</span> <span class="pre">getLine</span></code> actúa como <code class="docutils literal notranslate"><span class="pre">getLine</span></code>, solo su
resultado siempre lleva añadido un <code class="docutils literal notranslate"><span class="pre">&quot;!&quot;</span></code> al final.</p>
<p>Si vemos el tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> limitado a <code class="docutils literal notranslate"><span class="pre">IO</span></code>, tendríamos algo como
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">b</span></code>. <code class="docutils literal notranslate"><span class="pre">fmap</span></code> toma una función y una acción
de E/S y devuelve una nueva acción de E/S que actúa como la anterior, solo que
la función se aplica al resultado contenido en la acción.</p>
<p>Si alguna vez te encuentras ligando un nombre a una acción de E/S, con el
único fin de aplicarle una función para luego usarlo en algún otro lugar,
considera el uso de <code class="docutils literal notranslate"><span class="pre">fmap</span></code>, ya que es más elegante. Si quieres aplicar
varias transformaciones al contenido de un funtor puedes declarar tu propia
función, usar una función lambda o, idealmente, utilizar la composición de
funciones:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">intersperse</span> <span class="sc">&#39;-&#39;</span> <span class="o">.</span> <span class="n">reverse</span> <span class="o">.</span> <span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
          <span class="n">putStrLn</span> <span class="n">line</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ runhaskell fmapping_io.hs
hello there
E-R-E-H-T- -O-L-L-E-H
</pre></div>
</div>
<p>Como probablemente ya sepas, <code class="docutils literal notranslate"><span class="pre">intersperse</span> <span class="pre">'-'</span> <span class="pre">.</span> <span class="pre">reverse</span> <span class="pre">.</span> <span class="pre">map</span> <span class="pre">toUpper</span></code> es
una función que toma una cadena, mapea <code class="docutils literal notranslate"><span class="pre">toUpper</span></code> sobre ella, aplica
<code class="docutils literal notranslate"><span class="pre">reverse</span></code> sobre el resultado anterior y luego le aplica <code class="docutils literal notranslate"><span class="pre">intersperse</span> <span class="pre">'-'</span></code>.
Es como <code class="docutils literal notranslate"><span class="pre">(\xs</span> <span class="pre">-&gt;</span> <span class="pre">intersperse</span> <span class="pre">'-'</span> <span class="pre">(reverse</span> <span class="pre">(map</span> <span class="pre">toUpper</span> <span class="pre">xs)))</span></code> solo que
más bonito.</p>
<p>Otra instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code> con la que hemos estado trabajando pero que no
sabíamos que era un funtor es <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>. Probablemente ahora mismo estás un
poco confundido, ya que ¿Qué diablos significa <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>? El tipo de una
función <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> se puede reescribir como <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span> <span class="pre">a</span></code>, de forma similar que
podemos escribir <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code> como <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">2</span> <span class="pre">3</span></code>. Cuando nos encontramos con
<code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span> <span class="pre">a</span></code>, vemos a <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span></code> de forma diferente, ya que podemos verlo como
un constructor de tipos que toma dos parámetros de tipos, como <code class="docutils literal notranslate"><span class="pre">Either</span></code>.
Pero recuerda, dijimos que un constructor de tipos debe tomar un solo
parámetro para poder ser instancia de un funtor. Por esa razón no podemos
crear una <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span></code> instancia  de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, pero si lo aplicamos
parcialmente <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>, no hay ningún problema. Si la sintaxis permitiera
aplicar parcialmente los constructores de tipos con secciones (de la misma
forma que podemos aplicar parcialmente <code class="docutils literal notranslate"><span class="pre">+</span></code> utilizando <code class="docutils literal notranslate"><span class="pre">(2+)</span></code>, que es lo
mismo que <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">2</span></code>), podríamos escribir <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code> como <code class="docutils literal notranslate"><span class="pre">(r</span> <span class="pre">-&gt;)</span></code> ¿Cómo son
los funtores funciones? Bueno, vamos a echar un vistazo a la implementación,
que se encuentra en <code class="docutils literal notranslate"><span class="pre">Control.Monad.Instances</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Normalmente identificamos a la funciones que toman cualquier cosa y
devuleven cualquier otra cosa como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>. <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> es
exactamente lo mismo, solo que hemos usado letras diferentes para
las variables de tipo.</p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Si la sintaxis lo permitiera, lo podríamos haber escrito como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="n">r</span> <span class="ow">-&gt;</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>Pero no lo permite, así que lo tenemos que escribir como al principio.</p>
<p>Antes de nada, vamos a pensar en el tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code>. Sería
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code>. Ahora lo que tenemos que hacer es
remplazar mentalmente todas las <code class="docutils literal notranslate"><span class="pre">f</span></code>, las cuales hacen el papel de funtor,
por <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>. Hacemos esto cada vez que queramos ver como se comporta
<code class="docutils literal notranslate"><span class="pre">fmap</span></code> para una cierta instancia. Obtenemos
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">((-&gt;)</span> <span class="pre">r</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">((-&gt;)</span> <span class="pre">r</span> <span class="pre">b)</span></code>. Ahora lo que podemos hacer
es escribir los tipos <code class="docutils literal notranslate"><span class="pre">((-&gt;)</span> <span class="pre">r</span> <span class="pre">a)</span></code> y <code class="docutils literal notranslate"><span class="pre">((-&gt;)</span> <span class="pre">r</span> <span class="pre">b)</span></code> de forma infija,
<code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, como hacemos normalmente con las funciones. Lo que
obtenemos es <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">b)</span></code>.</p>
<p>Mmmm… Vale. Si mapeamos una función sobre una función obtenemos una nueva
función, de la misma forma que si mapeamos una función sobre un <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
obtenemos un <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y de la misma forma que si mapeamos una función sobre
una lista obtenemos una lista ¿Qué nos dice exactamente el tipo
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">b)</span></code>? Bueno, podemos ver que toma una
función de <code class="docutils literal notranslate"><span class="pre">a</span></code> a <code class="docutils literal notranslate"><span class="pre">b</span></code> y una función de <code class="docutils literal notranslate"><span class="pre">r</span></code> a <code class="docutils literal notranslate"><span class="pre">a</span></code> y devuelve una
función de <code class="docutils literal notranslate"><span class="pre">r</span></code> a <code class="docutils literal notranslate"><span class="pre">b</span></code> ¿Te recuerda a algo? ¡Sí! ¡Composición de funciones!
Dirigimos la salida de <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> a la entrada de <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> para obtener una
función <code class="docutils literal notranslate"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, lo cual es exactamente lo mismo que la composición de
funciones. Si miras como se definió la instancia arriba, podrás ver que es una
simple composición de funciones. Otra forma de escribirlo sería así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<p>De esta forma vemos de forma clara que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es simplemente una composición
de funciones. Ejecuta <code class="docutils literal notranslate"><span class="pre">:m</span> <span class="pre">+</span> <span class="pre">Control.Monad.Instances</span></code>, ya que ahí está
definida esta instancia e intenta mapear algunas funciones.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t fmap (*3) (+100)
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a
ghci&gt; fmap (*3) (+100) 1
303
ghci&gt; (*3) `fmap` (+100) $ 1
303
ghci&gt; (*3) . (+100) $ 1
303
ghci&gt; fmap (show . (*3)) (*100) 1
&quot;300&quot;
</pre></div>
</div>
<p>Podemos llamar a <code class="docutils literal notranslate"><span class="pre">fmap</span></code> de forma infija para que se parezca a <code class="docutils literal notranslate"><span class="pre">.</span></code>. En la
segunda línea estamos mapeando <code class="docutils literal notranslate"><span class="pre">(*3)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">(+100)</span></code>, lo que resulta en
una función que tomara un valor llamará a <code class="docutils literal notranslate"><span class="pre">(+100)</span></code> y luego a <code class="docutils literal notranslate"><span class="pre">(*3)</span></code> con el
resultado anterior. Llamamos a la función con <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>¿Cómo encaja la analogía de la caja aquí? Bueno, si la forzamos un poco, se
ajusta. Cuando usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+3)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> nos es fácil imaginar a
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> como una caja que contiene algo a lo que aplicamos la función
<code class="docutils literal notranslate"><span class="pre">(+3)</span></code> ¿Pero qué sucede cuando usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(*3)</span> <span class="pre">(+100)</span></code>? Bueno, puedes
imaginar a <code class="docutils literal notranslate"><span class="pre">(+100)</span></code> como una caja que contiene el resultado final. Algo
parecido a cuando imaginábamos las acciones de E/S como una caja que salía al
mundo real y nos traía un resultado. Al usar <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(*3)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">(+100)</span></code>
creará otra función que se comportará como <code class="docutils literal notranslate"><span class="pre">(+100)</span></code>, solo que antes de
producir el resultado, aplicará <code class="docutils literal notranslate"><span class="pre">(*3)</span></code> a ese resultado. Ahora podemos ver
como <code class="docutils literal notranslate"><span class="pre">fmap</span></code> se comporta como <code class="docutils literal notranslate"><span class="pre">.</span></code> para las funciones.</p>
<p>El hecho de que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> se comporte como una composición de funciones cuando
se utiliza sobre funciones no es que sea especialmente útil en estos momentos,
pero al menos es interesante. También puede confundirnos ver como algunas
cosas que se comportan más como una computación que como una caja (<code class="docutils literal notranslate"><span class="pre">IO</span></code> y
<code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code>), son funtores. Una función mapeada sobre una computación devuelve
esa misma computación, pero a el resultado de dicha computación se le aplicará
la función mapeada.</p>
<img alt="Desplazar una función es más fácil que desplazar una tolenada." class="align-right" src="../_images/lifter.png" />
<p>Antes de que veamos las reglas que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> debe seguir, vamos a pensar sobre
el tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> una vez más. Su tipo es
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code>. Nos hemos olvidado de la restricción de
clase <code class="docutils literal notranslate"><span class="pre">(Functor</span> <span class="pre">f)</span> <span class="pre">=&gt;</span></code>, pero lo hemos hecho por brevedad ya porque estamos
hablando de funtores y sabemos que significa <code class="docutils literal notranslate"><span class="pre">f</span></code>. La primera vez que
hablamos sobre las <a class="reference internal" href="ordensuperior.html#curry"><span class="std std-ref">Funciones currificadas</span></a>, dijimos que en
realidad todas las funciones de Haskell toman un solo parámetro. Una función
con tipo <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code> en realidad toma un solo parámetro <code class="docutils literal notranslate"><span class="pre">a</span></code> y luego
devuelve una función <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>, que a su vez toma otro parámetro y devuelve
<code class="docutils literal notranslate"><span class="pre">c</span></code>. Es como si llamáramos a la función con demasiados pocos parámetros (es
decir, la aplicamos parcialmente), obtenemos una función que toma tantos
parámetros como nos hayamos dejado (si pensamos de nuevo que las funciones
toman varios parámetros). Así que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code> puede escribirse como
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span></code> para hacer visible la currificación.</p>
<p>Del mismo modo, si escribimos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b)</span></code>, podemos
ver a <code class="docutils literal notranslate"><span class="pre">fmap</span></code> no como una función que toma una función y un funtor y devuelve
otro funtor, sino como una función que toma una función y devuelve otra
función igual a la anterior, solo que toma un funtor como parámetros y
devuelve otro funtor como resultado. Toma una función <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code> y devuelve
una función <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code>. A esto se llama <em>mover una función</em>. Vamos a
trastear un poco con esa idea utilizando el comando <code class="docutils literal notranslate"><span class="pre">:t</span></code> de GHCi:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t fmap (*2)
fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a
ghci&gt; :t fmap (replicate 3)
fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]
</pre></div>
</div>
<p>La expresión <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(*2)</span></code> es una función que toma un funtor <code class="docutils literal notranslate"><span class="pre">f</span></code> sobre
números y devuelve otro funtor sobre números. Ese funtor puede ser una lista,
un <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, un <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span></code>, cualquier cosa. La expresión
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(replicate</span> <span class="pre">3)</span></code> tomara un funtor sobre cualquier tipo y devolverá un
funtor sobre una lista de elementos de ese tipo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando decimos <em>funtor sobre números</em>, puedes verlo como un <em>funtor
contiene números</em>. El primero es algo más formal y más técnicamente
correcto, pero el segundo es más fácil de captar.</p>
</div>
<p>Puedes ver <code class="docutils literal notranslate"><span class="pre">fmap</span></code> como una función que toma una función y un funtor y luego
mapea dicha función sobre el funtor, o puedes verlo como una función que toma
función y mueve dicha función de forma que opere sobre funtores. Ambos puntos
de vista son correctos en Haskell, equivalentes.</p>
<p>El tipo <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(replicate</span> <span class="pre">3)</span> <span class="pre">::</span> <span class="pre">(Functor</span> <span class="pre">f)</span> <span class="pre">=&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">[a]</span></code> nos dice que la
función funcionará cuan cualquier tipo de funtor. Lo que hará exactamente
dependerá de que tipo de funtor utilicemos. Si usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(replicate</span> <span class="pre">3)</span></code>
con una lista, la implementación de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> para listas será utilizada, que
es <code class="docutils literal notranslate"><span class="pre">map</span></code>. Si la usamos con un``Maybe``, aplicará <code class="docutils literal notranslate"><span class="pre">replicate</span> <span class="pre">3</span></code> al valor
contenido en <code class="docutils literal notranslate"><span class="pre">Just</span></code>, o si es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, devolverá <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap (replicate 3) [1,2,3,4]
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]
ghci&gt; fmap (replicate 3) (Just 4)
Just [4,4,4]
ghci&gt; fmap (replicate 3) (Right &quot;blah&quot;)
Right [&quot;blah&quot;,&quot;blah&quot;,&quot;blah&quot;]
ghci&gt; fmap (replicate 3) Nothing
Nothing
ghci&gt; fmap (replicate 3) (Left &quot;foo&quot;)
Left &quot;foo&quot;
</pre></div>
</div>
<p>Ahora vamos a ver las <strong>leyes de los funtores</strong>. Para que algo sea una funtor,
debe satisfacer una serie de leyes. Se espera que todos los funtores exhiban
una serie de propiedades y comportamientos. Deben comportarse fielmente como
cosas que se puedan mapear. Al llamar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre un funtor solo debe
mapear una función sobre ese funtor, nada más. Este comportamiento se describe
en las leyes de los funtores. Hay dos de ellas que todas las instancias de
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> deben cumplir. Haskell no comprueba estas leyes automáticamente,
así que tenemos que comprobarlas nosotros mismos.</p>
<p><strong>La primera ley de funtores establece que si mapeamos la función</strong> <code class="docutils literal notranslate"><span class="pre">id</span></code>
<strong>sobre un funtor, el funtor que obtenemos debe ser igual que el original</strong>.
Si lo escribimos algo más formal, sería <code class="xref js js-data docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">id</span></code>. Básicamente
dice que, si usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">id</span></code> sobre un funtor, debe devolver lo mismo que
si aplicamos <code class="docutils literal notranslate"><span class="pre">id</span></code> a ese funtor. Recuerda, <code class="docutils literal notranslate"><span class="pre">id</span></code> es la función identidad, la
cual devuelve el parámetro original que le pasemos. También se pude definir
como <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x</span></code>. Si vemos el funtor como algo que puede ser mapeado, la ley
<code class="xref js js-data docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">id</span></code> es bastante trivial y obvia.</p>
<p>Vamos a ver si esta ley se cumple para algunos funtores:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap id (Just 3)
Just 3
ghci&gt; id (Just 3)
Just 3
ghci&gt; fmap id [1..5]
[1,2,3,4,5]
ghci&gt; id [1..5]
[1,2,3,4,5]
ghci&gt; fmap id []
[]
ghci&gt; fmap id Nothing
Nothing
</pre></div>
</div>
<p>Si vemos la definición de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> para, digamos, el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, podemos
averiguar porque la primera ley se cumple:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>Imaginamos que <code class="docutils literal notranslate"><span class="pre">if</span></code> hace el papel del parámetro <code class="docutils literal notranslate"><span class="pre">f</span></code> en la implementación.
Vemos que si mapeamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">id</span></code> sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">x</span></code>, el resultado será
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(id</span> <span class="pre">x)</span></code>, y como <code class="docutils literal notranslate"><span class="pre">id</span></code> simplemente devuelve su parámetro, podemos
deducir que <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(id</span> <span class="pre">x)</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">x</span></code>. De esta forma ahora sabemos
que si mapeamos <code class="docutils literal notranslate"><span class="pre">id</span></code> sobre un valor de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> con un constructor de datos
<code class="docutils literal notranslate"><span class="pre">Just</span></code>, obtenemos lo mismo como resultado.</p>
<p>Demostrar que al mapear <code class="docutils literal notranslate"><span class="pre">id</span></code> sobre un valor <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> devuelve el mismo
valor es trivial. Así que a partir de estas dos ecuaciones de la
implementación de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> podemos decir que la ley <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">id</span> <span class="pre">=</span> <span class="pre">id</span></code> se
cumple.</p>
<img alt="La justicia es ciega, aunque también mi perro." class="align-left" src="../_images/justice.png" />
<p><strong>La segunda ley dice que si mapeamos el resultado de una composición de dos
funciones sobre un funtor debe devolver lo mismo que si mapeamos una de estas
funciones sobre el funtor inicial y luego mapeamos la otra función</strong>. Escrito
formalmente sería <code class="xref js js-data docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">=</span> <span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">.</span> <span class="pre">fmap</span> <span class="pre">g</span></code>. O de otra forma
sería, para cualquier funtor <code class="docutils literal notranslate"><span class="pre">F</span></code>,
<code class="xref js js-data docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">F</span> <span class="pre">=</span> <span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">(fmap</span> <span class="pre">g</span> <span class="pre">F)</span></code>.</p>
<p>Si podemos demostrar que un funtor cumple las dos leyes, podemos confiar en
que dicho funtor tendrá el mismo comportamiento que los demás funtores.
Sabremos que cuando utilizamos <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre él, no pasará nada más que no
conozcamos y que se comportará como algo que puede ser mapeado, es decir, un
funtor. Puedes averiguar si se cumple la segunda ley para cierto tipo viendo
la implementación de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> de ese tipo y utilizando luego el mismo método
que hemos utilizado para ver si <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> cumplía la primera ley.</p>
<p>Si quieres, podemos comprobar como se cumple la segunda ley de los funtores
para <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Si hacemos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> obtenemos
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, ya que al mapear cualquier función sobre <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> devuelve
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Si hacemos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">(fmap</span> <span class="pre">g</span> <span class="pre">Nothing)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>,
obtenemos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> por el mismo motivo. Vale, comprobar como se cumple la
segunda ley para <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> si es un valor <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> es bastante sencillo,
casi trivial.</p>
<p>¿Qué pasa cuando tenemos un valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code>?  Bueno, si hacemos
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">(Just</span> <span class="pre">x)</span></code>, a partir de la implementación vemos que convierte
en <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">((f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">x)</span></code>, que es lo mismo que <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(f</span> <span class="pre">(g</span> <span class="pre">x))</span></code>. Si hacemos
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">(fmap</span> <span class="pre">g</span> <span class="pre">(Just</span> <span class="pre">x))</span></code>, a partir de la implementación vemos que
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">g</span> <span class="pre">(Just</span> <span class="pre">x)</span></code> es <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(g</span> <span class="pre">x)</span></code>. Ergo, <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">(fmap</span> <span class="pre">g</span> <span class="pre">(Just</span> <span class="pre">x))</span></code> es
igual a <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">(Just</span> <span class="pre">(g</span> <span class="pre">x))</span></code> y a partir de la implementación vemos que esto
es igual a <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(f</span> <span class="pre">(g</span> <span class="pre">x))</span></code>.</p>
<p>Si esta demostración te confunde un poco, no te preocupes. Asegúrate de
entender como funciona la <a class="reference internal" href="ordensuperior.html#compfunc"><span class="std std-ref">composición de funciones</span></a>. La mayor
parte de las veces puedes ver como se cumplen estas leyes de forma intuitiva
porque los tipos actúan como contenedores o funciones. También puedes
probarlas con cierta seguridad usando un montón de valores diferentes de un
cierto tipo y comprobar que, efectivamente, las leyes se cumplen.</p>
<p>Vamos a ver un ejemplo patológico de un constructor de tipos que tenga una
instancia de clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code> pero que en realidad no sea un funtor,
debido a que satisface las leyes. Digamos que tenemos el siguiente tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">CMaybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">CNothing</span> <span class="o">|</span> <span class="kt">CJust</span> <span class="kt">Int</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>La <em>C</em> viene de <em>contador</em>. Es un tipo de datos que se parece mucho a
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>, solo que la parte <code class="docutils literal notranslate"><span class="pre">Just</span></code> contiene dos campos en lugar de uno.
El primer campo del constructor de datos <code class="docutils literal notranslate"><span class="pre">CJust</span></code> siempre tiene el tipo
<code class="docutils literal notranslate"><span class="pre">Int</span></code>, que es una especie de contador, mientras que el segundo campo tiene
el tipo <code class="docutils literal notranslate"><span class="pre">a</span></code>, que procede del parámetro de tipo y su tipo será el tipo
concreto que elijamos para <code class="docutils literal notranslate"><span class="pre">CMaybe</span> <span class="pre">a</span></code>. Vamos a jugar un poco con este nuevo
tipo para ver como funciona.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; CNothing
CNothing
ghci&gt; CJust 0 &quot;haha&quot;
CJust 0 &quot;haha&quot;
ghci&gt; :t CNothing
CNothing :: CMaybe a
ghci&gt; :t CJust 0 &quot;haha&quot;
CJust 0 &quot;haha&quot; :: CMaybe [Char]
ghci&gt; CJust 100 [1,2,3]
CJust 100 [1,2,3]
</pre></div>
</div>
<p>Cuando usamos el constructor <code class="docutils literal notranslate"><span class="pre">CNothing</span></code>, no hay ningún campo que rellenar,
mientras que si usamos el constructor <code class="docutils literal notranslate"><span class="pre">CJust</span></code>, el primer campo será un
entero y el segundo campo podrá ser de cualquier tipo. Vamos a crear una
instancia para la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code> de forma que cada vez que usemos
<code class="docutils literal notranslate"><span class="pre">fmap</span></code>, la función sea aplicada al segundo campo, mientras que el contador
sea incrementado en uno.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">CMaybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">CNothing</span> <span class="ow">=</span> <span class="kt">CNothing</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">CJust</span> <span class="n">counter</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">CJust</span> <span class="p">(</span><span class="n">counter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Se parece a la implementación de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, exceptuando que cuando aplicamos
<code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre un valor que no representa una caja vacía (un valor <code class="docutils literal notranslate"><span class="pre">CJust</span></code>),
no solo aplicamos la función al contenido de la caja, sino que además
incrementamos el contador en uno. Parece que todo está bien hasta ahora,
incluso podemos probarlo un poco:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap (++&quot;ha&quot;) (CJust 0 &quot;ho&quot;)
CJust 1 &quot;hoha&quot;
ghci&gt; fmap (++&quot;he&quot;) (fmap (++&quot;ha&quot;) (CJust 0 &quot;ho&quot;))
CJust 2 &quot;hohahe&quot;
ghci&gt; fmap (++&quot;blah&quot;) CNothing
CNothing
</pre></div>
</div>
<p>¿Cumple con las leyes de los funtores? Para demostrar que no cumple las leyes,
basta con encontrar un contraejemplo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap id (CJust 0 &quot;haha&quot;)
CJust 1 &quot;haha&quot;
ghci&gt; id (CJust 0 &quot;haha&quot;)
CJust 0 &quot;haha&quot;
</pre></div>
</div>
<p>¡Ah! Sabemos que la primera ley de los funtores dice que si mapeamos <code class="docutils literal notranslate"><span class="pre">id</span></code>
sobre un funtor, debe devolver lo mismo que llamamos <code class="docutils literal notranslate"><span class="pre">id</span></code> con ese mismo
funtor, pero como hemos visto en este ejemplo, esta ley no se cumple para el
funtor <code class="docutils literal notranslate"><span class="pre">CMaybe</span></code>. Aunque forma parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, no
cumple las leyes de los funtores y por lo tanto no es un funtor. Si alguien
usará <code class="docutils literal notranslate"><span class="pre">CMaybe</span></code> como un funtor, esperaría que obedeciera las leyes de los
funtores como un buen funtor. Pero <code class="docutils literal notranslate"><span class="pre">CMaybe</span></code> falla a la hora de ser un
funtor aunque pretende serlo, así que usarlo como un funtor nos puede llevar
a un código erróneo. Cuando utilizamos un funtor, no nos debe importar si
primero unimos unas cuantas funciones usando una composición y luego la
mapeamos sobre un funtor o si mapeamos unas cuantas funciones sobre un funtor
sucesivamente. Pero con <code class="docutils literal notranslate"><span class="pre">CMaybe</span></code> si importa, ya que lleva una cuenta de
cuantas veces ha sido mapeado ¡Mal! Si quisiéramos que <code class="docutils literal notranslate"><span class="pre">CMaybe</span></code> cumpliera
las leyes de los funtores, deberíamos hacer que el campo <code class="docutils literal notranslate"><span class="pre">Int</span></code> se mantuviera
constante utilizamos <code class="docutils literal notranslate"><span class="pre">fmap</span></code>.</p>
<p>En un principio las leyes de los funtores pueden parecer un poco confusas e
innecesarias, pero luego vemos que si sabemos que un tipo cumple con ambas
leyes, podemos asumir como se comportará. Si un tipo cumple las leyes de los
funtores, sabemos que si llamamos a <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre un valor de ese tipo solo
mapeará la función sobre ese funtor, nada más. Esto nos lleva a un código que
es más abstracto y extensible, ya que podemos utilizar las leyes para razonar
acerca del comportamiento que un funtor debe tener y crear funciones que
operen de forma fiable sobre funtores.</p>
<p>Todas las instancias de los funtores de la biblioteca estándar cumplen con
estas leyes, aunque puedes comprobarlo tu mismo si no me crees. La próxima vez
que hagas una instancia <code class="docutils literal notranslate"><span class="pre">Functor</span></code> para un tipo, tómate tu tiempo para
asegurarte de que cumple con las leyes de los funtores. Cuando hayas trabajado
lo suficiente con los funtores, sabrás ver de forma intuitiva las propiedades
y comportamientos que tienen en común los funtores y te será muy fácil decir
si un funtor cumple o no con estas leyes. Aún sin esta experiencia, siempre
puedes leer la implementación línea a línea y ver si las leyes se cumplen o
intentar descubrir algún contraejemplo.</p>
<p>También podemos ver los funtores como resultados en un cierto contexto. Por
ejemplo, <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> tiene un resultado igual a <code class="docutils literal notranslate"><span class="pre">3</span></code> en el contexto de que
puede existir un resultado o no. <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code> contiene tres resultados, <code class="docutils literal notranslate"><span class="pre">1</span></code>,
<code class="docutils literal notranslate"><span class="pre">2</span></code> y <code class="docutils literal notranslate"><span class="pre">3</span></code>, en el contexto de que pueden haber varios resultados o incluso
ninguno. La función <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> dará un resultado, dependiendo del parámetro que
se le de.</p>
<p>Si ves los funtores como cosas que puede producir resultados, puedes pensar
que mapear algo sobre un funtor es como añadir una transformación al resultado
de ese funtor que modificará el resultado. Cuando hacemos
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+3)</span> <span class="pre">[1,2,3]</span></code>, añadimos la transformación <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> al resultado
<code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code>, de forma que cada vez que encuentre un número en la lista
resultante, se le aplicará <code class="docutils literal notranslate"><span class="pre">(+3)</span></code>. Otro ejemplo sería mapear sobre
funciones. Cundo hacemos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+3)</span> <span class="pre">(*3)</span></code>, añadimos la transformación
<code class="docutils literal notranslate"><span class="pre">(+3)</span></code> al resultado final de <code class="docutils literal notranslate"><span class="pre">(*3)</span></code>. Verlo de este modo nos da un pista de
porque al usar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre funciones equivale a componer funciones
(<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+3)</span> <span class="pre">(*3)</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">(+3)</span> <span class="pre">.</span> <span class="pre">(*3)</span></code>, que equivale a
<code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">((x*3)+3)</span></code>), ya que si tomamos una función como <code class="docutils literal notranslate"><span class="pre">(*3)</span></code> le añadimos
la transformación <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> a su resultado. Al final seguiremos teniendo una
función, solo que cuando le demos un número, primero se multiplicará por tres
y luego se le sumará tres, que es exactamente lo mismo que sucede con la
composición de funciones.</p>
</div>
<div class="section" id="funtores-aplicativos">
<span id="aplicativos"></span><h2>Funtores aplicativos<a class="headerlink" href="#funtores-aplicativos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Ignora esta analogía." class="align-right" src="../_images/present.png" />
<p>En esta sección, daremos un vistazo a los funtores aplicativos, los cuales son
una especie de funtores aumentados, representados en Haskell por la clase de
tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, que se encuentra en <code class="docutils literal notranslate"><span class="pre">Control.Applicative</span></code>.</p>
<p>Como ya sabes, las funciones en Haskell están currificadas por defecto, lo que
significa que las funciones que parecen que toman varios parámetros en
realidad solo toman un parámetro y devuelven una función que tomará el
siguiente parámetro y así sucesivamente. Si una función tiene el tipo
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>, normalmente decimos que toma dos parámetros y devuelve un
<code class="docutils literal notranslate"><span class="pre">c</span></code>, pero en realidad toma un <code class="docutils literal notranslate"><span class="pre">a</span></code> y devuelve una función <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></code>. Por
este motivo podemos aplicar esta función como <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span></code> o como <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">y</span></code>.
Este mecanismo es el que nos permite aplicar parcialmente las funciones
simplemente pasándoles menos parámetros de los que necesitan, de forma que
obtenemos nuevas funciones que probablemente pasaremos a otras funciones.</p>
<p>Hasta ahora, cuando mapeamos funciones sobre funtores, normalmente mapeamos
funciones que toman un solo parámetro. Pero ¿Qué sucede si mapeamos una
función como <code class="docutils literal notranslate"><span class="pre">*</span></code>, que toma dos parámetros, sobre un funtor? Vamos a ver
varios ejemplo concretos. Si tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> y hacemos
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(*)</span> <span class="pre">(Just</span> <span class="pre">3)</span></code> ¿Qué obtenemos? A partir de la implementación de la
instancia <code class="docutils literal notranslate"><span class="pre">Functor</span></code> de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, sabemos que es un valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code>,
aplicará la función <code class="docutils literal notranslate"><span class="pre">*</span></code> dentro de <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Así pues, al hacer
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(*)</span> <span class="pre">(Just</span> <span class="pre">3)</span></code> obtenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">((*)</span> <span class="pre">3)</span></code>, que también puede escribirse
usando secciones como <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(*</span> <span class="pre">3)</span></code> ¡Interesante! ¡Ahora tenemos una función
dentro de un <code class="docutils literal notranslate"><span class="pre">Just</span></code>!</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t fmap (++) (Just &quot;hey&quot;)
fmap (++) (Just &quot;hey&quot;) :: Maybe ([Char] -&gt; [Char])
ghci&gt; :t fmap compare (Just &#39;a&#39;)
fmap compare (Just &#39;a&#39;) :: Maybe (Char -&gt; Ordering)
ghci&gt; :t fmap compare &quot;A LIST OF CHARS&quot;
fmap compare &quot;A LIST OF CHARS&quot; :: [Char -&gt; Ordering]
ghci&gt; :t fmap (\x y z -&gt; x + y / z) [3,4,5,6]
fmap (\x y z -&gt; x + y / z) [3,4,5,6] :: (Fractional a) =&gt; [a -&gt; a -&gt; a]
</pre></div>
</div>
<p>Si mapeamos <code class="docutils literal notranslate"><span class="pre">compare</span></code>, que tiene un tipo <code class="docutils literal notranslate"><span class="pre">(Ord</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Ordering</span></code>
sobre una lista de caracteres, obtenemos una lista de funciones del tipo
<code class="docutils literal notranslate"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Ordering</span></code>, ya que la función <code class="docutils literal notranslate"><span class="pre">compare</span></code> se aplica parcialmente
a cada uno de los caracteres de la lista. No es una lista de funciones
<code class="docutils literal notranslate"><span class="pre">(Ord</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Ordering</span></code>, ya que como el primer <code class="docutils literal notranslate"><span class="pre">a</span></code> ha sido fijado a
<code class="docutils literal notranslate"><span class="pre">Char</span></code> el segundo también debe ser <code class="docutils literal notranslate"><span class="pre">Char</span></code>.</p>
<p>Vemos que si aplicamos funciones con varios parámetros sobre funtores,
obtenemos funtores que contienen funciones. Así que ¿Qué podemos hacer ahora
con ellos? Bien, podemos mapear funciones que toman estas funciones como
parámetros sobre ellos, ya que cualquier cosa que este dentro de un funtor
será pasado a la función que mapeamos.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let a = fmap (*) [1,2,3,4]
ghci&gt; :t a
a :: [Integer -&gt; Integer]
ghci&gt; fmap (\f -&gt; f 9) a
[9,18,27,36]
</pre></div>
</div>
<p>Pero ¿Y si tenemos un valor funtor de <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(3</span> <span class="pre">*)</span></code> y un valor funtor de
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">5</span></code> y queremos sacar la función de <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(3</span> <span class="pre">*)</span></code> y mapearla sobre
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">5</span></code>? Con los funtores normales no tendríamos mucha suerte, ya que lo
único que soportan es mapear funciones normales sobre funtores. Incluso aunque
mapeáramos <code class="docutils literal notranslate"><span class="pre">\f</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">9</span></code> sobre un funtor que contuviese funciones, estaríamos
mapeando simples funciones normales. No podemos mapear funciones que están
dentro de un funtor sobre otro funtor con lo que nos ofrece <code class="docutils literal notranslate"><span class="pre">fmap</span></code>.
Podríamos usar un ajuste de patrones con el constructor <code class="docutils literal notranslate"><span class="pre">Just</span></code> para extraer
la función y luego mapearla sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">5</span></code>, pero estamos buscando algo
más abstracto, general y que funcione junto a los funtores.</p>
<p>Te presento la clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>. Reside en el módulo
<code class="docutils literal notranslate"><span class="pre">Control.Applicative</span></code> y define dos métodos, <code class="docutils literal notranslate"><span class="pre">pure</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>. No
proporciona ninguna implementación por defecto para ninguno de los dos, así
que tenemos que definir ambos si queremos que algo sea un funtor aplicativo.
La clase se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Estas tres simples líneas nos dicen mucho. Vamos a empezar por la primera
línea. Empieza con la definición de la clase <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> y también
presenta una restricción de clase. Dice que si queremos que un constructor de
tipos forme parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, tiene que ser primero
parte de clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. De este modo si sabemos que un constructor de
tipos es parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, también lo es de
<code class="docutils literal notranslate"><span class="pre">Functor</span></code>, así que podemos usar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre él.</p>
<p>El primer método que define se llama <code class="docutils literal notranslate"><span class="pre">pure</span></code>. Su declaración de tipo es
<code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code>. <code class="docutils literal notranslate"><span class="pre">f</span></code> juega el papel del funtor aplicativo de la
instancia. Como Haskell tiene un buen sistema de tipos y como todo lo que
puede hacer una función es tomar un parámetro y devolver algún valor, podemos
deducir muchas cosas únicamente a partir de la declaración de tipos, y este
caso no es una excepción. <code class="docutils literal notranslate"><span class="pre">pure</span></code> debe tomar un valor de cualquier tipo y
devolver un funtor aplicativo que contiene ese valor. Cuando decimos
<em>que contiene</em>, estamos usando la analogía de la caja de nuevo, aunque ya
hemos visto que esta comparación no siempre es perfecta. Aun así, la
declaración <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span></code> es bastante descriptiva. Tomamos un valor y lo
introducimos en un funtor aplicativo que contendrá ese valor como resultado.</p>
<p>Una forma mejor de entender <code class="docutils literal notranslate"><span class="pre">pure</span></code> sería decir que toma un valor y lo
introduce en una especie de contexto por defecto (o contexto puro), es decir,
el contexto mínimo para albergar ese valor.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es realmente interesante. Tiene como declaración de tipo
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code> ¿Te recuerda a algo? Por supuesto,
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code>. Es una especie de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> modificado.
Mientras que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> toma una función y un funtor y aplica esa función dentro
del funtor, mientras que <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> toma un funtor que contenga una función y
otro funtor de forma que extrae esa función del primer funtor y la mapea sobre
el segundo funtor. Cuando decimos <code class="docutils literal notranslate"><span class="pre">extrae</span></code>, en realidad es algo como ejecuta
y luego extrae, quizá incluso secuenciar. Lo veremos pronto.</p>
<p>Vamos a echar un vistazo a la implementación de la instancia <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>
de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="kt">Just</span>
    <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">something</span>
</pre></div>
</div>
<p>De nuevo, a partir de la definición de la clase venos que <code class="docutils literal notranslate"><span class="pre">f</span></code> toma el papel
funtor aplicativo que toma un tipo concreto como parámetro, así que escribimos
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Applicative</span> <span class="pre">Maybe</span> <span class="pre">where</span></code> en lugar de
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Applicative</span> <span class="pre">(Maybe</span> <span class="pre">a)</span> <span class="pre">where</span></code>.</p>
<p>Antes de nada, <code class="docutils literal notranslate"><span class="pre">pure</span></code>. Antes hemos dicho que se supone que éste toma algo
y lo introduce en un funtor aplicativo. Hemos escrito <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">=</span> <span class="pre">Just</span></code>, ya que
los constructores de datos como <code class="docutils literal notranslate"><span class="pre">Just</span></code> son funciones normales. También
podríamos haber escrito <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">Just</span> <span class="pre">x</span></code>.</p>
<p>Luego, tenemos la definición de <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>. No podemos extraer una función de
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, ya que no hay nada dentro él. Así que decimos que si intentamos
extraer una función de un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, el resultado será <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Si vemos
la definición de clase de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, veremos que hay una restricción de
clase a <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, lo cual significa que podemos asumir que ambos parámetros
de <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> son funtores. Si el primer parámetro no es un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, si no un
<code class="docutils literal notranslate"><span class="pre">Just</span></code> con una función en su interior, diremos que queremos mapear esa
función sobre el segundo parámetro. Esto también tiene en cuenta el caso en el
que el segundo parámetro sea <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, ya que aplicar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> con
cualquier función sobre <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Así que para <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> extrae la función de su operando izquierdo si
es un <code class="docutils literal notranslate"><span class="pre">Just</span></code> y lo mapea sobre su operando derecho. Si alguno de estos
parámetros es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> será el resultado.</p>
<p>Vale, genial. Vamos a probarlo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Just (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; pure (+3) &lt;*&gt; Just 10
Just 13
ghci&gt; pure (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; Just (++&quot;hahah&quot;) &lt;*&gt; Nothing
Nothing
ghci&gt; Nothing &lt;*&gt; Just &quot;woot&quot;
Nothing
</pre></div>
</div>
<p>Vemos que tanto <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">(+3)</span></code> como <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(3)</span></code> son iguales en este caso.
Utiliza <code class="docutils literal notranslate"><span class="pre">pure</span></code> cuando trabajes con valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> en un contexto
aplicativo (es decir, cuando los utilices junto <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>), de cualquier otro
modo sigue fiel a <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Las primeras cuatro líneas de entrada demuestran
como una función es extraída y luego mapeada, pero en este caso, podría haber
sido logrado simplemente mapeando funciones normales sobre funtores. La última
línea es interesante, ya que intentamos extraer una función de un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>
y luego mapearla, lo cual es por supuesto <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Con los funtores normales solo podemos mapear una función sobre un
funtor, luego no podemos extraer el resultado de forma general, incluso aunque
el resultado sea una función parcialmente aplicada. Los funtores aplicativos,
por otra parte, te permiten operar con varios funtores con una única función.
Mira esto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Nothing
Nothing
ghci&gt; pure (+) &lt;*&gt; Nothing &lt;*&gt; Just 5
Nothing
</pre></div>
</div>
<img alt="Ballenaaa." class="align-right" src="../_images/whale.png" />
<p>¿Qué esta pasando aquí? Vamos a echar un vistazo paso a paso. <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es
asociativo por la izquierda, por lo tanto <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">(+)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">3</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">5</span></code>
es lo mismo que <code class="docutils literal notranslate"><span class="pre">(pure</span> <span class="pre">(+)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">3)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">5</span></code>. Primero, la función
<code class="docutils literal notranslate"><span class="pre">+</span></code> se introduce en un funtor, en este caso un valor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> que contiene
esa función. Así que al principio tenemos <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">(+)</span></code> que es lo mismo que
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(+)</span></code>. Luego tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(+)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">3</span></code>, cuyo resultado, debido a
que se aplica parcialmente la función, es <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(3+)</span></code>. Al aplicar <code class="docutils literal notranslate"><span class="pre">3</span></code> a la
función <code class="docutils literal notranslate"><span class="pre">+</span></code> obtenemos una nueva función que tomará un parámetro y le
añadirá 3. Para terminar, llegamos a <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(3+)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">5</span></code>, que resulta en
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">8</span></code>.</p>
<p>¿No es increíble? Los funtores aplicativos y el estilo aplicativo de hacer
<code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">x</span> <span class="pre">&lt;*&gt;</span> <span class="pre">y</span> <span class="pre">&lt;*&gt;</span> <span class="pre">...</span></code> nos permiten tomar una función que espera
parámetros que no son necesariamente funtores y utilizarla para operar con
varios valores que están en algún contexto funtor. La función puede tomar
tantos parámetros como queramos, ya que será aplicada parcialmente paso a paso
cada vez que aparezca un <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>.</p>
<p>Todo esto se vuelve más útil y aparente si consideramos el hecho de que
<code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">x</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">x</span></code>. Esta es una de la leyes aplicativas.
Las veremos en detalle más adelante, pero por ahora, podemos ver de forma
intuitiva su significado. Piensa un poco en ello, tiene sentido. Como ya hemos
dicho, <code class="docutils literal notranslate"><span class="pre">pure</span></code> inserta un valor en un contexto por defecto. Si todo lo que
hacemos es insertar una función en un contexto por defecto y luego la
extraemos para aplicarla a un valor contenido en un funtor aplicativo, es lo
mismo que simplemente mapear la función sobre ese funtor aplicativo. En
lugar de escribir <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">x</span> <span class="pre">&lt;*&gt;</span> <span class="pre">y</span> <span class="pre">&lt;*&gt;</span> <span class="pre">...</span></code> podemos usar
<code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">&lt;*&gt;</span> <span class="pre">y</span> <span class="pre">&lt;*&gt;</span> <span class="pre">...</span></code>. Por este motivo <code class="docutils literal notranslate"><span class="pre">Control.Applicative</span></code> exporta
una función llamada <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code>, que es simplemente <code class="docutils literal notranslate"><span class="pre">fmap</span></code> como operador infijo.
Así se define:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="nf">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Recuerda, las variables de tipo son independientes de los nombres de
los parámetros o de otro nombres de valores. La <code class="docutils literal notranslate"><span class="pre">f</span></code> en la
declaración de la función es una variable de tipo con una
restricción de clase diciendo que cualquier constructor de tipos que
reemplace a <code class="docutils literal notranslate"><span class="pre">f</span></code> de ser miembro de la clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. La <code class="docutils literal notranslate"><span class="pre">f</span></code>
que aparece en el cuerpo de la función representa la función que
mapearemos sobre <code class="docutils literal notranslate"><span class="pre">x</span></code>. El hecho de que usemos <code class="docutils literal notranslate"><span class="pre">f</span></code> para
representar ambos no significa que representen lo mismo.</p>
</div>
<p>El estilo aplicativo realmente destaca cuando utilizamos <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code>, ya que si
queremos aplicar un función <code class="docutils literal notranslate"><span class="pre">f</span></code> entre tres funtores aplicativos
podemos escribirlo así <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&lt;$&gt;</span> <span class="pre">x</span> <span class="pre">&lt;*&gt;</span> <span class="pre">y</span> <span class="pre">&lt;*&gt;</span> <span class="pre">z</span></code>. Si los parámetros no fueran
funtores aplicativos sino valores normales, lo habríamos escrito así
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></code>.</p>
<p>Vamos a ver más de cerca como funciona. Tenemos un valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;johntra&quot;</span></code> y
un valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;volta&quot;</span></code> y queremos unirlos en una sola <code class="docutils literal notranslate"><span class="pre">String</span></code> dentro
de un funtor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Hacemos esto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;
Just &quot;johntravolta&quot;
</pre></div>
</div>
<p>Antes de que veamos qué sucede aquí, compara lo anterior con esto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (++) &quot;johntra&quot; &quot;volta&quot;
&quot;johntravolta&quot;
</pre></div>
</div>
<p>¡Bien! Para usar una función normal con funtores aplicativos, simplemente
tenemos que esparcir unos cuantos <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> y la función
operará sobre funtores aplicativos ¿No es genial?</p>
<p>De cualquier modo, cuando hacemos
<code class="docutils literal notranslate"><span class="pre">(++)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">&quot;johntra&quot;</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">&quot;volta&quot;</span></code>, primero <code class="docutils literal notranslate"><span class="pre">(++)</span></code>, que tiene un
tipo <code class="docutils literal notranslate"><span class="pre">(++)</span> <span class="pre">::</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>, se mapea sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;johntra&quot;</span></code>, lo cual
da como resultado un valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(&quot;johntra&quot;++)</span></code> cuyo tipo es
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">([Char]</span> <span class="pre">-&gt;</span> <span class="pre">[Char])</span></code>. Fíjate como el primer parámetro de <code class="docutils literal notranslate"><span class="pre">(++)</span></code> ha
desaparecido y que <code class="docutils literal notranslate"><span class="pre">a</span></code> se ha convertido en un <code class="docutils literal notranslate"><span class="pre">Char</span></code>. Luego nos
encontramos con <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(&quot;johntra&quot;++)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">&quot;volta&quot;</span></code>, que extrae la
función que se encuentra en el primer <code class="docutils literal notranslate"><span class="pre">Just</span></code> y la mapea sobre
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;volta&quot;</span></code>, lo cual devuelve <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;johntravolta&quot;</span></code>. Si alguno de los
dos valores hubiera sido <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, el resultado habría sido <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Hasta ahora, solo hemos usado <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> en nuestros ejemplos y puede que estés
pensado que los funtores aplicativos solo funcionan con <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Existen un
buen puñado de instancias de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, así que vamos a probarlas.</p>
<p>Las listas (en realidad, el constructor de tipos <code class="docutils literal notranslate"><span class="pre">[]</span></code>) son funtores
aplicativos ¡Qué sorpresa! Aquí tienes la instancia de <code class="docutils literal notranslate"><span class="pre">[]</span></code> para
<code class="docutils literal notranslate"><span class="pre">Applicative</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<p>Antes dijimos que <code class="docutils literal notranslate"><span class="pre">pure</span></code> toma un valor y lo inserta en un contexto por
defecto. En otras palabras, un contexto mínimo que contenga ese valor. El
contexto mínimo para las listas sería la lista vacía, <code class="docutils literal notranslate"><span class="pre">[]</span></code>, pero la lista
vacía representa el hecho de tener un valor, así que no puede mantener un
valor por si mismo. Por este motivo, <code class="docutils literal notranslate"><span class="pre">pure</span></code> toma un valor y lo introduce en
una lista unitaria. De forma similar, el contexto mínimo para el funtor
aplicativo de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> sería <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, pero este representa el hecho de
no tener un valor, así que <code class="docutils literal notranslate"><span class="pre">pure</span></code> está implementado usando <code class="docutils literal notranslate"><span class="pre">Just</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; pure &quot;Hey&quot; :: [String]
[&quot;Hey&quot;]
ghci&gt; pure &quot;Hey&quot; :: Maybe String
Just &quot;Hey&quot;
</pre></div>
</div>
<p>¿Qué pasa con <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>? Si vemos el tipo de <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> como si estuviera limitado
a las listas tendríamos algo como <code class="docutils literal notranslate"><span class="pre">(&lt;*&gt;)</span> <span class="pre">::</span> <span class="pre">[a</span> <span class="pre">-&gt;</span> <span class="pre">b]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code>. Está
implementado usado <span class="xref std std-ref">listas por comprensión</span>. <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> debe
extraer de alguna forma la función que contiene el primer parámetro y mapearla
sobre el segundo parámetro. El problema es que aquí puede haber una función,
varias de ellas, o incluso ninguna. La lista de la derecha también puede
contener varios valores. Por este motivo se utiliza una lista por comprensión
para extraer valores de ambas listas. Aplicamos cada posible función de la
lista de la izquierda en cada posible valor de la lista de la derecha. El
resultado será una lista con cada posible combinación de aplicar una función
de la primera lista sobre un valor de la segunda lista.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [(*0),(+100),(^2)] &lt;*&gt; [1,2,3]
[0,0,0,101,102,103,1,4,9]
</pre></div>
</div>
<p>La lista de la izquierda tiene tres funciones y la lista de la derecha tiene
tres valores, así que el resultado tendrá nueve elementos. Cada función de la
lista de la izquierda se aplica a cada valor de la lista de la derecha. Si
tuviéramos funciones que tomen dos parámetros, podemos aplicar estas funciones
entre dos listas.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [(+),(*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4]
[4,5,5,6,3,4,6,8]
</pre></div>
</div>
<p>Como <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es asociativo por la izquierda, lo primero que se resuelve es
<code class="docutils literal notranslate"><span class="pre">[(+),(*)]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[1,2]</span></code>, que da como resultado una lista como esta
<code class="docutils literal notranslate"><span class="pre">[(1+),(2+),(1*),(2*)]</span></code>, ya que cada función de la lista de la izquierda se
aplica a cada valor de la lista de la derecha. Luego, se calcula
<code class="docutils literal notranslate"><span class="pre">[(1+),(2+),(1*),(2*)]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[3,4]</span></code>, que devuelve el resultado anterior.</p>
<p>Usar el estilo aplicativo con listas es divertido. Mira:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (++) &lt;$&gt; [&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;] &lt;*&gt; [&quot;?&quot;,&quot;!&quot;,&quot;.&quot;]
[&quot;ha?&quot;,&quot;ha!&quot;,&quot;ha.&quot;,&quot;heh?&quot;,&quot;heh!&quot;,&quot;heh.&quot;,&quot;hmm?&quot;,&quot;hmm!&quot;,&quot;hmm.&quot;]
</pre></div>
</div>
<p>De nuevo, fíjate en que hemos usado una función normal que toma dos cadenas
entre dos funtores aplicativos de cadenas simplemente insertando los
operadores aplicativos apropiados.</p>
<p>Puedes ver las listas como computaciones no deterministas. Un valor como
<code class="docutils literal notranslate"><span class="pre">100</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;que&quot;</span></code> puede ser visto como una computación determinista que solo
tienen un valor, mientras que una lista como <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code> puede ser visto como
un computación que no puede decidir que resultado queremos, así que nos
muestra una lista con todos los resultados posibles. Así que cuando hacemos
algo como <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2,3]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[4,5,6]</span></code>, puedes pensar que se trata de
sumar dos computaciones no deterministas con <code class="docutils literal notranslate"><span class="pre">+</span></code>, para que produzca otra
computación no determinista que esté incluso menos segura de que valor es el
resultado final.</p>
<p>El estilo aplicativo con listas suele ser un buen remplazo par la listas por
comprensión. En el segundo capítulo, queríamos saber todos los posibles
productos entre <code class="docutils literal notranslate"><span class="pre">[2,5,10]</span></code> y <code class="docutils literal notranslate"><span class="pre">[8,10,11]</span></code>, así que hicimos esto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110]
</pre></div>
</div>
<p>Simplemente extraemos valores de las dos listas y aplicamos una función para
combinar los elementos. Esto también se puede hacer usando el estilo
aplicativo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[16,20,22,40,50,55,80,100,110]
</pre></div>
</div>
<p>En mi opinión la segunda versión es más clara, ya que es más fácil de ver que
simplemente estamos aplicando <code class="docutils literal notranslate"><span class="pre">*</span></code> entre dos computaciones no deterministas.
Si quisiéramos todos los posibles productos entre ambas listas que fueran
mayores que 50, podríamos hacer algo como:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; filter (&gt;50) $ (*) &lt;$&gt; [2,5,10] &lt;*&gt; [8,10,11]
[55,80,100,110]
</pre></div>
</div>
<p>Es fácil de ver como <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">xs</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">xs</span></code> con la listas.
<code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span></code> es <code class="docutils literal notranslate"><span class="pre">[f]</span></code> y <code class="docutils literal notranslate"><span class="pre">[f]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">xs</span></code> aplicará cada función que esté en la
primera lista sobre cada valor que este en la segunda lista, pero solo hay una
función en la lista de la izquierda, así que es como un <code class="docutils literal notranslate"><span class="pre">fmap</span></code>.</p>
<p>Otra instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> con la que ya nos hemos encontrado es
<code class="docutils literal notranslate"><span class="pre">IO</span></code>. Así es como se implementa:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
    <span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">a</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">b</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<img alt="¡Jajaja!" class="align-left" src="../_images/knight.png" />
<p>Como todo lo que hace <code class="docutils literal notranslate"><span class="pre">pure</span></code> es insertar un valor en un contexto mínimo que
pueda albergar ese valor, tiene sentido que <code class="docutils literal notranslate"><span class="pre">pure</span></code> sea simplemente
<code class="docutils literal notranslate"><span class="pre">return</span></code>, ya que <code class="docutils literal notranslate"><span class="pre">return</span></code> hace exactamente eso: crea una acción de E/S
que no hace nada, simplemente tiene como resultado el valor que le pasemos,
pero en realidad no ejecuta ninguna operación de E/S como mostrar texto por
un terminal o leer algo de algún fichero.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> fuera exclusivo para <code class="docutils literal notranslate"><span class="pre">IO</span></code> su tipo sería
<code class="docutils literal notranslate"><span class="pre">(&lt;*&gt;)</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">b</span></code>. Tomaría una acción de E/S que
devuelve una función como resultado y otra acción de E/S y crearía una una
nueva acción de E/S a partir de estas dos, que cuando fuera ejecutada, primero
ejecutaría la primera acción para obtener la función y luego ejecutaría la
segunda acción para obtener un valor que luego aplicaría a la primera función
para obtener el resultado de la acción que crea. Hemos utilizado la <em>sintaxis
do</em> para implementarlo. Recuerda que la <em>sintaxis do</em> trata de tomar varias
acciones de E/S y unirlas en una sola, que es exactamente lo que hacemos aquí.</p>
<p>Con <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y <code class="docutils literal notranslate"><span class="pre">[]</span></code>, podemos que pensar que <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> simplemente extrae una
función de su parámetro izquierdo y luego lo aplica al de la derecha. Con
<code class="docutils literal notranslate"><span class="pre">IO</span></code>, seguimos extrayendo una función, pero ahora también existe una
<em>secuenciación</em> , ya que estamos tomando dos acciones de E/S y las estamos
secuenciando, o uniéndolas, en una sola acción. Hay que extraer una función
de la primera acción de E/S, pero para extraer un resultado de una acción de
E/S, primero tiene que ser ejecutada.</p>
<p>Considera esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myAction</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">myAction</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">a</span> <span class="o">++</span> <span class="n">b</span>
</pre></div>
</div>
<p>Esta acción de E/S preguntará al usuario por dos líneas de texto y las
devolverá concatenadas. Esto se consigue gracias a que hemos unido dos
acciones de E/S <code class="docutils literal notranslate"><span class="pre">getLine</span></code> y un <code class="docutils literal notranslate"><span class="pre">return</span></code>, ya que queríamos una nueva acción
de E/S que contuviera el resultado <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">++</span> <span class="pre">b++</span></code>. Otra forma de escribir esto
sería usando el estilo aplicativo.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">myAction</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">myAction</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">getLine</span> <span class="o">&lt;*&gt;</span> <span class="n">getLine</span>
</pre></div>
</div>
<p>Lo que hacíamos antes era crear una acción de E/S que aplicará una función
entre los resultados de otras dos acciones de E/S, y esto es exactamente lo
mismo. Recuerda, <code class="docutils literal notranslate"><span class="pre">getLine</span></code> es una acción de E/S con el tipo
<code class="docutils literal notranslate"><span class="pre">getLine</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">String</span></code>. Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> entre dos funtores
aplicativos, el resultado es un funtor aplicativo, así que parece que tiene
sentido.</p>
<p>Si volvemos a la analogía de la caja, podemos imaginar a <code class="docutils literal notranslate"><span class="pre">getLine</span></code> como
una caja que viajará al mundo real y nos traerá una cadena. Al hacer
<code class="docutils literal notranslate"><span class="pre">(++)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">getLine</span> <span class="pre">&lt;*&gt;</span> <span class="pre">getLine</span></code> creamos un nueva caja más grande, que
enviará esas dos cajas para obtener las dos líneas de la terminal y devolver
la concatenación de ambas como resultado.</p>
<p>El tipo de la expresión <code class="docutils literal notranslate"><span class="pre">(++)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">getLine</span> <span class="pre">&lt;*&gt;</span> <span class="pre">getLine</span></code> es <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">String</span></code>,
esto quiere decir que esta expresión es una acción de E/S normal y corriente
que también contiene un resultado, al igual que todas las demás acciones de
E/S. Por esta razón podemos hacer cosas como esta:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">getLine</span> <span class="o">&lt;*&gt;</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Las dos líneas concatenadas son: &quot;</span> <span class="o">++</span> <span class="n">a</span>
</pre></div>
</div>
<p>Si alguna vez te encuentras ligando una acción de E/S a algún nombre y luego
utilizas una función sobre ella para luego devolver ese valor como resultado
usando <code class="docutils literal notranslate"><span class="pre">return</span></code>, considera utilizar el estilo aplicativo ya que es sin
duda alguna más conciso.</p>
<p>Otra instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> es <code class="docutils literal notranslate"><span class="pre">(-&gt;</span> <span class="pre">r)</span></code>, es decir, funciones. No es
una instancia muy utilizada, pero sigue siendo interesante como aplicativo,
así que vamos a ver como se implementa.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si estas confudido acerca del significado de <code class="docutils literal notranslate"><span class="pre">(-&gt;</span> <span class="pre">r)</span></code>, revisa la
sección anterior donde explicamos como <code class="docutils literal notranslate"><span class="pre">(-&gt;</span> <span class="pre">r)</span></code> es un funtor.</p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Insertamos un valor dentro de un funtor aplicativo con <code class="docutils literal notranslate"><span class="pre">pure</span></code>, el resultado
que devuelva éste siempre debe ser el valor anterior. El contexto mínimo que
siga conteniendo ese valor como resultado. Por este motivo en la
implementación de la instancia funtor de las funciones, <code class="docutils literal notranslate"><span class="pre">pure</span></code> toma un valor
y crea una función que ignora su parámetro y devuelve siempre ese mismo valor.
Si vemos el tipo de <code class="docutils literal notranslate"><span class="pre">pure</span></code>, pero restringido al tipo de la instancia
<code class="docutils literal notranslate"><span class="pre">(-&gt;</span> <span class="pre">r)</span></code>, sería <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(r</span> <span class="pre">-&gt;</span> <span class="pre">a)</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (pure 3) &quot;blah&quot;
3
</pre></div>
</div>
<p>Gracias a la currificación, la aplicación de funciones es asociativa por la
izquierda, así que podemos omitir los paréntesis.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; pure 3 &quot;blah&quot;
3
</pre></div>
</div>
<p>La implementación de la instancia para <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es un poco críptica, así que
será mejor si simplemente vemos un ejemplo de como utilizar las funciones como
funtores aplicativos en estilo aplicativo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t (+) &lt;$&gt; (+3) &lt;*&gt; (*100)
(+) &lt;$&gt; (+3) &lt;*&gt; (*100) :: (Num a) =&gt; a -&gt; a
ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
508
</pre></div>
</div>
<p>Al llamar <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> con dos funtores aplicativos obtenemos otro funtor
aplicativo, así que si utilizamos dos funciones, obtenemos de nuevo una
función. Así que, ¿Qué sucede aquí? Cuando hacemos
<code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(+3)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(*100)</span></code>, creamos una función que utilizará <code class="docutils literal notranslate"><span class="pre">+</span></code> en los
resultados de <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> y <code class="docutils literal notranslate"><span class="pre">(*100)</span></code> y devolverá ese resultado. Para demostrar
este ejemplo real, hemos hecho <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(+3)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(*100)</span> <span class="pre">$</span> <span class="pre">5</span></code>, el primer
<code class="docutils literal notranslate"><span class="pre">5</span></code> se aplica a <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> y <code class="docutils literal notranslate"><span class="pre">(*100)</span></code>, obteniendo <code class="docutils literal notranslate"><span class="pre">8</span></code> y <code class="docutils literal notranslate"><span class="pre">500</span></code>. Luego, se
llama a <code class="docutils literal notranslate"><span class="pre">+</span></code> con <code class="docutils literal notranslate"><span class="pre">8</span></code> y <code class="docutils literal notranslate"><span class="pre">500</span></code>, obteniendo <code class="docutils literal notranslate"><span class="pre">508</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5
[8.0,10.0,2.5]
</pre></div>
</div>
<img alt="SLAP" class="align-right" src="../_images/jazzb.png" />
<p>Lo mismo. Hemos creado una función que llamará a <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">-&gt;</span> <span class="pre">[x,y,z]</span></code> con los
resultados finales de <code class="docutils literal notranslate"><span class="pre">(+3)</span></code>, <code class="docutils literal notranslate"><span class="pre">(*2)</span></code> y <code class="docutils literal notranslate"><span class="pre">(/2)</span></code>. El <code class="docutils literal notranslate"><span class="pre">5</span></code> será pasado a
estas tres funciones y luego se llamará a <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">-&gt;</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z]</span></code> con los
resultados.</p>
<p>Puedes verlo como si las funciones fueran cajas que contienen los resultados
finales, así que si hacemos <code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">&lt;$&gt;</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">g</span></code> se crea una función que llamará
a <code class="docutils literal notranslate"><span class="pre">k</span></code> con los resultados de <code class="docutils literal notranslate"><span class="pre">f</span></code> y <code class="docutils literal notranslate"><span class="pre">g</span></code>. Cuando hacemos algo como
<code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">3</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">5</span></code>, estamos usando <code class="docutils literal notranslate"><span class="pre">+</span></code> en valores que pueden
estar ahí o no, por lo tanto el resultado será un valor o ninguno. Cuando
hacemos algo como <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(+10)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(+5)</span></code>, estamos usando <code class="docutils literal notranslate"><span class="pre">+</span></code> en los
futuros resultados de las funciones <code class="docutils literal notranslate"><span class="pre">(+10)</span></code> y <code class="docutils literal notranslate"><span class="pre">(+5)</span></code>, y el resultado
también será algo que producirá un valor siempre y cuando sea llamado con un
parámetro.</p>
<p>No solemos utilizar las funciones como funtores aplicativos, pero siguen
siendo interesantes. Tampoco es muy importante que no entiendas como funciona
la instancia de las funciones para los funtores aplicativos, así que no te
preocupes mucho. Intenta jugar un poco con el estilo aplicativo y las
funciones para hacerte una idea de como funionan.</p>
<p>Una instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> que aún no nos hemos encontrado es
<code class="docutils literal notranslate"><span class="pre">ZipList</span></code> y reside en <code class="docutils literal notranslate"><span class="pre">Control.Applicative</span></code>.</p>
<p>Este tipo sugiere que en realidad hay mas formas de utilizar las listas como
funtores aplicativos. Una forma es la que ya hemos visto, cuando utilizamos
<code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> con una lista de funciones y una lista de valores devuelve una lista
de todas las posibles combinaciones de aplicar esas funciones de la lista de
la izquierda a los valores de la derecha. Si hacemos algo como
<code class="docutils literal notranslate"><span class="pre">[(+3),(*2)]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[1,2]</span></code>, <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> será aplicado a <code class="docutils literal notranslate"><span class="pre">1</span></code> y <code class="docutils literal notranslate"><span class="pre">2</span></code> y <code class="docutils literal notranslate"><span class="pre">(*2)</span></code>
también será aplicado a ambos, por lo que obtendremos una lista con cuatro
elementos, <code class="docutils literal notranslate"><span class="pre">[4,5,2,4]</span></code>.</p>
<p>Sin embargo, <code class="docutils literal notranslate"><span class="pre">[(+3),(*2)]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[1,2]</span></code> también podría funcionar de forma que
la primera función de la izquierda fuera aplicada a el primer valor de la
derecha y la segunda función fuera aplicada al segundo valor. Esto nos daría
una lista con dos valores, <code class="docutils literal notranslate"><span class="pre">[4,4]</span></code>. Lo podríamos ver como
<code class="docutils literal notranslate"><span class="pre">[1</span> <span class="pre">+</span> <span class="pre">3,</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">2]</span></code>.</p>
<p>Como un mismo tipo no puede tener dos instancias para una misma clase de
tipos, se utiliza el tipo <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">a</span></code>, que tiene un constructor <code class="docutils literal notranslate"><span class="pre">ZipList</span></code>
con un solo campo, la lista. Aquí esta la instancia:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">ZipList</span> <span class="kr">where</span>
        <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">x</span><span class="p">)</span>
        <span class="kt">ZipList</span> <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">fs</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Sí, también sería válido <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">(zipWith</span> <span class="pre">($)</span> <span class="pre">fs</span> <span class="pre">xs)</span></code>.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> hace lo que acabamos de explicar. Aplica la primera función a el
primer valor, la segunda función al segundo valor, etc. Esto se consigue con
<code class="docutils literal notranslate"><span class="pre">zipWith</span> <span class="pre">(\f</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">x)</span> <span class="pre">fs</span> <span class="pre">xs</span></code>. Debido a como funciona <code class="docutils literal notranslate"><span class="pre">zipWith</span></code>, la lista
final será tan larga como la lista más corta de las dos.</p>
<p><code class="docutils literal notranslate"><span class="pre">pure</span></code> es bastante interesante. Toma un valor y lo introduce en una lista
que tiene ese valor repetido indefinidamente. <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">&quot;jaja&quot;</span></code> devolvería algo
como <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">([&quot;jaja&quot;,&quot;jaja&quot;,&quot;jaja&quot;...</span></code>. Quizá esto sea algo confuso ya que
hemos dicho que <code class="docutils literal notranslate"><span class="pre">pure</span></code> debe introducir un valor en el contexto mínimo que
albergue ese valor. Y quizá estés pensado que una lista infinita difícilmente
es un contexto mínimo. Pero tiene sentido con esta listas, ya que tiene que
producir un valor en cada posición. De esta forma también se cumple la ley que
dice que <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">xs</span></code> debe ser igual a <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">xs</span></code>. Si <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">3</span></code> solo
devolviera <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">[3]</span></code>, <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">(*2)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">ZipList</span> <span class="pre">[1,5,10]</span></code> devolvería
<code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">[2]</span></code>, ya que la lista resultante es tan larga como la mas corta de
las dos que utilizamos como parámetros. Si utilizamos una lista infinita y
otra finita, la lista resultante siempre tendrá el tamaño de la lista finita.</p>
<p>¿Cómo funcionan estas listas al estilo aplicativo? Veamos. El tipo
<code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">a</span></code> no tiene una instancia para <code class="docutils literal notranslate"><span class="pre">Show</span></code>, así que tenemos que
utilizar la función <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">getZipList</span></code> para extraer una lista primitiva.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100,100]
[101,102,103]
ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]
[101,102,103]
ghci&gt; getZipList $ max &lt;$&gt; ZipList [1,2,3,4,5,3] &lt;*&gt; ZipList [5,3,1,2]
[5,3,3,4]
ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot;
[(&#39;d&#39;,&#39;c&#39;,&#39;r&#39;),(&#39;o&#39;,&#39;a&#39;,&#39;a&#39;),(&#39;g&#39;,&#39;t&#39;,&#39;t&#39;)]
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">(,,)</span></code> es lo mismo que <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">z</span> <span class="pre">-&gt;</span> <span class="pre">(x,y,z)</span></code>. También,
la función <code class="docutils literal notranslate"><span class="pre">(,)</span></code> sería igual a <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">(x,y)</span></code>.</p>
</div>
<p>A parte de <code class="docutils literal notranslate"><span class="pre">zipWith</span></code>, la biblioteca estándar también tiene funciones como
<code class="docutils literal notranslate"><span class="pre">zipWith3</span></code>, <code class="docutils literal notranslate"><span class="pre">zipWith4</span></code>, y todas las demás hasta llegar a 7. <code class="docutils literal notranslate"><span class="pre">zipWith</span></code>
toma una función que tome dos parámetros y une dos los listas con esta
función. <code class="docutils literal notranslate"><span class="pre">zipWith3</span></code> toma una función que tome tres parámetros y une tres
listas con ella. Gracias a estas listas y al estilo aplicativo, no tenemos
que tener una función distinta para cada número de listas que queramos unir
con una función. Lo único que tenemos que hacer es utilizar el estilo
aplicativo.</p>
<p><code class="docutils literal notranslate"><span class="pre">Control.Applicative</span></code> define una función llamada <code class="xref cpp cpp-member docutils literal notranslate"><span class="pre">liftA2</span></code>, cuyo
tipo es <code class="docutils literal notranslate"><span class="pre">liftA2</span> <span class="pre">::</span> <span class="pre">(Applicative</span> <span class="pre">f)</span> <span class="pre">=&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">c</span></code>.
Se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="nf">liftA2</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>Nada especial, simplemente aplica una función entre dos funtores aplicativos,
escondiendo el estilo aplicativo al que nos hemos acostumbrado. La razón por
la cual lo mostramos es para hacer más evidente porque los funtores
aplicativos son más potentes que los funtores ordinarios. Con lo funtores
ordinarios solo podemos mapear funciones sobre un funtor. Pero con los
funtores aplicativos, podemos aplicar una función con varios funtores. También
es interesante ver la el tipo de la función como
<code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">c)</span></code>. Si lo vemos de esta forma, podemos
decir que <code class="docutils literal notranslate"><span class="pre">liftA2</span></code> toma una función binaria normal y la desplaza para que
opere con dos funtores.</p>
<p>Un concepto interesante: podemos tomar dos funtores aplicativos y combinarlos
en un único funtor aplicativo que contenga los resultados de ambos funtores
en forma de lista. Por ejemplo, tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">4</span></code>. Vamos a
asumir que el segundo está dentro de una lista unitaria, lo cual es realmente
fácil de conseguir:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap (\x -&gt; [x]) (Just 4)
Just [4]
</pre></div>
</div>
<p>Vale, ahora tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[4]</span></code> ¿Cómo obtendríamos
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[3,4]</span></code>? Fácil.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; liftA2 (:) (Just 3) (Just [4])
Just [3,4]
ghci&gt; (:) &lt;$&gt; Just 3 &lt;*&gt; Just [4]
Just [3,4]
</pre></div>
</div>
<p>Recuerda, <code class="docutils literal notranslate"><span class="pre">:</span></code> es una función que toma un elemento y una lista y devuelve una
lista nueva con dicho elemento al principio. Ahora que tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[3,4]</span></code>,
¿podríamos combinarlos con <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">2</span></code> para obtener <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[2,3,4]</span></code>? Por
supuesto que podríamos. Parece que podemos combinar cualquier cantidad de
funtores aplicativos en uno que contenga una lista con los resultados de
dichos funtores. Vamos a intentar implementar una función que tome una lista
de funtores aplicativos y devuelva un funtor aplicativo que contenga una lista
con los resultados de los funtores. La llamaremos <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sequenceA</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sequenceA</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">pure</span> <span class="kt">[]</span>
<span class="nf">sequenceA</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">sequenceA</span> <span class="n">xs</span>
</pre></div>
</div>
<p>¡Ahh, recursión! Primero, veamos su tipo. Transformará una lista funtores
aplicativos en un funtor aplicativo con un lista. Esto nos da alguna pista
para el caso base. Si queremos convertir una lista vacía en un funtor
aplicativo con una lista que contenga los resultados, simplemente insertamos
la lista en el contexto mínimo. Luego viene la recursión. Si tenemos una lista
con una cabeza y una cola (recuerda, <code class="docutils literal notranslate"><span class="pre">x</span></code> es un funtor aplicativo y <code class="docutils literal notranslate"><span class="pre">xs</span></code> es
una lista de ellos), llamamos a <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> con la cola para que nos
devuelva un funtor aplicativo que contenga una lista. Luego, anteponemos el
valor que contiene el funtor aplicativo <code class="docutils literal notranslate"><span class="pre">x</span></code> en la lista ¡Y listo!</p>
<p>Si hiciéramos <code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[Just</span> <span class="pre">1,</span> <span class="pre">Just</span> <span class="pre">2]</span></code>, tendríamos
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">sequenceA</span> <span class="pre">[Just</span> <span class="pre">2]</span></code>, que es igual a
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">((:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">2</span> <span class="pre">&lt;*&gt;</span> <span class="pre">sequenceA</span> <span class="pre">[])</span></code>. Sabemos que
<code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[]</span></code> acabará siendo <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[]</span></code>, así que ahora tendríamos
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">((:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">2</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">[])</span></code>, que es igual a
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">Just</span> <span class="pre">1</span> <span class="pre">&lt;*&gt;</span> <span class="pre">Just</span> <span class="pre">[2]</span></code>, que es igual a <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">[1,2]</span></code>.</p>
<p>Otra forma de implementar <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> es con un pliegue. Recuerda, casi
cualquier función en la que recorramos una lista elemento a elemento y vayamos
acumulando un resultando a lo largo del camino puede ser implementada con
un pliegue.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">sequenceA</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sequenceA</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="n">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="p">(</span><span class="n">pure</span> <span class="kt">[]</span><span class="p">)</span>
</pre></div>
</div>
<p>Empezamos recorriendo la lista por la izquierda y con un acumulador inicial
igual a <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">[]</span></code>. Aplicamos <code class="docutils literal notranslate"><span class="pre">liftA2</span> <span class="pre">(:)</span></code> entre el acumulador y el último
elemento de la lista, lo cual resulta en un funtor aplicativo que contiene
una lista unitaria. Luego volvemos a aplicar <code class="docutils literal notranslate"><span class="pre">liftA2</span> <span class="pre">(:)</span></code> con el último
elemento actual de la lista con el acumulador actual, y así sucesivamente
hasta que solo nos quedemos con el acumulador, que contendrá todos los
resultados de los funtores aplicativos.</p>
<p>Vamos a probar nuestra función.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; sequenceA [Just 3, Just 2, Just 1]
Just [3,2,1]
ghci&gt; sequenceA [Just 3, Nothing, Just 1]
Nothing
ghci&gt; sequenceA [(+3),(+2),(+1)] 3
[6,5,4]
ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]
[]
</pre></div>
</div>
<p>Precioso. Cuando lo utilizamos con los valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> crea
un valor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> con todos los resultados dentro de una lista. Si alguno
de los valores es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, entonces el resultado final también lo es. Esto
puede ser útil cuando tenemos una lista de valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y estamos
interesados en obtener esos valores solo si ninguno de ellos es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Cuando se utiliza con funciones, <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> toma una lista de funciones y
devuelve una función cuyo resultado es una lista. En el ejemplo anterior,
creamos una función que tomará un número como parámetro, se aplica a cada una
de las funciones de la lista y luego devuelve una lista con los resultados.
<code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[(+3),(+2),(+1)]</span> <span class="pre">3</span></code> llamará a <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> con <code class="docutils literal notranslate"><span class="pre">3</span></code>, a <code class="docutils literal notranslate"><span class="pre">(+2)</span></code> con
<code class="docutils literal notranslate"><span class="pre">3</span></code> y a <code class="docutils literal notranslate"><span class="pre">(+1)</span></code> con <code class="docutils literal notranslate"><span class="pre">3</span></code>, luego devolverá una lista con todos los
resultados.</p>
<p>Si hacemos <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(+3)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(*2)</span></code> estamos creando una función que toma
un parámetro, lo aplica a <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> y a <code class="docutils literal notranslate"><span class="pre">(*2)</span></code> y luego llama a <code class="docutils literal notranslate"><span class="pre">+</span></code> con
ambos resultados. Del mismo modo, si hacemos <code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[(+3),(*2)]</span></code> estamos
creando una función que tomará un parámetro y lo aplicará a las funciones de
la lista. Pero, en lugar de llamar a <code class="docutils literal notranslate"><span class="pre">+</span></code> con los resultados de las
funciones, se utiliza una combinación de <code class="docutils literal notranslate"><span class="pre">:</span></code> y <code class="docutils literal notranslate"><span class="pre">pure</span> <span class="pre">[]</span></code> para unir todos
esos resultados en una lista.</p>
<p><code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> puede ser útil cuando tenemos una lista de funciones y queremos
aplicarlas todas al mismo parámetro y luego tener los resultados en una lista.
Por ejemplo, si tenemos un número y queremos saber si satisface todos los
predicados que contiene una lista. Una forma de hacerlo sería así:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
[True,True,True]
ghci&gt; and $ map (\f -&gt; f 7) [(&gt;4),(&lt;10),odd]
True
</pre></div>
</div>
<p>Recuerda que <code class="docutils literal notranslate"><span class="pre">and</span></code> toma una lista de booleanos y devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si son
todos <code class="docutils literal notranslate"><span class="pre">True</span></code>. Otra forma de hacer lo mismo sería con <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; sequenceA [(&gt;4),(&lt;10),odd] 7
[True,True,True]
ghci&gt; and $ sequenceA [(&gt;4),(&lt;10),odd] 7
True
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[(&gt;4),(&lt;10),odd]</span></code> crea una función que tomará un número y lo
aplicará a todos los predicados de la lista, <code class="docutils literal notranslate"><span class="pre">[(&gt;4),(&lt;10),odd]</span></code>, y devolverá
una lista con los resultados. Dicho de otra forma, convierte una lista de tipo
<code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">[a</span> <span class="pre">-&gt;</span> <span class="pre">Bool]</span></code> en una función cuyo tipo sería
<code class="docutils literal notranslate"><span class="pre">(Num</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[Bool]</span></code> ¿Tiene buena pinta, no?</p>
<p>Ya que las listas son homogéneas, todas las funciones de la lista deben tener
el mismo tipo. No podemos tener una lista como <code class="docutils literal notranslate"><span class="pre">[ord,</span> <span class="pre">(+3)]</span></code>, porque <code class="docutils literal notranslate"><span class="pre">ord</span></code>
toma un carácter y devuelve un número, mientras que <code class="docutils literal notranslate"><span class="pre">(+3)</span></code> toma un número y
devuelve otro número.</p>
<p>Cuando se utiliza con <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> toma una lista y devuelve una
lista de listas. Mmm… interesante. En realidad crea una lista que contiene
todas las combinaciones posibles de sus elementos. A título de ejemplo aquí
tienes unos cuantos usos de <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> con sus equivalentes usando listas
por comprensión:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; sequenceA [[1,2,3],[4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; [[x,y] | x &lt;- [1,2,3], y &lt;- [4,5,6]]
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
ghci&gt; sequenceA [[1,2],[3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; [[x,y] | x &lt;- [1,2], y &lt;- [3,4]]
[[1,3],[1,4],[2,3],[2,4]]
ghci&gt; sequenceA [[1,2],[3,4],[5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
ghci&gt; [[x,y,z] | x &lt;- [1,2], y &lt;- [3,4], z &lt;- [5,6]]
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
</pre></div>
</div>
<p>Quizá esto es un poco difícil de entender, pero si jugamos un poco con ellos,
veremos como funciona. Digamos que tenemos <code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[[1,2],[3,4]]</span></code>. Para
ver lo que sucede, vamos a utilizar la definición
<code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">x</span> <span class="pre">&lt;*&gt;</span> <span class="pre">sequenceA</span> <span class="pre">xs</span></code> de <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> y el caso
base <code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[]</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">[]</span></code>. No tienes porque seguir esta traza, pero si
no consigues imaginarte como funciona <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> con las listas puede que
te resulte de ayuda.</p>
<blockquote>
<div><ul class="simple">
<li><p>Empezamos con <code class="docutils literal notranslate"><span class="pre">sequenceA</span> <span class="pre">[[1,2],[3,4]]</span></code>.</p></li>
<li><p>Lo cual se evalúa a <code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">sequenceA</span> <span class="pre">[[3,4]]</span></code>.</p></li>
<li><p>Si evaluamos el <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> interior una vez más, obtenemos
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">((:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[3,4]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">sequenceA</span> <span class="pre">[])</span></code>.</p></li>
<li><p>Ahora hemos alcanzado el caso base, así que tenemos
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">((:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[3,4]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[[]])</span></code>.</p></li>
<li><p>Evaluamos la parte <code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[3,4]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[[]]</span></code>, que utilizará <code class="docutils literal notranslate"><span class="pre">:</span></code> con cada
posible valor de la lista de la izquierda  (es decir <code class="docutils literal notranslate"><span class="pre">3</span></code> y <code class="docutils literal notranslate"><span class="pre">4</span></code>) con
cada posible valor de la lista de la derecha (<code class="docutils literal notranslate"><span class="pre">[]</span></code>), obteniendo así
<code class="docutils literal notranslate"><span class="pre">[3:[],</span> <span class="pre">4:[]]</span></code>, que es <code class="docutils literal notranslate"><span class="pre">[[3],[4]]</span></code>. Así que ahora tenemos
<code class="docutils literal notranslate"><span class="pre">(:)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[[3],[4]]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:</span></code> se utiliza con cada posible valor de la lista de la izquierda (<code class="docutils literal notranslate"><span class="pre">1</span></code>
y <code class="docutils literal notranslate"><span class="pre">2</span></code>) con cada posible valor de la lista de la derecha (<code class="docutils literal notranslate"><span class="pre">[3]</span></code> y
<code class="docutils literal notranslate"><span class="pre">[4]</span></code>), de forma que nos quedamos con <code class="docutils literal notranslate"><span class="pre">[1:[3],</span> <span class="pre">1:[4],</span> <span class="pre">2:[3],</span> <span class="pre">2:[4]]</span></code>,
que es igual a <code class="docutils literal notranslate"><span class="pre">[[1,3],[1,4],[2,3],[2,4]</span></code>.</p></li>
</ul>
</div></blockquote>
<p>Si hacemos <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">[1,2]</span> <span class="pre">&lt;*&gt;</span> <span class="pre">[4,5,6]</span></code> estamos creando una computación
no determinista <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></code> donde <code class="docutils literal notranslate"><span class="pre">x</span></code> toma cualquier valor de <code class="docutils literal notranslate"><span class="pre">[1,2]</span></code> e
<code class="docutils literal notranslate"><span class="pre">y</span></code> toma cualquier valor de <code class="docutils literal notranslate"><span class="pre">[4,5,6]</span></code>. Representamos la solución con una
lista con todos los posibles resultados. De forma similar, si hacemos
<code class="docutils literal notranslate"><span class="pre">sequence</span> <span class="pre">[[1,2],[3,4],[5,6],[7,8]]</span></code> estamos creando una computación no
determinista <code class="docutils literal notranslate"><span class="pre">[x,y,z,w]</span></code>, donde <code class="docutils literal notranslate"><span class="pre">x</span></code> toma cualquier valor de <code class="docutils literal notranslate"><span class="pre">[1,2]</span></code>,
<code class="docutils literal notranslate"><span class="pre">y</span></code> toma cualquier valor de <code class="docutils literal notranslate"><span class="pre">[3,4]</span></code>, y así sucesivamente. Representamos el
resultado de la computación no determinista utilizando una lista, donde cada
elemento es una lista posible. Por este motivo el resultado es una lista de
listas.</p>
<p>Con acciones de E/S, <code class="docutils literal notranslate"><span class="pre">sequenceA</span></code> se comporta igual que <code class="docutils literal notranslate"><span class="pre">sequence</span></code>. Toma
una lista de acciones de E/S y devuelve una acción de E/S que ejecutará cada
una de esas acciones y tendrá como resultado una lista con los resultados de
todas esas acciones. Por este motivo para convertir un valor <code class="docutils literal notranslate"><span class="pre">[IO</span> <span class="pre">a]</span></code> en
un valor <code class="docutils literal notranslate"><span class="pre">IO</span> <span class="pre">[a]</span></code>, o dicho de otra forma, para crear una acción de E/S que
devuelva una lista de resultados cuando sea ejecutada, todas estas acciones
tienen que ser secuenciadas de forma que sean ejecutadas unas detrás de otra
cuando se fuerce la evaluación. No puede obtener el resultado de una acción de
E/S si no la ejecutas primero.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; sequenceA [getLine, getLine, getLine]
heyh
ho
woo
[&quot;heyh&quot;,&quot;ho&quot;,&quot;woo&quot;]
</pre></div>
</div>
<p>Al igual que los funtores normales, los funtores aplicativos vienen con una
serie de leyes. La mas importante de todas es la que ya hemos mencionado,
<code class="xref js js-data docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">fmap</span> <span class="pre">f</span> <span class="pre">x</span></code>. Como ejercicio, puedes intentar comprobar
esta ley en algunos de los funtores de los que hemos hablado. Las otras leyes
son:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">pure</span> <span class="pre">id</span> <span class="pre">&lt;*&gt;</span> <span class="pre">v</span> <span class="pre">=</span> <span class="pre">v</span></code></p></li>
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">pure</span> <span class="pre">(.)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">u</span> <span class="pre">&lt;*&gt;</span> <span class="pre">v</span> <span class="pre">&lt;*&gt;</span> <span class="pre">w</span> <span class="pre">=</span> <span class="pre">u</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(v</span> <span class="pre">&lt;*&gt;</span> <span class="pre">w)</span></code></p></li>
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">pure</span> <span class="pre">f</span> <span class="pre">&lt;*&gt;</span> <span class="pre">pure</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">(f</span> <span class="pre">x)</span></code></p></li>
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">u</span> <span class="pre">&lt;*&gt;</span> <span class="pre">pure</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">pure</span> <span class="pre">($</span> <span class="pre">y)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">u</span></code></p></li>
</ul>
</div></blockquote>
<p>No vamos a verlas en detalle ahora mismo ya que nos tomaría unas cuantas
página y probablemente sea algo aburrido, pero, si te sientes con ganas,
puedes echarles una vistazo más de cerca y comprobar si algunas de las
instancias que hemos visto las cumplen.</p>
<p>Concluyendo, los funtores aplicativos no son solo interesantes, sino que
también son útiles, ya que nos permiten combinar diferentes computaciones,
como computaciones de E/S, computaciones no deterministas, computaciones que
puede fallar, etc. utilizando el estilo aplicativo. Simplemente utilizando
<code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> podemos utilizar funciones normales para que operen de forma
uniforme con cualquier número de funtores aplicativos y tomar ventaja de la
semántica de cada uno.</p>
</div>
<div class="section" id="la-palabra-clave-newtype">
<h2>La palabra clave newtype<a class="headerlink" href="#la-palabra-clave-newtype" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="¿Por qué estas tan serio?" class="align-left" src="../_images/maoi.png" />
<p>Hasta ahora hemos creado nuestros propios tipos de datos algebraicos
utilizando el palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code>. También hemos visto como dar sinónimos
de tipos ya existentes utilizando la palabra clave <code class="docutils literal notranslate"><span class="pre">type</span></code>. En esta sección,
veremos como crear nuevos tipos de datos a partir de tipos datos ya existentes
utilizando la palabra clave <code class="docutils literal notranslate"><span class="pre">newtype</span></code> y el porqué de hacerlo de este modo.</p>
<p>En la sección anterior vimos que en realidad hay más de una forma para que una
lista sea un funtor aplicativo. Una manera es que <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> tome cada función de
la lista que se le pasa como parámetro izquierdo y la aplique a cada valor que
contenga la lista de la derecha, de forma que devuelva todas las posibles
combinaciones de aplicar una función de la izquierda con un valor de la
derecha.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [(+1),(*100),(*5)] &lt;*&gt; [1,2,3]
[2,3,4,100,200,300,5,10,15]
</pre></div>
</div>
<p>La segundo forma es que tome la primera función de la lista de la izquierda de
<code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> y la aplique a el primer valor de la lista de la derecha, luego tomará
la segunda función de la lista izquierda y la aplicara al segundo valor de la
lista derecha, y así sucesivamente. Al final es algo como unir dos listas en
una. Pero las listas ya tienen una instancia para <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, así que
¿Cómo hemos creado una segunda instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>? Si haces memoria,
recordarás que dijimos que el tipo <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">a</span></code> se utilizaba por este motivo,
el cual tiene un constructor de datos, <code class="docutils literal notranslate"><span class="pre">ZipList</span></code>, con un solo campo. Pusimos
la lista con la que íbamos a trabajar en ese campo. Luego, como <code class="docutils literal notranslate"><span class="pre">ZipList</span></code>
tenia su propia instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, el comportamiento de las listas
como funtores aplicativos era diferente. Solo teníamos que utilizar el
constructor <code class="docutils literal notranslate"><span class="pre">ZipList</span></code> con la lista y cuando termináramos debíamos usar
<code class="docutils literal notranslate"><span class="pre">getZipList</span></code> para recuperarla.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getZipList $ ZipList [(+1),(*100),(*5)] &lt;*&gt; ZipList [1,2,3]
[2,200,15]
</pre></div>
</div>
<p>Y bien ¿Qué tiene que ver todo esto con la palabra clave <code class="docutils literal notranslate"><span class="pre">newtype</span></code>? Bueno,
piensa un poco en como deberíamos declarar el tipo de datos <code class="docutils literal notranslate"><span class="pre">ZipList</span> <span class="pre">a</span></code>. Una
forma sería así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>Un tipo que solo tiene un constructor de datos y este constructor solo tiene
un campo el cual es una lista de cosas. También podríamos utiliza la sintaxis
de registro para obtener de forma automática una función que extraiga la lista
de un <code class="docutils literal notranslate"><span class="pre">ZipList</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Todo esto parece correcto y de hecho funciona bien. Simplemente hemos
utilizado la palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code> para insertar un tipo dentro dentro de
otro y así poder crear una segunda instancia de el tipo original.</p>
<p>En Haskell, la palabra clave <code class="docutils literal notranslate"><span class="pre">newtype</span></code> se utiliza exactamente para estos
casos en los que simplemente queremos insertar un tipo dentro de otro para que
parezca un tipo distinto. En realidad, <code class="docutils literal notranslate"><span class="pre">ZipList</span></code> se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Se utiliza <code class="docutils literal notranslate"><span class="pre">newtype</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">data</span></code>. Y ¿Por qué? Te estarás
preguntando. Muy sencillo, <code class="docutils literal notranslate"><span class="pre">newtype</span></code> es más rápido. Si utilizamos la palabra
clave <code class="docutils literal notranslate"><span class="pre">data</span></code> para insertar un tipo dentro de otro, se genera cierta
sobrecarga cuando el programa se ejecuta debido a las operaciones que insertan
y extraen el tipo. Pero si utilizamos <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, Haskell sabe que lo estamos
utilizando para insertar un tipo existente en un nuevo tipo (de ahí viene el
nombre). En realidad lo que buscamos es que internamente sean iguales pero que
su tipo sea distinto. Teniendo esto en cuenta, Haskell puede deshacerse de las
operaciones de inserción y extracción una vez sepa de que tipo es cada valor.</p>
<p>Entonces ¿Por qué no utilizamos siempre <code class="docutils literal notranslate"><span class="pre">newtype</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">data</span></code>?
Cuando creamos un nuevo tipo a partir de uno ya existente utilizando la
palabra clave <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, solo podemos utilizar un constructor de datos y
éste solo puede tener un campo. Mientras que con <code class="docutils literal notranslate"><span class="pre">data</span></code> podemos tener varios
constructores de datos y cada uno de ellos con cero o varios campos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Profession</span> <span class="ow">=</span> <span class="kt">Fighter</span> <span class="o">|</span> <span class="kt">Archer</span> <span class="o">|</span> <span class="kt">Accountant</span>

<span class="kr">data</span> <span class="kt">Race</span> <span class="ow">=</span> <span class="kt">Human</span> <span class="o">|</span> <span class="kt">Elf</span> <span class="o">|</span> <span class="kt">Orc</span> <span class="o">|</span> <span class="kt">Goblin</span>

<span class="kr">data</span> <span class="kt">PlayerCharacter</span> <span class="ow">=</span> <span class="kt">PlayerCharacter</span> <span class="kt">Race</span> <span class="kt">Profession</span>
</pre></div>
</div>
<p>Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">newtype</span></code> estamos restringidos a utilizar a utilizar un
solo constructor con un solo campo.</p>
<p>También podemos utilizar la palabra clave <code class="docutils literal notranslate"><span class="pre">deriving</span></code> con <code class="docutils literal notranslate"><span class="pre">newtype</span></code> de la
misma forma que hacemos con <code class="docutils literal notranslate"><span class="pre">data</span></code>. Podemos derivar las instancias de
<code class="docutils literal notranslate"><span class="pre">Eq</span></code>, <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Enum</span></code>, <code class="docutils literal notranslate"><span class="pre">Bounded</span></code>, <code class="docutils literal notranslate"><span class="pre">Show</span></code> y <code class="docutils literal notranslate"><span class="pre">Read</span></code>. Si derivamos la
instancia de una clase de tipos, el tipo original tiene que ser miembro de
dicha clase de tipos. Tiene sentido, ya que <code class="docutils literal notranslate"><span class="pre">newtype</span></code> solo sustituye a un
tipo existente. Si tenemos el siguiente código, podríamos mostrar por pantalla
y equiparar valores del nuevo tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CharList</span> <span class="ow">=</span> <span class="kt">CharList</span> <span class="p">{</span> <span class="n">getCharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Vamos a probarlo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; CharList &quot;this will be shown!&quot;
CharList {getCharList = &quot;this will be shown!&quot;}
ghci&gt; CharList &quot;benny&quot; == CharList &quot;benny&quot;
True
ghci&gt; CharList &quot;benny&quot; == CharList &quot;oisters&quot;
False
</pre></div>
</div>
<p>En este caso en particular, el constructor de datos tiene el siguiente tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">CharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">CharList</span>
</pre></div>
</div>
<p>Toma un valor del tipo <code class="docutils literal notranslate"><span class="pre">[Char]</span></code>, como <code class="docutils literal notranslate"><span class="pre">&quot;My</span> <span class="pre">Sharona&quot;</span></code> y devuelve un valor
del tipo <code class="docutils literal notranslate"><span class="pre">CharList</span></code>. En el ejemplo anterior lo podemos ver en
funcionamiento. Po el contrario, la función <code class="docutils literal notranslate"><span class="pre">getCharList</span></code>, que ha sido
generada automáticamente gracias al uso de la sintaxis de registro, tiene este
tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">getCharList</span> <span class="ow">::</span> <span class="kt">CharList</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<p>Toma un valor del tipo <code class="docutils literal notranslate"><span class="pre">CharList</span></code> y devuelve uno del tipo <code class="docutils literal notranslate"><span class="pre">[Char]</span></code>. Estas
son las operaciones de inserción y extracción de las que antes hablábamos,
aunque también puedes verlo como una transformación de un tipo a otro. Gracias
a las propiedades de <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, estas operaciones no tendrán ningún coste
en tiempo de ejecución.</p>
<div class="section" id="utilizando-newtype-para-crear-instancias-de-clase">
<h3>Utilizando newtype para crear instancias de clase<a class="headerlink" href="#utilizando-newtype-para-crear-instancias-de-clase" title="Enlazar permanentemente con este título">¶</a></h3>
<p>A menudo queremos crear instancias de nuestros tipos para ciertas clases
de tipos, pero los parámetros de tipo no encajan en lo que queremos hacer. Es
muy fácil crear una instancia de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> para <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, ya que la clase
de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code> se define como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Así que simplemente tenemos que hacer esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</pre></div>
</div>
<p>E implementar <code class="docutils literal notranslate"><span class="pre">fmap</span></code>. Todos los parámetros de tipo encajan porque <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
toma el lugar de <code class="docutils literal notranslate"><span class="pre">f</span></code> en la definición de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, de
forma que si vemos el tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> como si solo funcionara para <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
quedaría así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<img alt="¡Muy peligroso!" class="align-right" src="../_images/krakatoa.png" />
<p>Ahora ¿Qué pasaría si quisiéramos crear una instancia para <code class="docutils literal notranslate"><span class="pre">Functor</span></code> para
las duplas de forma que cuando utilizamos <code class="docutils literal notranslate"><span class="pre">fmap</span></code> con una función sobre una
dupla, se aplicara la función al primer componente de la dupla? De este modo,
si hiciéramos algo como <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+3)</span> <span class="pre">(1,1)</span></code> obtendríamos <code class="docutils literal notranslate"><span class="pre">(4,1)</span></code>. Pues
resulta que escribir una instancia para lograr este comportamiento no es tan
sencillo. Con <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> solo teníamos que utilizar
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">Maybe</span> <span class="pre">where</span></code> porque solo los constructores de tipos que
toman exactamente un parámetro pueden crear una instancia para la clase
<code class="docutils literal notranslate"><span class="pre">Functor</span></code>. Pero parece que no hay ninguna forma de hacer que algo como que
el parámetro <code class="docutils literal notranslate"><span class="pre">a</span></code> de <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code> acabe siendo el que cambie cuando utilicemos
<code class="docutils literal notranslate"><span class="pre">fmap</span></code>. Para solucionarlo, podemos utilizar <code class="docutils literal notranslate"><span class="pre">newtype</span></code> con las duplas de
forma que el segundo parámetro de tipo represente el primer parámetro de tipo
de las duplas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Pair</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="p">{</span> <span class="n">getPair</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Y ahora podemos hacer la instancia para <code class="docutils literal notranslate"><span class="pre">Functor</span></code> de forma que la función
sea aplicada únicamente en la primera componente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Como puede observar, podemos utilizar el ajuste de patrones con tipos
definidos con <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. Utilizamos el ajuste de patrones para obtener la
dupla subyacente, luego aplicamos la función <code class="docutils literal notranslate"><span class="pre">f</span></code> al primer componente de la
tupla y luego utilizamos el constructor de datos <code class="docutils literal notranslate"><span class="pre">Pair</span></code> para convertir la
tupla de nuevo al tipo <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">b</span> <span class="pre">a</span></code>. El tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> restringido al nuevo
tipo quedaría así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">b</span>
</pre></div>
</div>
<p>De nuevo, hemos utilizado <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Pair</span> <span class="pre">c)</span> <span class="pre">where</span></code> así que
<code class="docutils literal notranslate"><span class="pre">(Pair</span> <span class="pre">c)</span></code> toma el lugar de <code class="docutils literal notranslate"><span class="pre">f</span></code> en la definición de clase de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Ahora podemos convertir una dupla en un <code class="docutils literal notranslate"><span class="pre">Pair</span> <span class="pre">b</span> <span class="pre">a</span></code>, y utilizar <code class="docutils literal notranslate"><span class="pre">fmap</span></code>
sobre ella de forma que la función solo se aplique a la primera componente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getPair</span> <span class="o">$</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getPair</span> <span class="o">$</span> <span class="n">fmap</span> <span class="n">reverse</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="s">&quot;london calling&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="s">&quot;gnillac nodnol&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="la-pereza-de-newtype">
<h3>La pereza de newtype<a class="headerlink" href="#la-pereza-de-newtype" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ya hemos hablado de que normalmente <code class="docutils literal notranslate"><span class="pre">newtype</span></code> es más rápido que <code class="docutils literal notranslate"><span class="pre">data</span></code>. Lo
único que podemos hacer cuando utilizamos <code class="docutils literal notranslate"><span class="pre">newtype</span></code> es convertir un tipo
existente en un nuevo tipo, aunque internamente, Haskell puede representar los
valores de los tipos definidos con <code class="docutils literal notranslate"><span class="pre">newtype</span></code> igual que los originales,
aunque debe tener en cuenta que sus tipos son diferentes. Esto provoca que
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> no solo sea más rápido, sino también más perezoso. Vamos a ver con
detalle que significa esto.</p>
<p>Como ya dijimos, Haskell perezoso por defecto, lo que significa que solo
cuando intentamos mostrar el resultado de nuestras funciones tendrá lugar el
cómputo de estos resultados. Además, solo los cómputos que son necesario para
calcular el resultado la función serán ejecutados. El valor <code class="docutils literal notranslate"><span class="pre">undefined</span></code> de
Haskell representa un cómputo erróneo. Si intentamos evaluarlo (es decir,
forzamos a Haskell a que lo calcule) mostrándolo por la terminal, Haskell se
lanzará un berrinche (técnicamente conocido como excepción):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; undefined
*** Exception: Prelude.undefined
</pre></div>
</div>
<p>Sin embargo, si insertamos algunos valores <code class="docutils literal notranslate"><span class="pre">undefined</span></code> en una lista pero
solo necesitamos la cabeza de la lista, la cual no es <code class="docutils literal notranslate"><span class="pre">undefined</span></code>, todo
funcionará bien ya que Haskell no necesita evaluar ningún otro elemento de la
lista si solo estamos interesados en el primer elemento:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; head [3,4,5,undefined,2,undefined]
3
</pre></div>
</div>
<p>Ahora consideremos el siguiente tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">CoolBool</span> <span class="ow">=</span> <span class="kt">CoolBool</span> <span class="p">{</span> <span class="n">getCoolBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div>
</div>
<p>Es uno de los muchos tipos de datos algebraicos que se pueden definir con la
palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code>. Tiene un único constructor de datos, y este
constructor solo posee un campo cuyo tipo es <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. Vamos a crear una
función que use un ajuste de patrones en un <code class="docutils literal notranslate"><span class="pre">CoolBool</span></code> y devuelva el valor
<code class="docutils literal notranslate"><span class="pre">&quot;hola&quot;</span></code> independientemente de que el valor <code class="docutils literal notranslate"><span class="pre">Bool</span></code> contenido en
<code class="docutils literal notranslate"><span class="pre">CoolBool</span></code> sea <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">helloMe</span> <span class="ow">::</span> <span class="kt">CoolBool</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">helloMe</span> <span class="p">(</span><span class="kt">CoolBool</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;hola&quot;</span>
</pre></div>
</div>
<p>En lugar de aplicar esta función a un valor normal de <code class="docutils literal notranslate"><span class="pre">CoolBool</span></code>, vamos a
complicarnos la vida y aplicar el valor <code class="docutils literal notranslate"><span class="pre">undefined</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; helloMe undefined
&quot;*** Exception: Prelude.undefined
</pre></div>
</div>
<p>¡Una excepción! ¿Por qué sucede esto? Los tipos definidos con la palabra clave
<code class="docutils literal notranslate"><span class="pre">data</span></code> pueden tener varios constructores de datos (aunque <code class="docutils literal notranslate"><span class="pre">CoolBool</span></code> solo
tiene uno). Así que para saber si un valor dado a nuestra función se ajusta al
patrón <code class="docutils literal notranslate"><span class="pre">(CoolBool</span> <span class="pre">_)</span></code>, Haskell tiene que evaluar el valor lo suficiente como
para saber el constructor de datos que se ha utilizado para crear el valor. Y
cuando tratamos de evaluar un valor <code class="docutils literal notranslate"><span class="pre">undefined</span></code>, por muy poco que lo
evaluemos, se lanzará una excepción.</p>
<p>En lugar de utilizar la palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code> para definir <code class="docutils literal notranslate"><span class="pre">CoolBool</span></code>,
vamos a intentar utilizar <code class="docutils literal notranslate"><span class="pre">newtype</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CoolBool</span> <span class="ow">=</span> <span class="kt">CoolBool</span> <span class="p">{</span> <span class="n">getCoolBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div>
</div>
<p>No tenemos que cambiar nada de la función <code class="docutils literal notranslate"><span class="pre">helloMe</span></code> porque la sintaxis que
se utiliza en el ajuste de patrones es igual para <code class="docutils literal notranslate"><span class="pre">data</span></code> que para
<code class="docutils literal notranslate"><span class="pre">newtype</span></code>. Vamos a hacer lo mismo y aplicar <code class="docutils literal notranslate"><span class="pre">helloMe</span></code> a un valor
<code class="docutils literal notranslate"><span class="pre">undefined</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; helloMe undefined
&quot;hola&quot;
</pre></div>
</div>
<img alt="¡Te deseo lo mejor!" class="align-right" src="../_images/shamrock.png" />
<p>¡Funcionó! Mmm… ¿Por qué? Bueno, como ya hemos dicho, cuando utilizamos
<code class="docutils literal notranslate"><span class="pre">newtype</span></code>, Haskell puede representar internamente los valores del nuevo
tipo como si se tratasen del original. No tiene que añadir ningún envoltorio a
estos valores, simplemente debe tener en cuenta de que poseen un tipo
distinto. Y como Haskell sabe que los tipos definidos con la palabra clave
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> solo pueden tener un constructor de datos, no tiene porque evaluar
el parámetro pasado a la función para estar seguro de que se ajusta al patrón
<code class="docutils literal notranslate"><span class="pre">(CoolBool</span> <span class="pre">_)</span></code> ya que los tipos <code class="docutils literal notranslate"><span class="pre">newtype</span></code> solo pueden tener un constructor
de datos con un solo campo.</p>
<p>Esta diferencia de comportamiento puede parecer trivial, pero en realidad es
muy importante ya que nos ayuda a entender que aunque los tipos definidos con
<code class="docutils literal notranslate"><span class="pre">data</span></code> y <code class="docutils literal notranslate"><span class="pre">newtype</span></code> se comportan de forma muy similar desde el punto de
vista de un programador, en realidad son dos mecanismos diferentes. Mientras
<code class="docutils literal notranslate"><span class="pre">data</span></code> se puede utilizar para crear nuestros propios tipos de datos desde
cero, <code class="docutils literal notranslate"><span class="pre">newtype</span></code> sirve para crear un tipo completamente nuevo a partir de uno
ya existente. Cuando utilizamos un ajuste de patrones con un tipo <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
no estamos extrayendo ningún dato de él (como ocurriría con <code class="docutils literal notranslate"><span class="pre">data</span></code>), sería
más bien como una conversión directa entre un dato y otro.</p>
</div>
<div class="section" id="type-vs-newtpe-vs-data">
<h3>type vs. newtpe vs. data<a class="headerlink" href="#type-vs-newtpe-vs-data" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Llegados a este punto, quizás estés algo confundido sobre que diferencias
existen entre <code class="docutils literal notranslate"><span class="pre">type</span></code>, <code class="docutils literal notranslate"><span class="pre">data</span></code> y <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. Vamos a refrescar la memoria.</p>
<p>La palabra clave <code class="docutils literal notranslate"><span class="pre">type</span></code> se utiliza para crear sinónimos. Básicamente lo que
hacemos es dar otro nombre a un tipo que ya existe de forma que nos sea más
fácil referirnos a él. Por ejemplo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntList</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</pre></div>
</div>
<p>Todo lo que hace es permitirnos llamar al tipo <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> como <code class="docutils literal notranslate"><span class="pre">IntList</span></code>. Se
puede utilizar indistintamente. No obtenemos ningún constructor de datos nuevo
a partir de <code class="docutils literal notranslate"><span class="pre">IntList</span></code> ni nada por el estilo. Como <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> y <code class="docutils literal notranslate"><span class="pre">IntList</span></code>
son dos formas de referirse al mismo tipo, no importa que nombre usemos en las
declaraciones de tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">IntList</span><span class="p">)</span> <span class="o">++</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>Utilizamos los sinónimos de tipos cuando queremos que nuestras declaraciones
de tipo sean más descriptivas, de forma que los sinónimos que demos expliquen
algo acerca de su propósito en un determinado contexto. Por ejemplo, si
utilizamos listas de asociación del tipo <code class="docutils literal notranslate"><span class="pre">[(String,String)]</span></code> para
representar una agenda telefónica, podemos darle el sinónimo de tipo
<code class="docutils literal notranslate"><span class="pre">PhoneBook</span></code> de forma que las declaraciones de tipo de las funciones sean más
legibles.</p>
<p>La palabra clave <code class="docutils literal notranslate"><span class="pre">newtype</span></code> se utiliza para crear nuevos tipos a partir de
uno ya existente. Su uso es común para facilitar la declaración de ciertas
instancias de clases de tipos. Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">newtype</span></code> con un tipo ya
existente, el tipo que obtenemos es diferente del original. Si tenemos el
siguiente tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CharList</span> <span class="ow">=</span> <span class="kt">CharList</span> <span class="p">{</span> <span class="n">getCharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>No podemos utilizar <code class="docutils literal notranslate"><span class="pre">++</span></code> para concatenar un <code class="docutils literal notranslate"><span class="pre">CharList</span></code> con un <code class="docutils literal notranslate"><span class="pre">[Char]</span></code>.
Ni siquiera podemos utilizar <code class="docutils literal notranslate"><span class="pre">++</span></code> para concatenar dos <code class="docutils literal notranslate"><span class="pre">CharList</span></code> porque
<code class="docutils literal notranslate"><span class="pre">++</span></code> solo funciona con listas. <code class="docutils literal notranslate"><span class="pre">CharList</span></code> no es una lista, incluso aunque
sepamos que contiene una. Sin embargo, podemos convertir dos <code class="docutils literal notranslate"><span class="pre">CharList</span></code> en
listas, luego utilizar <code class="docutils literal notranslate"><span class="pre">++</span></code> con ellas y más tarde convertir el resultado en
un <code class="docutils literal notranslate"><span class="pre">CharList</span></code>.</p>
<p>Cuando utilizamos la sintaxis de registro en las declaraciones <code class="docutils literal notranslate"><span class="pre">newtype</span></code>,
obtenemos funciones para convertir ente el nuevo tipo y el original. El nuevo
tipo no posee automáticamente las instancias para clases de tipos de las que
formaba parte el tipo original, así que tenemos que derivarlas manualmente.</p>
<p>En la practica, puedes considerar las declaraciones de tipo <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
iguales a las declaraciones <code class="docutils literal notranslate"><span class="pre">data</span></code>, aunque solo puede tener un constructor
de datos y un solo campo. Si te encuentras declarando un tipo como ese,
plantéate utilizar <code class="docutils literal notranslate"><span class="pre">newtype</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<p>La palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code> la utilizamos para crear nuestros propios tipos de
datos, y podemos hacer lo que se nos antoje con ellos. Pueden tener tantos
constructores de datos y tantos campos como quieras y se pueden utilizar para
implementar cualquier tipo de dato algebraico. Cualquier cosa, desde listas
hasta tipos como <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> o árboles.</p>
<p>Si quieres que las declaraciones de tipo sean más descriptivas y legibles,
probablemente lo que estés buscando sean los sinónimos de tipos. Si lo que
quieres es crear un nuevo tipo que contenga a otro para poder declarar una
instancia de una clase de tipos, seguramente quieras utilizar <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. Y
si lo que quieres es crear algo completamente nuevo, apostaría a que debes
utilizar <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
</div>
</div>
<div class="section" id="monoides">
<span id="id1"></span><h2>Monoides<a class="headerlink" href="#monoides" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Probablemente el barco pirata más inofensivo." class="align-right" src="../_images/pirateship.png" />
<p>En Haskell, las clases de tipos se utilizan crear una interfaz de un
comportamiento que comparten varios tipos. Empezamos viendo la sencillas
clases de tipos, como <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, que representa los tipos que pueden ser
equiparados, o <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, que representa los tipos cuyos valores pueden ser
puestos en un determinado orden. Luego continuamos viendo clases de tipos más
interesantes, como <code class="docutils literal notranslate"><span class="pre">Functor</span></code> o <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.</p>
<p>Cuando creamos un tipo debemos pensar en que comportamientos debe soportar,
es decir, pensar si puede actuar como esos comportamientos, y luego decidir si
es oportuno crear una instancia de estos. Si tiene sentido que los valores de
un determinado tipo sean equiparados, entonces creamos una instancia de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>
para ese tipo. Si vemos que un tipo es un especie de funtor, podemos crear una
instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>, y así sucesivamente.</p>
<p>Ahora consideremos esto: la función <code class="docutils literal notranslate"><span class="pre">*</span></code> toma dos números y los multiplica.
Si multiplicamos un número por <code class="docutils literal notranslate"><span class="pre">1</span></code>, el resultado es siempre igual a ese
número. No importa si hacemos <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">*</span> <span class="pre">x</span></code> o <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">1</span></code>, el resultado es siempre
el mismo. De forma similar, <code class="docutils literal notranslate"><span class="pre">++</span></code> también es una función que toma dos
parámetros y devuelve una tercera. Solo que en lugar de multiplicar números,
toma dos listas y las concatena. Al igual que pasaba con <code class="docutils literal notranslate"><span class="pre">*</span></code>, <code class="docutils literal notranslate"><span class="pre">++</span></code> también
posee un valor que hará que el resultado final solo dependa del otro valor. En
este caso el valor es la lista vacía, <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; 4 * 1
4
ghci&gt; 1 * 9
9
ghci&gt; [1,2,3] ++ []
[1,2,3]
ghci&gt; [] ++ [0.5, 2.5]
[0.5,2.5]
</pre></div>
</div>
<p>Parece que tanto <code class="docutils literal notranslate"><span class="pre">*</span></code> junto a <code class="docutils literal notranslate"><span class="pre">1</span></code> como <code class="docutils literal notranslate"><span class="pre">++</span></code> junto a <code class="docutils literal notranslate"><span class="pre">[]</span></code> comparten
ciertas propiedades:</p>
<blockquote>
<div><ul class="simple">
<li><p>La función toma dos parámetros.</p></li>
<li><p>Los parámetros y el valor de retorno comparten el mismo tipo.</p></li>
<li><p>Existe un valor que hará que el resultado de la función binaria solo
dependa del otro parámetro.</p></li>
</ul>
</div></blockquote>
<p>Existe también otra propiedad que ambos comparte pero que quizá no sea tan
obvia: cuando tenemos tres o mas valores y queremos utilizar la función
binaria para reducirlos a un solo valor, el orden en el que apliquemos la
función binaria no importa. No importa si hacemos <code class="docutils literal notranslate"><span class="pre">(3</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">*</span> <span class="pre">5</span></code> o
<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">(4</span> <span class="pre">*</span> <span class="pre">5)</span></code>, al final el resultado será <code class="docutils literal notranslate"><span class="pre">60</span></code>. Lo mismo ocurre para
<code class="docutils literal notranslate"><span class="pre">++</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (3 * 2) * (8 * 5)
240
ghci&gt; 3 * (2 * (8 * 5))
240
ghci&gt; &quot;la&quot; ++ (&quot;di&quot; ++ &quot;da&quot;)
&quot;ladida&quot;
ghci&gt; (&quot;la&quot; ++ &quot;di&quot;) ++ &quot;da&quot;
&quot;ladida&quot;
</pre></div>
</div>
<p>Llamamos a esta propiedad <em>asociatividad</em>. <code class="docutils literal notranslate"><span class="pre">*</span></code> es asociativa, y también lo
es <code class="docutils literal notranslate"><span class="pre">++</span></code>, pero <code class="docutils literal notranslate"><span class="pre">-</span></code>, por ejemplo, no lo es. Las expresiones <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">-</span> <span class="pre">3)</span> <span class="pre">-</span> <span class="pre">4</span></code>
y <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">-</span> <span class="pre">(3</span> <span class="pre">-</span> <span class="pre">4)</span></code> tienen resultados diferentes.</p>
<p>Si observamos estas propiedades nos encontraremos con los <em>monoides</em>. Un
monoide es cuando tienes una función binaria asociativa y valor que actúa como
identidad respecto a esa función. Cuando se dice que un valor actúa como
identidad respecto a una función significa que, cuando se utiliza en esa
función junto con otro valor, el resultado siempre siempre es igual al otro
valor. <code class="docutils literal notranslate"><span class="pre">1</span></code> es la identidad respecto a <code class="docutils literal notranslate"><span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">[]</span></code> es la identidad
respecto a <code class="docutils literal notranslate"><span class="pre">++</span></code>. En el mundo de Haskell existen muchos más monoides y por
este motivo existe la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>. Es para tipos que pueden
actuar como monoides. Vamos a ver como se define:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">::</span> <span class="n">m</span>
    <span class="n">mappend</span> <span class="ow">::</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span>
    <span class="n">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span>
    <span class="n">mconcat</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">mappend</span> <span class="n">mempty</span>
</pre></div>
</div>
<img alt="¡Wau wau!" class="align-right" src="../_images/balloondog.png" />
<p>La clase <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> está definida en <code class="docutils literal notranslate"><span class="pre">Data.Monoid</span></code>. Vamos a tomarnos un rato
para familiarizarnos con ella.</p>
<p>Antes de nada, podemos ver que solo los tipo concretos pueden tener una
instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, ya que <code class="docutils literal notranslate"><span class="pre">m</span></code>, en la definición de la clase, no toma
ningún parámetro de tipo. Es diferente de lo que sucede con <code class="docutils literal notranslate"><span class="pre">Functor</span></code> y
<code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, ya que sus instancias requieren que los constructores de
tipos tomen un parámetro.</p>
<p>La primera función es <code class="docutils literal notranslate"><span class="pre">mempty</span></code>. En realidad no es un función porque no toma
ningún parámetro, así que es una constante polimórfica, parecido a
<code class="docutils literal notranslate"><span class="pre">minBound</span></code> o <code class="docutils literal notranslate"><span class="pre">maxBound</span></code>. <code class="docutils literal notranslate"><span class="pre">mempty</span></code> representa el valor identidad para
un determinado monoide.</p>
<p>A continuación tenemos <code class="docutils literal notranslate"><span class="pre">mappend</span></code>, que, como ya habrás adivinado, es la
función binaría. Toma dos parámetros del mismo tipo y devuelve un valor del
mismo tipo también. La decisión de llamar a esta función <code class="docutils literal notranslate"><span class="pre">mappend</span></code> (añadir)
no fue la más correcta, ya que implica que de algún modo vamos añadir dos
cosas. Mientras que <code class="docutils literal notranslate"><span class="pre">++</span></code> toma dos listas y añade una a la otra, <code class="docutils literal notranslate"><span class="pre">*</span></code> no
añade nada, simplemente multiplica dos números. Cuando veamos más instancias
de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, veremos que muchas de ellas tampoco añaden valores con esta
función, así que evita pensar en términos de añadir y piensa que <code class="docutils literal notranslate"><span class="pre">mappend</span></code>
es la función binaria del monoide.</p>
<p>La última función definida por esta clase de tipos es <code class="docutils literal notranslate"><span class="pre">mconcat</span></code>. Toma una
lista de monoides y la reduce y la reduce a uno solo valor aplicando
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> entre los elementos de la lista. Posee una implementación por
defecto, que toma <code class="docutils literal notranslate"><span class="pre">mempty</span></code> como valor inicial y pliega la lista por la
derecha con la función <code class="docutils literal notranslate"><span class="pre">mappend</span></code>. Como la implementación por defecto de
<code class="docutils literal notranslate"><span class="pre">mconcat</span></code> es válida para la mayoría de la instancias, no nos vamos a
preocupar mucho por ella. Cuando creamos una instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> basta
con implementar <code class="docutils literal notranslate"><span class="pre">mempty</span></code> y <code class="docutils literal notranslate"><span class="pre">mappend</span></code>. La razón por la que <code class="docutils literal notranslate"><span class="pre">mconcat</span></code> se
encuentra en la declaración de clase es que para ciertas instancias, puede
que exista una forma más eficiente de implementar <code class="docutils literal notranslate"><span class="pre">mconcat</span></code>, pero para la
mayoría de la instancias la implementación por defecto es perfecta.</p>
<p>Antes de ver algunas de las instancias de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, vamos a echar un pequeño
vistazo a las leyes de los monoides. Hemos mencionado que debe existir un
valor que actúe como identidad con respecto a la función binaria y que dicha
función debe ser asociativa. Es posible crear instancias de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> que no
sigan estas reglas, pero estas instancias no serán útiles para nadie ya que
cuando utilizamos la clase <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, confiamos en que estas instancias se
comporten como monoides De otro modo, ¿qué sentido tendría todo eso? Por esta
razón, cuando creamos instancias debemos asegurarnos de cumplir estas leyes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">mempty</span> <span class="pre">`mappend`</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x</span></code></p></li>
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">x</span> <span class="pre">`mappend`</span> <span class="pre">mempty</span> <span class="pre">=</span> <span class="pre">x</span></code></p></li>
<li><p><code class="xref js js-data docutils literal notranslate"><span class="pre">(x</span> <span class="pre">`mappend`</span> <span class="pre">y)</span> <span class="pre">`mappend`</span> <span class="pre">z</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">`mappend`</span> <span class="pre">(y</span> <span class="pre">`mappend`</span> <span class="pre">z)</span></code></p></li>
</ul>
</div></blockquote>
<p>Las primeras dos leyes establecen que <code class="docutils literal notranslate"><span class="pre">mempty</span></code> debe actuar como identidad
respecto a <code class="docutils literal notranslate"><span class="pre">mappend</span></code> y la tercera dice que <code class="docutils literal notranslate"><span class="pre">mappend</span></code> debe ser asociativa,
es decir, que el orden en el que utilicemos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> para reducir varios
valores de un monoide en uno no debe importar. Haskell no comprueba estas
leyes, así que nosotros como programadores debemos ser cautelosos y
asegurarnos de obedecer estas leyes.</p>
<div class="section" id="las-listas-son-monoides">
<h3>Las listas son monoides<a class="headerlink" href="#las-listas-son-monoides" title="Enlazar permanentemente con este título">¶</a></h3>
<p>¡Sí, las listas son monoides! Como ya hemos visto, la función <code class="docutils literal notranslate"><span class="pre">++</span></code> y la
lista vacía <code class="docutils literal notranslate"><span class="pre">[]</span></code> forman un monoide. La instancia es muy simple:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="n">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>
</pre></div>
</div>
<p>Las listas poseen su propia instancia para la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>
independientemente del tipo de dato que alberguen. Fíjate que hemos utilizado
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Monoid</span> <span class="pre">[a]</span></code> y no <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Monoid</span> <span class="pre">[]</span></code>, ya que <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>
requiere un tipo concreto para formar la instancia.</p>
<p>Si realizamos algunas pruebas no nos encontraremos ninguna sorpresa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; (&quot;one&quot; `mappend` &quot;two&quot;) `mappend` &quot;tree&quot;
&quot;onetwotree&quot;
ghci&gt; &quot;one&quot; `mappend` (&quot;two&quot; `mappend` &quot;tree&quot;)
&quot;onetwotree&quot;
ghci&gt; &quot;one&quot; `mappend` &quot;two&quot; `mappend` &quot;tree&quot;
&quot;onetwotree&quot;
ghci&gt; &quot;pang&quot; `mappend` mempty
&quot;pang&quot;
ghci&gt; mconcat [[1,2],[3,6],[9]]
[1,2,3,6,9]
ghci&gt; mempty :: [a]
[]
</pre></div>
</div>
<img alt="¡Presumiendo!" class="align-left" src="../_images/smug.png" />
<p>Fíjate en la última línea, hemos tenido que usar una anotación de tipo
explícita, ya que si solo hubiésemos puesto <code class="docutils literal notranslate"><span class="pre">mempty</span></code>, <code class="docutils literal notranslate"><span class="pre">GHCi</span></code> no sabría que
instancia usar así que tenemos que especificar que queremos utilizar la
instancia de las listas. Hemos sido capaces de utilizar un tipo general como
<code class="docutils literal notranslate"><span class="pre">[a]</span></code> (en lugar de especificar un tipo concreto como <code class="docutils literal notranslate"><span class="pre">[Int]</span></code> o
<code class="docutils literal notranslate"><span class="pre">[String]</span></code>) porque las listas vacías puede actuar como si contuvieran
cualquier tipo.</p>
<p>Como <code class="docutils literal notranslate"><span class="pre">mconcat</span></code> tiene una implementación por defecto, obtenemos esta función
automáticamente cuando creamos una instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>. En el caso de las
listas`,` <code class="docutils literal notranslate"><span class="pre">mconcat</span></code> se comporta igual que <code class="docutils literal notranslate"><span class="pre">concat</span></code>. Toma una lista de
listas y las une utilizando <code class="docutils literal notranslate"><span class="pre">++</span></code> entre entre las listas adyacentes
contenidas en la lista.</p>
<p>Las leyes de los monoides se cumplen para la instancia de las listas. Cuando
tenemos varias listas y utilizamos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> (o <code class="docutils literal notranslate"><span class="pre">++</span></code>) para unirlas, no
importa que unión hagamos primero, ya que al final acabaran siendo unidas de
todas formas. También, la lista vacía actúa como identidad. Ten en cuenta que
los monoides no requieren que <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">`mappend`</span> <span class="pre">b</span></code> sea igual a
<code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">`mappend`</span> <span class="pre">a</span></code> (es decir, no son conmutativos). En el caso de las listas,
se puede observar fácilmente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;one&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;two&quot;</span>
<span class="s">&quot;onetwo&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;two&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;one&quot;</span>
<span class="s">&quot;twoone&quot;</span>
</pre></div>
</div>
<p>No pasa nada. El hecho de que la multiplicación <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code> y <code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">3</span></code> tengan
el mismo resultado es solo una propiedad de la multiplicación, pero no tiene
porque cumplirse para los monoides.</p>
</div>
<div class="section" id="product-y-sum">
<h3><code class="docutils literal notranslate"><span class="pre">Product</span></code> y <code class="docutils literal notranslate"><span class="pre">Sum</span></code><a class="headerlink" href="#product-y-sum" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ya hemos visto una forma de que los números sean considerados monoides, con la
función <code class="docutils literal notranslate"><span class="pre">*</span></code> y la identidad <code class="docutils literal notranslate"><span class="pre">1</span></code>. Resulta que no es la única forma de que
los números formen un monoide. Otra forma sería utilizando la función binaria
<code class="docutils literal notranslate"><span class="pre">+</span></code> y como identidad <code class="docutils literal notranslate"><span class="pre">0</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; 0 + 4
4
ghci&gt; 5 + 0
5
ghci&gt; (1 + 3) + 5
9
ghci&gt; 1 + (3 + 5)
9
</pre></div>
</div>
<p>La leyes de los monoides se cumplen. Si sumamos a un número 0, el resultado es
ese número. Además la suma también es asociativa, así que no tenemos ningún
problema. Entonces tenemos dos formas de que los números sean monoides,
¿cuál elegimos? Bueno, no tenemos porque elegir. Recuerda, cuando existen
varias instancias de un tipo válidas para una misma clase de tipos, podemos
utilizar <code class="docutils literal notranslate"><span class="pre">newtype</span></code> con ese tipo y crear una instancia para cada
comportamiento.</p>
<p>En este caso el módulo <code class="docutils literal notranslate"><span class="pre">Data.Monoid</span></code> exporta dos tipos, llamados <code class="docutils literal notranslate"><span class="pre">Product</span></code>
y <code class="docutils literal notranslate"><span class="pre">Sum</span></code>. <code class="docutils literal notranslate"><span class="pre">Product</span></code> se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Product</span> <span class="n">a</span> <span class="ow">=</span>  <span class="kt">Product</span> <span class="p">{</span> <span class="n">getProduct</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div>
</div>
<p>Simple, es solo un tipo <code class="docutils literal notranslate"><span class="pre">newtype</span></code> con un parámetro de tipo y algunas clases
derivadas. Su instancia para la clase <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> es esta:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Product</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="mi">1</span>
    <span class="kt">Product</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Product</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mempty</span></code> es simplemente un <code class="docutils literal notranslate"><span class="pre">1</span></code> envuelto en el constructor <code class="docutils literal notranslate"><span class="pre">Product</span></code>. El
patrón de <code class="docutils literal notranslate"><span class="pre">mappend</span></code> se ajusta al constructor <code class="docutils literal notranslate"><span class="pre">Product</span></code>, multiplica los dos
números y devuelve el resultado como <code class="docutils literal notranslate"><span class="pre">Product</span></code>. Como puedes ver, existe una
restricción de clase <code class="docutils literal notranslate"><span class="pre">Num</span> <span class="pre">a</span></code>. Esto quiere decir que <code class="docutils literal notranslate"><span class="pre">Product</span> <span class="pre">a</span></code> tendrá una
instancia para <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> siempre que <code class="docutils literal notranslate"><span class="pre">a</span></code> sea miembro de la clase <code class="docutils literal notranslate"><span class="pre">Num</span></code>.
Para utilizar <code class="docutils literal notranslate"><span class="pre">Product</span> <span class="pre">a</span></code> como monoide, tenemos que introducir y extraer los
valores:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getProduct $ Product 3 `mappend` Product 9
27
ghci&gt; getProduct $ Product 3 `mappend` mempty
3
ghci&gt; getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2
24
ghci&gt; getProduct . mconcat . map Product $ [3,4,2]
24
</pre></div>
</div>
<p>Es bonito como ejemplo de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, pero nadie en su sano
juicio utilizaría esta forma para multiplicar números en lugar de escribir
<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">9</span></code> y <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">1</span></code>. Aún así, dentro de poco veremos como estas instancias
de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> que parece triviales ahora pueden ser muy útiles.</p>
<p><code class="docutils literal notranslate"><span class="pre">Sum</span></code> se define como <code class="docutils literal notranslate"><span class="pre">Product</span></code> y su instancia es similar. Lo utilizamos
del mismo modo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getSum $ Sum 2 `mappend` Sum 9
11
ghci&gt; getSum $ mempty `mappend` Sum 3
3
ghci&gt; getSum . mconcat . map Sum $ [1,2,3]
6
</pre></div>
</div>
</div>
<div class="section" id="any-y-all">
<h3><code class="docutils literal notranslate"><span class="pre">Any</span></code> y <code class="docutils literal notranslate"><span class="pre">All</span></code><a class="headerlink" href="#any-y-all" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Otro tipo que puede comportarse como un monoide de dos formas diferentes y
válidas es <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. La primera forma es tener la función lógica <em>O</em> <code class="docutils literal notranslate"><span class="pre">||</span></code>
como función binaria junto al valor <code class="docutils literal notranslate"><span class="pre">False</span></code> como identidad. La función
lógica <em>O</em> devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si alguno de sus dos parámetros es <code class="docutils literal notranslate"><span class="pre">True</span></code>,
en caso contrario devuelve <code class="docutils literal notranslate"><span class="pre">False</span></code>. Así que si utilizamos <code class="docutils literal notranslate"><span class="pre">False</span></code> como
valor identidad, la función binaria devolverá <code class="docutils literal notranslate"><span class="pre">False</span></code> si su otro parámetro
es <code class="docutils literal notranslate"><span class="pre">False</span></code> y <code class="docutils literal notranslate"><span class="pre">True</span></code> si su otro parámetro es <code class="docutils literal notranslate"><span class="pre">True</span></code>. El constructor
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> <code class="docutils literal notranslate"><span class="pre">Any</span></code> tiene una instancia para <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>. Se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Any</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">{</span> <span class="n">getAny</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div>
</div>
<p>Y la instancia así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Any</span> <span class="kr">where</span>
        <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="kt">False</span>
        <span class="kt">Any</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>La razón por la que se llama <code class="docutils literal notranslate"><span class="pre">Any</span></code> (<em>Algún</em>) es porque devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si
<em>alguno</em> de sus parámetros es <code class="docutils literal notranslate"><span class="pre">True</span></code>. Aunque tres o más valores <code class="docutils literal notranslate"><span class="pre">Bool</span></code>
envueltos en <code class="docutils literal notranslate"><span class="pre">Any</span></code> sean reducidos con <code class="docutils literal notranslate"><span class="pre">mappend</span></code>, el resultado se
mantendrá a <code class="docutils literal notranslate"><span class="pre">True</span></code> si alguno de ellos es <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getAny $ Any True `mappend` Any False
True
ghci&gt; getAny $ mempty `mappend` Any True
True
ghci&gt; getAny . mconcat . map Any $ [False, False, False, True]
True
ghci&gt; getAny $ mempty `mappend` mempty
False
</pre></div>
</div>
<p>La otra forma de que <code class="docutils literal notranslate"><span class="pre">Bool</span></code> sea miembro de la clase <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> es la
contraría: tener <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> como función binaría y <code class="docutils literal notranslate"><span class="pre">True</span></code> como valor identidad.
La función lógica <em>Y</em> devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> solo si ambos parámetros son <code class="docutils literal notranslate"><span class="pre">True</span></code>.
Aquí tienes la declaración de <code class="docutils literal notranslate"><span class="pre">newtype</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">All</span> <span class="ow">=</span> <span class="kt">All</span> <span class="p">{</span> <span class="n">getAll</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
        <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div>
</div>
<p>Y la instancia es:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">All</span> <span class="kr">where</span>
        <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">All</span> <span class="kt">True</span>
        <span class="kt">All</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">All</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">All</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> con tipos <code class="docutils literal notranslate"><span class="pre">All</span></code>, el resultado será <code class="docutils literal notranslate"><span class="pre">True</span></code>
solo si todos los valores son <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getAll $ mempty `mappend` All True
True
ghci&gt; getAll $ mempty `mappend` All False
False
ghci&gt; getAll . mconcat . map All $ [True, True, True]
True
ghci&gt; getAll . mconcat . map All $ [True, True, False]
False
</pre></div>
</div>
<p>Al igual que la multiplicación y la suma, normalmente especificamos
explícitamente la función binaria en lugar de introducir los datos en un tipo
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> para luego utilizar <code class="docutils literal notranslate"><span class="pre">mappend</span></code>. <code class="docutils literal notranslate"><span class="pre">mconcat</span></code> parece útil para
<code class="docutils literal notranslate"><span class="pre">Any</span></code> y <code class="docutils literal notranslate"><span class="pre">All</span></code>, pero normalmente es más fácil usar las funciones <code class="docutils literal notranslate"><span class="pre">or</span></code> o
<code class="docutils literal notranslate"><span class="pre">and</span></code>, las cuales toman una lista de <code class="docutils literal notranslate"><span class="pre">Bool</span></code> y devuelven <code class="docutils literal notranslate"><span class="pre">True</span></code> si hay
algún <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">True</span></code> si todos los son, respectivamente.</p>
</div>
<div class="section" id="el-monoide-ordering">
<h3>El monoide <code class="docutils literal notranslate"><span class="pre">Ordering</span></code><a class="headerlink" href="#el-monoide-ordering" title="Enlazar permanentemente con este título">¶</a></h3>
<p>¿Recuerdas el tipo <code class="docutils literal notranslate"><span class="pre">Ordering</span></code>? Se utiliza como resultado al comparar cosas y
tiene tres posibles valores: <code class="docutils literal notranslate"><span class="pre">LT</span></code>, <code class="docutils literal notranslate"><span class="pre">EQ</span></code> y <code class="docutils literal notranslate"><span class="pre">GT</span></code>, cuyo significado es
<em>menor que</em>, <em>igual que</em> y <em>mayor que</em> respectivamente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; 1 `compare` 2
LT
ghci&gt; 2 `compare` 2
EQ
ghci&gt; 3 `compare` 2
GT
</pre></div>
</div>
<p>Con las listas, los números, los valores booleanos simplemente era cuestión de
buscar una función ya existente que mostrara un comportamiento de monoide. Con
<code class="docutils literal notranslate"><span class="pre">Ordering</span></code> tenemos que buscar más detalladamente para encontrar el monoide,
pero resulta que su instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> es tan intuitiva como las otras
que ya hemos visto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Ordering</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">EQ</span>
    <span class="kt">LT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">LT</span>
    <span class="kt">EQ</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
    <span class="kt">GT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">GT</span>
</pre></div>
</div>
<img alt="¿Alguien pidio una pizza?" class="align-right" src="../_images/bear.png" />
<p>La instancia funciona de este modo: cuando aplicamos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> a dos valores
<code class="docutils literal notranslate"><span class="pre">Ordering</span></code>, el valor de la izquierda se mantiene como resultado, a no ser
que dicho valor sea <code class="docutils literal notranslate"><span class="pre">EQ</span></code>, en cuyo el resultado será el valor de la derecha.
La identidad es <code class="docutils literal notranslate"><span class="pre">EQ</span></code>. A primera vista puede parecer un poco arbitrario, pero
en realidad se asemeja a la forma en la que comparamos las palabras por orden
alfabético. Comparamos las dos primeras letras y si son diferentes ya podemos
decidir cual irá primero en el diccionario. Sin embargo, si las primeras dos
letras son iguales, tenemos que comparar el siguiente par de letras y repetir
el proceso.</p>
<p>Por ejemplo, si comparamos alfabéticamente las palabras <code class="docutils literal notranslate"><span class="pre">&quot;le&quot;</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;la&quot;</span></code>,
primero comparamos las primeras letras de ambas palabras, al comprobar que son
iguales continuamos con las segundas letras de cada palabra. Vemos que <code class="docutils literal notranslate"><span class="pre">'e'</span></code>
es alfabéticamente mayor que <code class="docutils literal notranslate"><span class="pre">'a'</span></code> y de este modo obtenemos el resultado.
Para aclarar porque <code class="docutils literal notranslate"><span class="pre">EQ</span></code> es la identidad, podemos ver que en caso de
comparar la misma letra en la misma posición de ambas palabras, <code class="docutils literal notranslate"><span class="pre">EQ</span></code> no
cambiaría el resultado de su orden alfabético. <code class="docutils literal notranslate"><span class="pre">&quot;lxe&quot;</span></code> sigue siendo
alfabéticamente mayor que <code class="docutils literal notranslate"><span class="pre">&quot;lxa&quot;</span></code>.</p>
<p>Es importante tener en cuenta que la instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> para
<code class="docutils literal notranslate"><span class="pre">Ordering</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">`mappend`</span> <span class="pre">y</span></code> no es igual <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">`mappend`</span> <span class="pre">x</span></code>. Como el primer
parámetro se mantiene como resultado a no ser que sea <code class="docutils literal notranslate"><span class="pre">Eq</span></code>,  <code class="docutils literal notranslate"><span class="pre">LT</span> <span class="pre">`mappend`</span>
<span class="pre">GT</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">LT</span></code>, mientras que <code class="docutils literal notranslate"><span class="pre">GT</span> <span class="pre">`mappend`</span> <span class="pre">LT</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">GT</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; LT `mappend` GT
LT
ghci&gt; GT `mappend` LT
GT
ghci&gt; mempty `mappend` LT
LT
ghci&gt; mempty `mappend` GT
GT
</pre></div>
</div>
<p>Vale, así que, ¿cuál es la utilidad de este monoide? Digamos que estamos
escribiendo una función que toma dos cadenas, compara sus longitudes y
devuelve un resultado del tipo <code class="docutils literal notranslate"><span class="pre">Ordering</span></code>. Pero si las cadenas son del mismo
tamaño, en lugar de devolver <code class="docutils literal notranslate"><span class="pre">EQ</span></code>, las compara alfabéticamente. Una forma
de escribir esto sería así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span>
                        <span class="n">b</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span>
                    <span class="kr">in</span>  <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="kt">EQ</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">a</span>
</pre></div>
</div>
<p>Damos el nombre <code class="docutils literal notranslate"><span class="pre">a</span></code> al resultado de comparar las cadenas por sus longitudes
y <code class="docutils literal notranslate"><span class="pre">b</span></code> al resultado de compararlas alfabéticamente. Si resulta que sus
longitudes son idénticas, devolvemos <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
<p>Pero ahora que sabemos que <code class="docutils literal notranslate"><span class="pre">Ordering</span></code> es un monoide, podemos reescribir esta
función de una forma mucho más simple:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Vamos a probarla:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; lengthCompare &quot;zen&quot; &quot;peces&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;pez&quot;
GT
</pre></div>
</div>
<p>Recuerda, cuando utilizamos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> el parámetro izquierdo será el
resultado a no ser que sea igual a <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, en cuyo caso el resultado será el
parámetro derecho. Por esta razón ponemos la comparación que según nuestro
criterio es más importante como primer parámetro. Si queremos expandir esta
función para que también compare por el número de vocales a modo de segundo
criterio más importante, simplemente tenemos que modificarla así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">vowels</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">vowels</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
    <span class="kr">where</span> <span class="n">vowels</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="s">&quot;aeiou&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Hemos creado una función auxiliar que toma una cadena y nos dice cuantas
vocales tiene. Para ello filtra las letras que estén contenidas en la cadena
<code class="docutils literal notranslate"><span class="pre">&quot;aeiou&quot;</span></code> y luego aplica <code class="docutils literal notranslate"><span class="pre">length</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; lengthCompare &quot;zen&quot; &quot;anna&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;ana&quot;
LT
ghci&gt; lengthCompare &quot;zen&quot; &quot;ann&quot;
GT
</pre></div>
</div>
<p>Genial. En el primer ejemplo vemos que si las longitudes de las cadenas son
distintas devuelve <code class="docutils literal notranslate"><span class="pre">LT</span></code>, ya que la longitud de <code class="docutils literal notranslate"><span class="pre">&quot;zen&quot;</span></code> es menor que la de
<code class="docutils literal notranslate"><span class="pre">&quot;anna&quot;</span></code>. En el segundo ejemplo, las longitudes son iguales, pero la segunda
cadena tiene más vocales, así que devuelve <code class="docutils literal notranslate"><span class="pre">LT</span></code> de nuevo. En el tercer
ejemplo, ambas cadenas tienen la misma longitud y el mismo número de vocales,
así que se comparan alfabéticamente y <code class="docutils literal notranslate"><span class="pre">&quot;zen&quot;</span></code> gana.</p>
<p>El monoide <code class="docutils literal notranslate"><span class="pre">Ordering</span></code> es muy útil ya que nos facilita comparar cosas por
varios criterios en un cierto orden, del más importante al menos importante.</p>
</div>
<div class="section" id="el-monoide-maybe">
<h3>El monoide <code class="docutils literal notranslate"><span class="pre">Maybe</span></code><a class="headerlink" href="#el-monoide-maybe" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Vamos a ver varias formas en las que <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> puede actuar como un monoide
y para que son útiles.</p>
<p>Una forma sería tratar <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> como monoide solo si su parámetro de tipo
<code class="docutils literal notranslate"><span class="pre">a</span></code> es también un monoide, de forma que <code class="docutils literal notranslate"><span class="pre">mappend</span></code> se implemente utilizando
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> con los valores contenidos en <code class="docutils literal notranslate"><span class="pre">Just</span></code>.  Utilizamos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>
como identidad, de modo que si uno de los dos valores que pasamos a
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, el resultado será el otro valor. Así sería la
declaración de la instancia:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span>
    <span class="n">m</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="n">m</span>
    <span class="kt">Just</span> <span class="n">m1</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Just</span> <span class="n">m2</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">m1</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">m2</span><span class="p">)</span>
</pre></div>
</div>
<p>Fíjate en la restricción de clase. Dice que <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> tendrá una instancia
de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code> solo si <code class="docutils literal notranslate"><span class="pre">a</span></code> posee una instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>. Si aplicamos
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> a algo y a <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, el resultado será ese algo. Si aplicamos
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> a dos valores <code class="docutils literal notranslate"><span class="pre">Just</span></code>, se aplicará <code class="docutils literal notranslate"><span class="pre">mappend</span></code> al contenido de
ambos valores y el resultado de dicha operación se introducirá en un valor
<code class="docutils literal notranslate"><span class="pre">Just</span></code>. Somos capaces de realizar esta operación porque la restricción de
clase nos asegura que el tipo que contiene los valores <code class="docutils literal notranslate"><span class="pre">Just</span></code> posee una
instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Nothing `mappend` Just &quot;andy&quot;
Just &quot;andy&quot;
ghci&gt; Just LT `mappend` Nothing
Just LT
ghci&gt; Just (Sum 3) `mappend` Just (Sum 4)
Just (Sum {getSum = 7})
</pre></div>
</div>
<p>Este monoide es útil cuando estamos trabajando con resultados de cómputos que
pueden fallar. Gracias a esta instancia, no nos tenemos que preocupar por
comprobar si los cómputos han fallado y por lo tanto son <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> o bien
son <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Simplemente debemos tratarlos como valores normales.</p>
<p>Pero, ¿qué sucede si el contenido de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> no forma parte de la clase
<code class="docutils literal notranslate"><span class="pre">Monoid</span></code>? Si te fijas, en la declaración de la instancia anterior, el único
lugar donde necesitábamos que los contenidos fueran monoides era cuando los
dos parámetros de <code class="docutils literal notranslate"><span class="pre">mappend</span></code> eran <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Pero si desconocemos si los
contenidos son monoides o no, no podemos utilizar <code class="docutils literal notranslate"><span class="pre">mappend</span></code> con ellos, así
que, ¿qué podemos hacer? Bueno, una de las cosas que podemos hacer es
descartar el segundo valor y quedarnos con el primero. Por este motivo existe
el tipo <code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">a</span></code> y esta es su definición:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">First</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">First</span> <span class="p">{</span> <span class="n">getFirst</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Tomamos un tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> y lo envolvemos en un <code class="docutils literal notranslate"><span class="pre">newtype</span></code>. La instancia de
<code class="docutils literal notranslate"><span class="pre">Monoid</span></code> sería así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">First</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">First</span> <span class="kt">Nothing</span>
    <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
    <span class="kt">First</span> <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div>
</div>
<p>Tal y como hemos dicho. <code class="docutils literal notranslate"><span class="pre">mempty</span></code> es simplemente <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> dentro del
constructor <code class="docutils literal notranslate"><span class="pre">newtype</span></code> <code class="docutils literal notranslate"><span class="pre">First</span></code>. Si el primer parámetro de <code class="docutils literal notranslate"><span class="pre">mappend</span></code> es un
valor <code class="docutils literal notranslate"><span class="pre">Just</span></code> ignoramos el segundo parámetro. Si el primer parámetro es
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, entonces damos el segundo parámetro como resultado,
independientemente de que sea <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> o <code class="docutils literal notranslate"><span class="pre">Just</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getFirst $ First (Just &#39;a&#39;) `mappend` First (Just &#39;b&#39;)
Just &#39;a&#39;
ghci&gt; getFirst $ First Nothing `mappend` First (Just &#39;b&#39;)
Just &#39;b&#39;
ghci&gt; getFirst $ First (Just &#39;a&#39;) `mappend` First Nothing
Just &#39;a&#39;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">First</span></code> es útil cuando tenemos un montón de valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y solamente
queremos saber si alguno de ellos es <code class="docutils literal notranslate"><span class="pre">Just</span></code>. La función <code class="docutils literal notranslate"><span class="pre">mconcat</span></code> será
útil en esos momentos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]
Just 9
</pre></div>
</div>
<p>Si queremos que un monoide <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> conserve el segundo parámetro cuando
se aplica <code class="docutils literal notranslate"><span class="pre">mappend</span></code> sobre dos valores <code class="docutils literal notranslate"><span class="pre">Just</span></code> en lugar del primero,
<code class="docutils literal notranslate"><span class="pre">Data.Monoid</span></code> proporciona el tipo <code class="docutils literal notranslate"><span class="pre">Last</span> <span class="pre">a</span></code> que funciona igual que
<code class="docutils literal notranslate"><span class="pre">First</span> <span class="pre">a</span></code>, solo que el último valor no <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> se mantiene como
resultado cuando se utiliza <code class="docutils literal notranslate"><span class="pre">mappend</span></code> o <code class="docutils literal notranslate"><span class="pre">mconcat</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]
Just 10
ghci&gt; getLast $ Last (Just &quot;one&quot;) `mappend` Last (Just &quot;two&quot;)
Just &quot;two&quot;
</pre></div>
</div>
</div>
<div class="section" id="utilizando-monoides-para-plegar-estructuras-de-datos">
<h3>Utilizando monoides para plegar estructuras de datos<a class="headerlink" href="#utilizando-monoides-para-plegar-estructuras-de-datos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una de las formas más interesante de utilizar los monoides es para que nos
ayuden a la hora de definir pliegues sobre estructuras de datos. Hasta ahora
solo hemos utilizados pliegues sobre listas, pero las listas no son el único
tipo de dato que se puede plegar. Podemos definir pliegues sobre casi
cualquier tipo de estructura. Lo árboles, por ejemplo, encajan perfectamente
con este concepto.</p>
<p>Debido a que existen tantos tipos de datos que funcionan perfectamente con los
pliegues, utilizamos la clase de tipos <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Foldable</span></code>. De la misma
forma <code class="docutils literal notranslate"><span class="pre">Functor</span></code> es para cosas que pueden ser mapeadas, <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> es para
cosas que puede ser plegadas. Se encuentra en <code class="docutils literal notranslate"><span class="pre">Data.Foldable</span></code> y como exporta
funciones con nombres iguales a funciones residentes en <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, se mejor
importarlo cualificado:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Foldable</span> <span class="k">as</span> <span class="n">F</span>
</pre></div>
</div>
<p>Para evitar sobre-esforzar nuestros queridos dedos, hemos elegido importarlo
con el nombre <code class="docutils literal notranslate"><span class="pre">F</span></code>. ¿Y bien? ¿cuáles son las funciones que define esta clase
de tipos? Bueno, básicamente son <code class="docutils literal notranslate"><span class="pre">foldr</span></code>, <code class="docutils literal notranslate"><span class="pre">foldl</span></code>, <code class="docutils literal notranslate"><span class="pre">foldr1</span></code> y
<code class="docutils literal notranslate"><span class="pre">foldl1</span></code>. ¿Cómo? Ya conocemos estas funciones así que, ¿qué tienen
diferente? Vamos a comparar los tipos de <code class="docutils literal notranslate"><span class="pre">foldr</span></code> de <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> y de
<code class="docutils literal notranslate"><span class="pre">foldr</span></code> de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> para ver las diferencias:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t foldr
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
ghci&gt; :t F.foldr
F.foldr :: (F.Foldable t) =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</pre></div>
</div>
<p>Mientras que <code class="docutils literal notranslate"><span class="pre">foldr</span></code> toma una lista y la pliega, el <code class="docutils literal notranslate"><span class="pre">foldr</span></code> de
<code class="docutils literal notranslate"><span class="pre">Data.Foldable</span></code> toma cualquier tipo que pueda ser plegado , ¡no solo listas!
Como era de esperar, ambas funciones se comportan igual con las listas.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foldr (*) 1 [1,2,3]
6
ghci&gt; F.foldr (*) 1 [1,2,3]
6
</pre></div>
</div>
<p>Bien, ¿qué otras estructuras soportan pliegues? Pues nuestro querido <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
por ejemplo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; F.foldl (+) 2 (Just 9)
11
ghci&gt; F.foldr (||) False (Just True)
True
</pre></div>
</div>
<p>Pero plegar valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> no es que sea especialmente interesante, ya que
cuando realiza el pliegue actúa como si se tratara de una lista con un solo
elemento en caso de que valor sea <code class="docutils literal notranslate"><span class="pre">Just</span></code> o como una lista vacía si el valor
es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Vamos a examinar una estructura de datos que sea más compleja.</p>
<p>¿Recuerdas la estructura de datos de árbol que utilizamos en el capítulo de
«<a class="reference internal" href="clasesdetipos.html#estrucrec"><span class="std std-ref">Creando nuestros propios tipos de datos</span></a>»? Lo definimos
así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Dijimos que un árbol es o bien en un árbol vacío que no contiene ningún valor
o bien un nodo que contiene un valor y también otros dos árboles. Después de
definirlo, creamos su instancia para la clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code> y con ella ganamos
la habilidad de usar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> con estos árboles. Ahora vamos a crear la
instancia de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> de forma que podamos plegar estos árboles. Una forma
de crear la instancia de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> para un determinado constructor de tipos
es simplemente implementar la función <code class="docutils literal notranslate"><span class="pre">foldr</span></code> para él. Pero existe otra
forma, normalmente mucho más sencilla, y es implementar la función
<code class="docutils literal notranslate"><span class="pre">foldMap</span></code>, que también forma parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>. La
función <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> tiene la siguiente declaración de tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Foldable</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span>
</pre></div>
</div>
<p>El primer parámetro es una función que toma un valor del tipo que la
estructura de datos plegable contiene (denominada aquí <code class="docutils literal notranslate"><span class="pre">a</span></code>) y devuelve un
monoide. El segundo parámetro es una estructura plegable que contiene valores
del tipo <code class="docutils literal notranslate"><span class="pre">a</span></code>. Mapea esa función sobre la estructura de datos plegable,
produciendo de esta forma una estructura plegable que contiene monoides.
Luego, aplicando <code class="docutils literal notranslate"><span class="pre">mappend</span></code> entre estos monoides, los reduce todos en un solo
valor. Esta función puede parece algo rara ahora mismo, pero veremos que es
realmente fácil de implementar. Otra cosa que también es interesante es que
cuando implementemos estas función no necesitaremos hacer nada más para
implementar el resto de la instancia <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>. Así que simplemente
tenemos que implementar la función <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> para un tipo, y obtenemos
automáticamente <code class="docutils literal notranslate"><span class="pre">foldr</span></code> y <code class="docutils literal notranslate"><span class="pre">foldl</span></code>.</p>
<p>Aquí tienes como definimos la instancia de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> para <code class="docutils literal notranslate"><span class="pre">Tree</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">F</span><span class="o">.</span><span class="kt">Foldable</span> <span class="kt">Tree</span> <span class="kr">where</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="n">mempty</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="n">f</span> <span class="n">l</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                             <span class="n">f</span> <span class="n">x</span>           <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                             <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="n">f</span> <span class="n">r</span>
</pre></div>
</div>
<img alt="Encuentra la analogía visual" class="align-right" src="../_images/accordion.png" />
<p>Si tenemos una función que toma un elemento del árbol y devuelve un monoide,
¿cómo reducimos el árbol entero a un único monoide? Cuando aplicamos <code class="docutils literal notranslate"><span class="pre">fmap</span></code>
a un árbol, aplicamos la función que estamos mapeando a un nodo y luego
mapeamos recursivamente esa misma función sobre el sub-árbol izquierdo y el
sub-árbol derecho. En este caso nuestra tarea no consiste únicamente en
mapear una función, sino que también tenemos que reducir todos los resultados
en un único monoide utilizando <code class="docutils literal notranslate"><span class="pre">mappend</span></code>. Primero consideramos el caso de
un árbol vacío, un triste y solitario árbol que no contienen ningún valor ni
ningún sub-árbol. Como no contiene ningún valor no podemos aplicar la función
binaria del monoide, así que nos limitamos a decir que el árbol está vacío
devolviendo el valor <code class="docutils literal notranslate"><span class="pre">mempty</span></code>.</p>
<p>El caso de un nodo no vacío es algo más interesante. Contiene dos sub-árboles
y también un valor. En este caso, aplicamos recursivamente la función
<code class="docutils literal notranslate"><span class="pre">foldMap</span></code> junto a <code class="docutils literal notranslate"><span class="pre">f</span></code> al sub-árbol izquierdo y derecho. Recuerda, la
función <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> devuelve un único valor, un monoide. También aplicamos la
función <code class="docutils literal notranslate"><span class="pre">f</span></code> al valor contenido en el nodo. De este modo, ahora tenemos tres
monoides (dos de los sub-árboles y otro de aplicar <code class="docutils literal notranslate"><span class="pre">f</span></code> al nodo actual) y
solo tenemos que reducirlos a un único valor. Para lograrlo utilizamos la
función <code class="docutils literal notranslate"><span class="pre">mappend</span></code>, primero con el valor del sub-árbol izquierdo, luego con
el valor del nodo y para terminar con el valor del sub-árbol derecho.</p>
<p>Ten en cuenta que no somos los encargados de crear la función que toma un
valor y devuelve un monoide. Recibimos esa función como parámetro de
<code class="docutils literal notranslate"><span class="pre">foldMap</span></code> y todo lo que debemos hacer es decidir donde vamos a aplicarla y
como reducir los monoides a un único valor.</p>
<p>Ahora que tenemos una instancia de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> para el tipo árbol, obtenemos
<code class="docutils literal notranslate"><span class="pre">foldr</span></code> y <code class="docutils literal notranslate"><span class="pre">foldl</span></code> automáticamente. Considera este árbol:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">testTree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="mi">5</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">10</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>Tiene un <code class="docutils literal notranslate"><span class="pre">5</span></code> como raíz y luego su nodo izquierdo tiene un <code class="docutils literal notranslate"><span class="pre">3</span></code> con un <code class="docutils literal notranslate"><span class="pre">1</span></code>
a su izquierda y un <code class="docutils literal notranslate"><span class="pre">6</span></code> a su derecha. El nodo raíz de la derecha contiene un
<code class="docutils literal notranslate"><span class="pre">9</span></code> junto con un <code class="docutils literal notranslate"><span class="pre">8</span></code> a su izquierda y un <code class="docutils literal notranslate"><span class="pre">10</span></code> a la derecha. Gracias a
la instancia de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code> ahora podemos utilizar todos los pliegues que
usábamos con las listas:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; F.foldl (+) 0 testTree
42
ghci&gt; F.foldl (*) 1 testTree
64800
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">foldMap</span></code> no solo es útil para crear nuevas instancias de <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>.
También es útil para reducir una estructura a un único valor monoidal. Por
ejemplo, si queremos saber si algún número de un árbol es igual a <code class="docutils literal notranslate"><span class="pre">3</span></code>
podemos hacer lo siguiente:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getAny $ F.foldMap (\x -&gt; Any $ x == 3) testTree
True
</pre></div>
</div>
<p>Aquí, <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">Any</span> <span class="pre">$</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">3</span></code> es una función que toma un número y devuelve un
valor monoidal, en concreto un <code class="docutils literal notranslate"><span class="pre">Bool</span></code> dentro de un <code class="docutils literal notranslate"><span class="pre">Any</span></code>. <code class="docutils literal notranslate"><span class="pre">foldMap</span></code>
aplica esta función a todos los elementos del árbol y luego reduce todos los
resultados monoidales a un único valor monoidal. Si hacemos esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Any</span> <span class="o">$</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="n">testTree</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>Todos los nodos del árbol contendrían el valor <code class="docutils literal notranslate"><span class="pre">Any</span> <span class="pre">False</span></code> después de que
la función lambda se aplicara sobre ellos. Para que <code class="docutils literal notranslate"><span class="pre">mappend</span></code> sobre valores
del tipo <code class="docutils literal notranslate"><span class="pre">Any</span></code> devuelva <code class="docutils literal notranslate"><span class="pre">True</span></code> al menos uno de sus parámetros debe ser
<code class="docutils literal notranslate"><span class="pre">True</span></code>. Por este motivo el resultado que obtenemos al final es <code class="docutils literal notranslate"><span class="pre">False</span></code>, y
tiene sentido ya que no hay ningún valor mayor que <code class="docutils literal notranslate"><span class="pre">15</span></code> en el árbol.</p>
<p>También podemos convertir el árbol en una lista fácilmente. Para ello
utilizamos <code class="docutils literal notranslate"><span class="pre">foldMap</span></code> con la función <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">[x]</span></code>. Al proyectar la función
sobre el árbol obtenemos un árbol que contendrá listas unitarias. Luego se
aplicará <code class="docutils literal notranslate"><span class="pre">mappend</span></code> sobre todas esas listas de forma que obtendremos una
única lista que contendrá todos los valores del árbol original.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; F.foldMap (\x -&gt; [x]) testTree
[1,3,6,5,8,9,10]
</pre></div>
</div>
<p>Lo mejor de todo es que este truco no se limita únicamente a los árboles,
funciona para cualquier tipo miembro de la clase <code class="docutils literal notranslate"><span class="pre">Foldable</span></code>.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="monadas.html" title="Un puñado de mónadas"
             >siguiente</a></li>
        <li class="right" >
          <a href="problemas.html" title="Resolviendo problemas de forma funcional"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>