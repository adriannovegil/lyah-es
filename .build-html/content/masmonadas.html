
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Unas cuantas mónadas más &#8212; documentación de ¡Aprende Haskell por el bien de todos! - 0.1</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Zippers" href="zippers.html" />
    <link rel="prev" title="Un puñado de mónadas" href="monadas.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="zippers.html" title="Zippers"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="monadas.html" title="Un puñado de mónadas"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="unas-cuantas-monadas-mas">
<h1>Unas cuantas mónadas más<a class="headerlink" href="#unas-cuantas-monadas-mas" title="Enlazar permanentemente con este título">¶</a></h1>
<img alt="Amigo, existen dos tipos de personas en el mundo: los que aprenden Haskell y lo que trabajan programando en Java." class="align-right" src="../_images/clint.png" />
<p>Hemos visto como podemos utilizar las mónadas para tomar valores con un cierto
contexto y aplicarles funciones utilizando <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> o la notación <code class="docutils literal notranslate"><span class="pre">do</span></code>, lo
cual nos permite centrarnos en los valores en si mientras que el contexto se
trata automáticamente.</p>
<p>Ya hemos conocemos la mónada <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y hemos visto como añade un contexto de
que existan posibles fallos. Ya hemos aprendido a utilizar la mónada lista y
hemos visto como nos permite introducir un no determinismo en nuestros
programas. También hemos aprendido a trabajar con la mónada <code class="docutils literal notranslate"><span class="pre">IO</span></code>, ¡incluso
antes de que supiéramos de la existencia de las mónadas!</p>
<p>En este capítulo, vamos a ver una cuantas mónadas más. Veremos como éstas
pueden conseguir que nuestros programas sean más claros permitiéndonos manejar
todo tipo de valores como si fueran monádicos. El hecho de ver unas cuantas
mónadas más también reforzará nuestro conocimiento acerca de ellas.</p>
<p>Todas las mónadas que vamos a ver forman parte del paquete <code class="docutils literal notranslate"><span class="pre">mtl</span></code>. Un
paquete de Haskell es una colección de módulos. El paquete <code class="docutils literal notranslate"><span class="pre">mtl</span></code> viene con
la plataforma Haskell así que probablemente ya lo tengas instalado. Para
comprobarlo, ejecuta <code class="docutils literal notranslate"><span class="pre">ghc-pkg</span> <span class="pre">list</span></code> en la línea de comandos. Así podrás ver
todos los paquetes que tienes instalados y uno de ellos debe ser <code class="docutils literal notranslate"><span class="pre">mtl</span></code>,
seguido de un número de versión.</p>
<div class="section" id="writer-no-la-conozco">
<h2>¿Writer? No la conozco<a class="headerlink" href="#writer-no-la-conozco" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hemos cargado una pistola con la mónada <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, la mónada lista y la mónada
<code class="docutils literal notranslate"><span class="pre">IO</span></code>. Ahora vamos a hacer sitio en la recámara para la mónada <code class="docutils literal notranslate"><span class="pre">Writer</span></code> y
ver que pasa cuando la disparamos.</p>
<p>Mientras que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> sirve para valores con el contexto adicional de un
posible fallo y las listas son para valores no deterministas, la mónada
<code class="docutils literal notranslate"><span class="pre">Writer</span></code> sirve para valores que tienen una especie de registres como
contexto. La mónada <code class="docutils literal notranslate"><span class="pre">Writer</span></code> nos permite realizar cómputos de forma que los
valores del registro se combinan en un solo registro que será adjuntado al
resulto final.</p>
<p>Por ejemplo, podríamos querer equipar algunos valores con unas cadenas que
explicaran lo que esta sucediendo, probablemente para luego depurar el
código. La siguiente función toma el número de bandidos de una banda y nos
dice si es una gran banda o no. Una función muy simple:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isBigGang</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isBigGang</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span>
</pre></div>
</div>
<p>Ahora, en lugar de que nos devuelva solo <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>, queremos que
nos devuelve también una cadena de registro que nos indique que ha hecho la
función. Para ello solo tenemos que devolver una cadena junto al valor
<code class="docutils literal notranslate"><span class="pre">Bool</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">isBigGang</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">isBigGang</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;Compared gang size to 9.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que ahora en vez de devolver una valor <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, devuelve una tupla cuyo
primer es el resultado original y el segundo es la cadena que acompaña al
resultado. Ahora este resultado tiene añadido un cierto contexto. Vamos a
probarla:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; isBigGang 3
(False,&quot;Compared gang size to 9.&quot;)
ghci&gt; isBigGang 30
(True,&quot;Compared gang size to 9.&quot;)
</pre></div>
</div>
<img alt="Cuando vayas al retrete, haz tus necesidades, no hables." class="align-left" src="../_images/tuco.png" />
<p>Hasta aquí todo bien. <code class="docutils literal notranslate"><span class="pre">isBigGang</span></code> toma un valor normal y devuelve un valor
con un determinado contexto. Como ya sabemos, pasar a esta función un valor
normal no causa ningún problema. Pero, ¿y si ya tenemos un valor que tiene
adjuntado una cadena, como por ejemplo <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">&quot;Smallish</span> <span class="pre">gang.&quot;)</span></code>, y queremos
pasarlo a <code class="docutils literal notranslate"><span class="pre">isBigGang</span></code>? Parece que una vez más nos topamos con la misma
pregunta: si tenemos una función que toma un valor normal y devuelve un valor
con un cierto contexto, ¿cómo extraemos el valor de ese contexto y se lo
pasamos a la función?</p>
<p>Cuando estábamos explorando la mónada <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> creamos la función
<code class="docutils literal notranslate"><span class="pre">applyMaybe</span></code>, la cual tomaba un valor de tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> y una función del
tipo <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code> y pasa ese valor <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> a la función, incluso
aunque la función toma una valor del tipo <code class="docutils literal notranslate"><span class="pre">a</span></code> y no <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. Conseguíamos
hacer esto teniendo en cuenta el contexto de los valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, el cual
era el de los valores con un posible fallo. Dentro de la función
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code> éramos capaces de tratar ese valor con absoluta normalidad,
ya que <code class="docutils literal notranslate"><span class="pre">applyMaybe</span></code> (que luego vino a ser <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>) se encargaba de
comprobar si el valor era <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> o un valor <code class="docutils literal notranslate"><span class="pre">Just</span></code>.</p>
<p>Del mismo modo, vamos a crear una función que tome un valor con un registro
añadido, como por ejemplo <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">String)</span></code>, y una función del tipo
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">String)</span></code> a la que pasaremos el valor inicial. La llamaremos
<code class="docutils literal notranslate"><span class="pre">applyLog</span></code>. Como un valor del tipo <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">String)</span></code> no lleva asociado ningún
contexto de un posible fallo, sino únicamente un registro adicional,
<code class="docutils literal notranslate"><span class="pre">applyLog</span></code> se encargará de que el registro de la variable original no se
pierda concatenándolo con el registro del resultado de la función. Aquí tienes
la implementación de <code class="docutils literal notranslate"><span class="pre">applyLog</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="kt">String</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span>
<span class="nf">applyLog</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">newLog</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">log</span> <span class="o">++</span> <span class="n">newLog</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando tenemos un valor dentro de un contexto y queremos pasar dicho valor
a una función, normalmente intentamos separar el valor real del contexto,
luego intentamos aplicar la función sobre ese valor y para terminar volvemos
a considerar el contexto. Con la mónada <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, primero comprobamos si el
valor era del tipo <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">x</span></code> y si lo era, tomábamos el valor <code class="docutils literal notranslate"><span class="pre">x</span></code> y lo
aplicábamos a la función. En este caso es fácil encontrar el valor real, ya
que estamos trabajando con una dupla que contiene el valor y un registro.
Primero tomamos el valor, que es <code class="docutils literal notranslate"><span class="pre">x</span></code> y le aplicamos la función <code class="docutils literal notranslate"><span class="pre">f</span></code>.
Obtenemos una dupla de <code class="docutils literal notranslate"><span class="pre">(y,</span> <span class="pre">newLog)</span></code>, donde <code class="docutils literal notranslate"><span class="pre">y</span></code> es el nuevo resultado y
<code class="docutils literal notranslate"><span class="pre">newLog</span></code> es el nuevo registro. Sin embargo, si devolviéramos esto como
resultado, el registro antiguo no se incluiría en el resultado, así que
devolvemos una dupla <code class="docutils literal notranslate"><span class="pre">(y,log</span> <span class="pre">++</span> <span class="pre">newLog)</span></code>. Utilizamos <code class="docutils literal notranslate"><span class="pre">++</span></code> para concatenar
ambos registros.</p>
<p>Aquí tienes <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> en acción:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (3, &quot;Smallish gang.&quot;) `applyLog` isBigGang
(False,&quot;Smallish gang.Compared gang size to 9&quot;)
ghci&gt; (30, &quot;A freaking platoon.&quot;) `applyLog` isBigGang
(True,&quot;A freaking platoon.Compared gang size to 9&quot;)
</pre></div>
</div>
<p>El resultado es similar al anterior, solo que el número de bandidos en la
banda va acompañado de un registro. Unos cuantos ejemplos más:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (&quot;Tobin&quot;,&quot;Got outlaw name.&quot;) `applyLog` (\x -&gt; (length x, &quot;Applied length.&quot;))
(5,&quot;Got outlaw name.Applied length.&quot;)
ghci&gt; (&quot;Bathcat&quot;,&quot;Got outlaw name.&quot;) `applyLog` (\x -&gt; (length x, &quot;Applied length&quot;))
(7,&quot;Got outlaw name.Applied length&quot;)
</pre></div>
</div>
<p>Fíjate en el interior de la función lambda, <code class="docutils literal notranslate"><span class="pre">x</span></code> es un cadena normal y no una
tupla. Además <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> se encarga de concatenar los registros.</p>
<div class="section" id="monoides-al-rescate">
<h3>Monoides al rescate<a class="headerlink" href="#monoides-al-rescate" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>¡Asegurate de saber lo que son los <a class="reference internal" href="funtores.html#monoides"><span class="std std-ref">monoides</span></a> si
quieres continuar!</p>
</div>
<p>Ahora mismo, <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> toma valores del tipo <code class="docutils literal notranslate"><span class="pre">(a,String)</span></code>, pero, ¿existe
alguno motivo especial por el que lo registros deban ser del tipo <code class="docutils literal notranslate"><span class="pre">String</span></code>?
Utilizamos <code class="docutils literal notranslate"><span class="pre">++</span></code> para unir los registros, así que, ¿no debería aceptar
cualquier tipo de listas, y no solo listas de caracteres? Pues sí, debería.
Podemos cambiar su tipo a:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="n">c</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">c</span><span class="p">]))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<p>Ahora, el registro es una lista. El tipo de valores que contiene la lista debe
ser el mismo tipo de que tienen los elementos de la lista original, a la vez
que deben ser iguales a los que devuelve la función. De otro modo, no
podríamos utilizar <code class="docutils literal notranslate"><span class="pre">++</span></code> para unirlos.</p>
<p>¿Debería función con cadenas de bytes? No hay ninguna razón para que no
funcionase. Sin embargo, el tipo que hemos utilizado solo acepta listas.
Parece que tendremos que crear una <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> solo para cadenas de bytes
¡Pero espera! Tanto las listas como los cadenas de bytes son monoides. Como
tal, ambas poseen instancias de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>, lo cual
significa que ambas implementan la función <code class="docutils literal notranslate"><span class="pre">mappend</span></code>. Y tanto par las listas
como para las cadenas de bytes, <code class="docutils literal notranslate"><span class="pre">mappend</span></code> sirve para unir. Mira:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [1,2,3] `mappend` [4,5,6]
[1,2,3,4,5,6]
ghci&gt; B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
Chunk &quot;chi&quot; (Chunk &quot;huahua&quot; Empty)
</pre></div>
</div>
<p>¡Genial! Ahora <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> pede funcionar con cualquier monoide. Tenemos que
cambiar la declaración de tipo para que lo refleje, y también la
implementación ya que tenemos cambiar <code class="docutils literal notranslate"><span class="pre">++</span></code> por <code class="docutils literal notranslate"><span class="pre">mappend</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">m</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">m</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="nf">applyLog</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">newLog</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">log</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">newLog</span><span class="p">)</span>
</pre></div>
</div>
<p>Como el valor que acompaña al valor original ahora puede ser cualquier tipo
de monoide, ya no tenemos que porque ver la dupla como una valor y un
registro, sino como una valor y un monoide. Por ejemplo, podemos tener una
tupla que tenga el nombre de un producto y su precio como valor monoidal.
Simplemente tenemos que utilizar el <code class="docutils literal notranslate"><span class="pre">newtype</span></code> <code class="docutils literal notranslate"><span class="pre">Sum</span></code> para asegurarnos de
que los precios se suman. Aquí tienes un ejemplo de una función que añade
la bebida para cierto tipo de comida de cowboy:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="kr">type</span> <span class="kt">Food</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Price</span> <span class="ow">=</span> <span class="kt">Sum</span> <span class="kt">Int</span>

<span class="nf">addDrink</span> <span class="ow">::</span> <span class="kt">Food</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Food</span><span class="p">,</span><span class="kt">Price</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="s">&quot;beans&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;milk&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">25</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="s">&quot;jerky&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;whiskey&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">99</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="kr">_</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;beer&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>Utilizamos cadenas para representar las comidas y un <code class="docutils literal notranslate"><span class="pre">Int</span></code> dentro de un
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> <code class="docutils literal notranslate"><span class="pre">Sum</span></code> para mantener el precio total. Recuerda, cuando utilizamos
<code class="docutils literal notranslate"><span class="pre">mappend</span></code> con <code class="docutils literal notranslate"><span class="pre">Sum</span></code> el resultado será la suma de ambos parámetros:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Sum 3 `mappend` Sum 9
Sum {getSum = 12}
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">addDrink</span></code> es bastante simple. Si estamos comiendo alubias,
devuelve <code class="docutils literal notranslate"><span class="pre">&quot;milk&quot;</span></code> junto <code class="docutils literal notranslate"><span class="pre">Sum</span> <span class="pre">25</span></code>, es decir 25 centavos dentro de un
<code class="docutils literal notranslate"><span class="pre">Sum</span></code>. Si estamos comiendo cecina bebemos whisky y si estamos comiendo
cualquier otra cosa bebemos cerveza. Aplicar esta función a una comida no
sería muy interesante, pero si utilizamos <code class="docutils literal notranslate"><span class="pre">applyLog</span></code> para pasar una comida
junto a un precio a esta función la cosa se vuelve más interesante:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (&quot;beans&quot;, Sum 10) `applyLog` addDrink
(&quot;milk&quot;,Sum {getSum = 35})
ghci&gt; (&quot;jerky&quot;, Sum 25) `applyLog` addDrink
(&quot;whiskey&quot;,Sum {getSum = 124})
ghci&gt; (&quot;dogmeat&quot;, Sum 5) `applyLog` addDrink
(&quot;beer&quot;,Sum {getSum = 35})
</pre></div>
</div>
<p>La leche cuesta <code class="docutils literal notranslate"><span class="pre">25</span></code> centavos, pero si comemos alubias que cuestan <code class="docutils literal notranslate"><span class="pre">10</span></code>
centavos, acabaremos pagando <code class="docutils literal notranslate"><span class="pre">35</span></code> centavos. Ahora se ve claramente como el
valor que acompañamos no tiene porque ser siempre un registro, puede ser
cualquier tipo de monoide y como se unan ambos valores dependerá de ese
monoide. Cuando utilizamos registros, se concatenan, cuando utilizamos
números, se suman, etc.</p>
<p>Como el valor que devuelve <code class="docutils literal notranslate"><span class="pre">addDrink</span></code> es una dupla del tipo
<code class="docutils literal notranslate"><span class="pre">(Food,Price)</span></code>, podemos pasar el resultado a <code class="docutils literal notranslate"><span class="pre">addDrink</span></code> de nuevo, de forma
que el resultado nos diga que vamos a beber y cuanto nos a costado en total.
Aquí tienes una muestra:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (&quot;dogmeat&quot;, Sum 5) `applyLog` addDrink `applyLog` addDrink
(&quot;beer&quot;,Sum {getSum = 65})
</pre></div>
</div>
<p>Si añadimos una bebida a un poco de carne de perro obtendremos una cerveza
y otros <code class="docutils literal notranslate"><span class="pre">30</span></code> centavos de más, <code class="docutils literal notranslate"><span class="pre">(&quot;beer&quot;,</span> <span class="pre">Sum</span> <span class="pre">35)</span></code>. Si utilizamos
<code class="docutils literal notranslate"><span class="pre">applyLog</span></code> para pasar este último valor a <code class="docutils literal notranslate"><span class="pre">addDrink</span></code>, obtenemos otra
cerveza y el resultado final será <code class="docutils literal notranslate"><span class="pre">(&quot;beer&quot;,</span> <span class="pre">Sum</span> <span class="pre">35)</span></code>.</p>
</div>
<div class="section" id="el-tipo-writer">
<h3>El tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code><a class="headerlink" href="#el-tipo-writer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que hemos visto que un valor junto a un monoide puede actuar como un
valor monoidal, vamos a explorar la instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> para esos valores.
El módulo <code class="docutils literal notranslate"><span class="pre">Contol.Monad.Writer</span></code> exporta el tipo <code class="docutils literal notranslate"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">a</span></code> junto su
instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> y algunas funciones útiles para trabajar con valores de
este tipo.</p>
<p>Primero vamos a explorar el tipo en si mismo. Para adjuntar un monoide a un
valor solo tenemos que ponerlos juntos en una dupla. El tipo <code class="docutils literal notranslate"><span class="pre">Writter</span> <span class="pre">w</span> <span class="pre">a</span></code>
es solo un <code class="docutils literal notranslate"><span class="pre">newtype</span></code> de la dupla. Su definición es muy simple:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">{</span> <span class="n">runWriter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Gracias a que esta definido con <code class="docutils literal notranslate"><span class="pre">newtype</span></code> podemos crear una instancia de
<code class="docutils literal notranslate"><span class="pre">Monad</span></code> que se comporte de forma diferente a la instancia de las tuplas
normales. El parámetro de tipo <code class="docutils literal notranslate"><span class="pre">a</span></code> representa el tipo del valor mientras
que el parámetro de tipo <code class="docutils literal notranslate"><span class="pre">w</span></code> representa el valor monádico que adjuntamos al
valor.</p>
<p>Su instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> se define así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mempty</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kt">Writer</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">v&#39;</span><span class="p">))</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">v&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="Cuando vayas al retrete, haz tus necesidades, no hables." class="align-right" src="../_images/angeleyes.png" />
<p>Antes de nada vamos a ver <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>. Su implementación es básicamente la misma
que <code class="docutils literal notranslate"><span class="pre">applyLog</span></code>, solo que ahora la dupla está contenida en el <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
<code class="docutils literal notranslate"><span class="pre">Writer</span></code>, así que tenemos que extraerla con ayuda de un patrón. Tomamos el
valor <code class="docutils literal notranslate"><span class="pre">x</span></code> y le aplicamos la función <code class="docutils literal notranslate"><span class="pre">f</span></code>. Esto nos da un valor del tipo
<code class="docutils literal notranslate"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">a</span></code> que, con ayuda de una expresión <code class="docutils literal notranslate"><span class="pre">let,</span> <span class="pre">lo</span> <span class="pre">ajustamos</span> <span class="pre">a</span> <span class="pre">un</span>
<span class="pre">patrón.</span> <span class="pre">Llamamos</span> <span class="pre">``y</span></code> al nuevo resultado y utilizamos <code class="docutils literal notranslate"><span class="pre">mappend</span></code> para
combinar el monodie antiguo con el nuevo. Juntamos ambos valores en una dupla
, luego dentro del constructor <code class="docutils literal notranslate"><span class="pre">Writer</span></code> y por fin este será el resultado
final.</p>
<p>¿Qué pasa con <code class="docutils literal notranslate"><span class="pre">return</span></code>? Tiene que tomar un valor e introducirlo en el
contexto mínimo por defecto que pueda albergar dicho valor como resultado
¿Cúal será ese contexto para los valores del tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code>? Tiene sentido
que si queremos que el valor del monoide afecte tan poco como sea posible
utilizar <code class="docutils literal notranslate"><span class="pre">mempty</span></code>. Utilizamos <code class="docutils literal notranslate"><span class="pre">mempty</span></code> como identadad para los valores
monoidales, como <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">Sum</span> <span class="pre">0</span></code>, cadenas de bytes vacías, etc. Siempre que
utilicemos <code class="docutils literal notranslate"><span class="pre">mempty</span></code> junto a <code class="docutils literal notranslate"><span class="pre">mappend</span></code> y algún otro valor monoidal, el
resultado será el valor monoidal. Así que si utilizamos <code class="docutils literal notranslate"><span class="pre">return</span></code> para crear
un valor del tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> y luego utilizamos <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> para pasárselo a una
función, el valor monoidal resultante será igual al que devuelva la función.
Vamos a utitlizar <code class="docutils literal notranslate"><span class="pre">return</span></code> con el número <code class="docutils literal notranslate"><span class="pre">3</span></code> unas cuantas veces, pero
cada vez con un monoide distinto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runWriter (return 3 :: Writer String Int)
(3,&quot;&quot;)
ghci&gt; runWriter (return 3 :: Writer (Sum Int) Int)
(3,Sum {getSum = 0})
ghci&gt; runWriter (return 3 :: Writer (Product Int) Int)
(3,Product {getProduct = 1})
</pre></div>
</div>
<p>Como <code class="docutils literal notranslate"><span class="pre">Writer</span></code> no tiene una instancia de <code class="docutils literal notranslate"><span class="pre">Show</span></code>, tenemos que utilizar
<code class="docutils literal notranslate"><span class="pre">runWriter</span></code> para convertir los valores de <code class="docutils literal notranslate"><span class="pre">Writer</span></code> en tuplas normales que
puedan ser mostradas. Para <code class="docutils literal notranslate"><span class="pre">String</span></code>, el valor monoidal es la cadena vacía.
Con <code class="docutils literal notranslate"><span class="pre">Sum</span></code>, es <code class="docutils literal notranslate"><span class="pre">0</span></code> porque si sumamos 0 a algo, el resultado será el mismo.
Para <code class="docutils literal notranslate"><span class="pre">Product</span></code> la identidad es <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>La instancia de <code class="docutils literal notranslate"><span class="pre">Writer</span></code> no posee ninguna implementación de <code class="docutils literal notranslate"><span class="pre">fail</span></code>, así
que si un ajuste de patrones falla dentro de un bloque <code class="docutils literal notranslate"><span class="pre">do</span></code> se llamará a la
función <code class="docutils literal notranslate"><span class="pre">error</span></code>.</p>
</div>
<div class="section" id="utilizando-la-notacion-do-junto-a-writer">
<h3>Utilizando la notación <code class="docutils literal notranslate"><span class="pre">do</span></code> junto a <code class="docutils literal notranslate"><span class="pre">Writer</span></code><a class="headerlink" href="#utilizando-la-notacion-do-junto-a-writer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que tenemos una instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> podemos utilizar la notación
<code class="docutils literal notranslate"><span class="pre">do</span></code> con valores <code class="docutils literal notranslate"><span class="pre">Writer</span></code>. Es útil para cuando tenemos varios valores del
tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> y queremos hacer cosas con ellas. Al igual que la demás
mónadas, podemos tratar estos valores como valores normales dejando que se
ocupen del contexto por nosotros. En este caso, toda los valores monoidales
se unen con <code class="docutils literal notranslate"><span class="pre">mappend</span></code> y por lo tanto se reflejan en el resultado final. Aquí
tiene un ejemplo de uso de la notación <code class="docutils literal notranslate"><span class="pre">do</span></code> con <code class="docutils literal notranslate"><span class="pre">Writer</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">logNumber</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">logNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;Got number: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>

<span class="nf">multWithLog</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">multWithLog</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">3</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">5</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">logNumber</span></code> toma un número y crea un valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code> a partir de él.
Utilizamos una lista de cadenas como monoide de forma que adjuntamos una
lista unitaria que dice que número hemos utilizado. <code class="docutils literal notranslate"><span class="pre">multWithLog</span></code> es un
valor del tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> que multiplica un <code class="docutils literal notranslate"><span class="pre">3</span></code> y un <code class="docutils literal notranslate"><span class="pre">5</span></code> y se asegura que
los registros de ambos números aparezcan en el resultado final. Utilizamos
<code class="docutils literal notranslate"><span class="pre">resultado</span></code> para devolver <code class="docutils literal notranslate"><span class="pre">a*b</span></code> como resultado. Como <code class="docutils literal notranslate"><span class="pre">return</span></code> toma un
valor y lo introduce en el contexto mínimo por defecto, podemos estar seguros
de que no añadirá nada al registro. Esto es lo que vemos si lo ejecutamos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runWriter multWithLog
(15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;])
</pre></div>
</div>
<p>A veces solo queremos que cierto valor monoidal sea incluido llegado el
momento. Para ello tenemos la función <code class="docutils literal notranslate"><span class="pre">tell</span></code> que forma parte de la clase de
tipos <code class="docutils literal notranslate"><span class="pre">MonadWriter</span></code>. Para la instancia de <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, toma un valor
monoidal, como <code class="docutils literal notranslate"><span class="pre">[&quot;This</span> <span class="pre">is</span> <span class="pre">going</span> <span class="pre">on&quot;],</span> <span class="pre">y</span> <span class="pre">crea</span> <span class="pre">un</span> <span class="pre">valor</span> <span class="pre">del</span> <span class="pre">tipo</span> <span class="pre">``Writer</span></code>
con resultado <code class="docutils literal notranslate"><span class="pre">()</span></code> y como valor monoidal adjunto el valor que le hayamos
pasado. Cuando tenemos un resultado como <code class="docutils literal notranslate"><span class="pre">()</span></code> no lo ligamos a ninguna
variable. Aquí tienes como se vería <code class="docutils literal notranslate"><span class="pre">multWithLog</span></code> con un reporte adicional:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">multWithLog</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">multWithLog</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">3</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">5</span>
    <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Gonna multiply these two&quot;</span><span class="p">]</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Es importante que <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(a*b)</span></code> esté en la última línea porque la última
línea de una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> es el resultado final del bloque entero. Si
hubiésemos puesto <code class="docutils literal notranslate"><span class="pre">tell</span></code> en la última línea, <code class="docutils literal notranslate"><span class="pre">()</span></code> hubiera sido el
resultado final de esta expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>. Hubiéramos perdido el resultado de
la multiplicación, además que el tipo de la expresión hubiera sido
<code class="docutils literal notranslate"><span class="pre">multWithLog</span> <span class="pre">::</span> <span class="pre">Writer</span> <span class="pre">()</span> <span class="pre">Int</span></code>. Sin embargo, el registro hubira sido el
mismo. Aquí lo tienes en acción:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runWriter multWithLog
(15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;,&quot;Gonna multiply these two&quot;])
</pre></div>
</div>
</div>
<div class="section" id="anadiendo-registros-a-los-programas">
<h3>Añadiendo registros a los programas<a class="headerlink" href="#anadiendo-registros-a-los-programas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El algoritmo de Euclides es un algoritmo que toma dos números y calcula su
máximo común divisor. Es decir, el número más grande que puede dividir a
ambos. Haskell ya posee la función <code class="docutils literal notranslate"><span class="pre">gcb</span></code>, que hace exactamente esto, pero
vamos a implementarla de nuevo para añadirle un registro. Aquí esta el
algoritmo normal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span>    <span class="ow">=</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>El algoritmo es muy sencillo. Primero, comprueba si el segundo número es 0.
Si lo es, entonces el resultado es el primer número. Si no lo es, entonces el
resultado es el máximo común divisor del segundo número y del resto de dividir
el primer número por el segundo. Por ejemplo, si queremos saber el máximo
común divisor de 8 y 3 simplemente tenemos que seguir el algoritmo. Como 3 no
es 0, tenemos que encontrar el máximo común divisor de de 3 y 2 (si dividimos
8 por 3, el resto es 2). Luego, tenemos que encontrar el máximo común divisor
de 3 y 2. 2 aún no es igual 0, así que tenemos 2 y 1. El segundo número aún
no es 0 así que volvemos a aplicar el algoritmo para obtener 1 y 0, ya que
dividir 2 por 1 nos da como resto 0. Finalmente, como el segundo número es 0,
el resultado final es 1. Vamos a ver si Haskell opina lo mismo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; gcd&#39; 8 3
1
</pre></div>
</div>
<p>Lo hace. Ahora, queremos adjuntar un contexto a este resultado, y el contexto
será un valor monoidal a modo de registro. Como antes, utilizaremos una lista
de cadenas como monoide. De este modo, el tipo de la nueva función <code class="docutils literal notranslate"><span class="pre">gcd'</span></code>
será:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Todo lo que nos queda por hacer es añadir a la función los valores del
registro. Así será el código:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">]</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)]</span>
        <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Esta función toma dos valores <code class="docutils literal notranslate"><span class="pre">Int</span></code> normales y devuelve un
<code class="docutils literal notranslate"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Int</span></code>. Es decir, un <code class="docutils literal notranslate"><span class="pre">Int</span></code> que contiene un contexto de
registro. En caso de que <code class="docutils literal notranslate"><span class="pre">b</span></code> sea <code class="docutils literal notranslate"><span class="pre">0</span></code>, en lugar de únicamente devolver
<code class="docutils literal notranslate"><span class="pre">a</span></code> como resultado, utilizamos una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> para unir un valor del
tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> con el resultado. Primero utilizamos <code class="docutils literal notranslate"><span class="pre">tell</span></code> para indicar
que hemos terminado  luego utilizamos <code class="docutils literal notranslate"><span class="pre">return</span></code> para devolver <code class="docutils literal notranslate"><span class="pre">a</span></code> como
resultado del bloque <code class="docutils literal notranslate"><span class="pre">do</span></code>. En lugar de utilizar esta expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>
podíamos haber utilizado simplemente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Writer</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>Aún así la expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> parece más legible. Luego tenemos el caso en el
que <code class="docutils literal notranslate"><span class="pre">b</span></code> no es igual a <code class="docutils literal notranslate"><span class="pre">0</span></code>. En este caso, indicamos que vamos a utilizar
<code class="docutils literal notranslate"><span class="pre">mod</span></code> para averiguar cual es el resto de dividir <code class="docutils literal notranslate"><span class="pre">a</span></code> por <code class="docutils literal notranslate"><span class="pre">b</span></code>. La
segunda línea del bloque <code class="docutils literal notranslate"><span class="pre">do</span></code> simplemente llama de forma de recursiva a
<code class="docutils literal notranslate"><span class="pre">gcd'</span></code>. Recuerda que <code class="docutils literal notranslate"><span class="pre">gcd'</span></code> al final devuelve un valor del tipo
<code class="docutils literal notranslate"><span class="pre">Writer</span></code>, así que es perfectamente válido que <code class="docutils literal notranslate"><span class="pre">gcd'</span> <span class="pre">b</span> <span class="pre">(a</span> <span class="pre">`mod`</span> <span class="pre">b)</span></code> sea
una línea de la expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>.</p>
<p>Vamos a probar esta nueva versión de <code class="docutils literal notranslate"><span class="pre">gcd'</span></code>. Su resultado es del tipo
<code class="docutils literal notranslate"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Int</span></code> así que debemos extraer la dupla de este <code class="docutils literal notranslate"><span class="pre">newtype</span></code>.
Luego, el primer componente de la dupla será el resultado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">runWriter</span> <span class="p">(</span><span class="n">gcd&#39;</span> <span class="mi">8</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>¡Bien! Ahora, ¿qué pasa cono el registro? Como el registro es una lista de
cadenas, vamos a utilizar <code class="docutils literal notranslate"><span class="pre">mapM_</span> <span class="pre">putStrLn</span></code> par mostrar las cadenas por
pantalla:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd&#39; 8 3)
8 mod 3 = 2
3 mod 2 = 1
2 mod 1 = 0
Finished with 1
</pre></div>
</div>
<p>Es genial como hemos sido capaces de cambiar el algoritmo original a uno que
devuelva lo que está sucediendo simplemente cambiando los valores normales por
valores monádicos y dejando que la implementación de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> para <code class="docutils literal notranslate"><span class="pre">Writer</span></code>
se encargue de los registros por nosotros. Podemos añadir este mecanismo de
registro casi a cualquier función. Solo tenemos que remplazar los valores
normales por valores del tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> y cambiar la aplicación normal de
funciones por <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> (o por expresiones <code class="docutils literal notranslate"><span class="pre">do</span></code> si vemos que es más legible).</p>
</div>
<div class="section" id="construccion-de-listas-ineficiente">
<h3>Construcción de listas ineficiente<a class="headerlink" href="#construccion-de-listas-ineficiente" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando utilizamos la mónada <code class="docutils literal notranslate"><span class="pre">Writer</span></code> hay que tener cuidado con que monoide
utilizar, ya que utilizar listas como monoides puede resultar en una ejecución
muy lenta. Esto se debe al uso de <code class="docutils literal notranslate"><span class="pre">++</span></code> de <code class="docutils literal notranslate"><span class="pre">mappend</span></code>, añadir una lista al
final de otra puede ser muy costoso si una lista es muy larga.</p>
<p>En la función <code class="docutils literal notranslate"><span class="pre">gcd'</span></code>, el registro es rápido porque la lista se acaba
pareciendo a esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">a</span> <span class="o">++</span> <span class="p">(</span><span class="n">b</span> <span class="o">++</span> <span class="p">(</span><span class="n">c</span> <span class="o">++</span> <span class="p">(</span><span class="n">d</span> <span class="o">++</span> <span class="p">(</span><span class="n">e</span> <span class="o">++</span> <span class="n">f</span><span class="p">))))</span>
</pre></div>
</div>
<p>Las listas son estructuras de datos que se construyen de izquierda a derecha,
y esto último es eficiente porque primero construimos la parte izquierda de la
lista y solo después de construirla añadimos una lista más larga a la derecha.
Pero si no tenemos cuidado al utilizar la mónada <code class="docutils literal notranslate"><span class="pre">Writer</span></code> podemos producir
listas que se parezcan a:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">((((</span><span class="n">a</span> <span class="o">++</span> <span class="n">b</span><span class="p">)</span> <span class="o">++</span> <span class="n">c</span><span class="p">)</span> <span class="o">++</span> <span class="n">d</span><span class="p">)</span> <span class="o">++</span> <span class="n">e</span><span class="p">)</span> <span class="o">++</span> <span class="n">f</span>
</pre></div>
</div>
<p>Esta lista se asocia por la izquierda en vez de por la derecha. No es
eficiente porque cada vez que queramos añadir la parte derecha a la parte
izquierda tiene que construir la parte izquierda desde el principio.</p>
<p>La siguiente función funciona igual que <code class="docutils literal notranslate"><span class="pre">gdc'</span></code>, solo que registra las
cadenas al revés. Primero produce el registro del procedimiento y luego añade
el paso actual al final del registro.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcdReverse</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">gcdReverse</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">]</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">gcdReverse</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)]</span>
        <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Primero realiza el paso de recursión y liga el resultado a <code class="docutils literal notranslate"><span class="pre">result</span></code>. Luego,
añade el paso actual al registro, pero el paso actual debe ir al final del
registro que a sido producido por la recursión. Al final, devuelve el
resultado de la recursión como resultado final.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
Finished with 1
2 mod 1 = 0
3 mod 2 = 1
8 mod 3 = 2
</pre></div>
</div>
<p>Es ineficiente porque acaba asociando el uso de <code class="docutils literal notranslate"><span class="pre">++</span></code> por la izquierda en
lugar de por la derecha.</p>
</div>
<div class="section" id="listas-de-diferencia">
<h3>Listas de diferencia<a class="headerlink" href="#listas-de-diferencia" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="Cactus" class="align-left" src="../_images/cactus.png" />
<p>Como la listas a veces son ineficientes cuando se concatenan repetidamente de
esta forma, lo mejor es utilizar un estructura de datos que cuando se
concatene sea siempre eficiente. Una estructura de este tipo es la lista de
diferencia. Una lista de diferencia es similar a una lista, solo que en lugar
de ser una lista normal, es una función que toma un lista y la antepone a
otra lista. La lista de diferencia equivalente a la lista <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code> sería
la función <code class="docutils literal notranslate"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">[1,2,3]</span> <span class="pre">++</span> <span class="pre">xs</span></code>. Un lista vacía normal <code class="docutils literal notranslate"><span class="pre">[]</span></code> equivaldría
a <code class="docutils literal notranslate"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">[]</span> <span class="pre">++</span> <span class="pre">xs</span></code>.</p>
<p>Lo interesante de las listas de diferencia es que soportan la concatenación de
forma eficiente. Cuando añadimos los listas normales con <code class="docutils literal notranslate"><span class="pre">++</span></code>, hay que
recorrer toda la lista de la izquierda hasta el final y luego añadir la otra
ahí. Pero, ¿y si tomamos el enfoque de las listas de diferencia y
representamos las listas como funciones? Bueno, entones añadir dos listas
diferentes sería:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">f</span> <span class="p">`</span><span class="n">append</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Recuerda que <code class="docutils literal notranslate"><span class="pre">f</span></code> y <code class="docutils literal notranslate"><span class="pre">g</span></code> son funciones que toman lista y la anteponen a
otra lista. Así que, por ejemplo, si la función <code class="docutils literal notranslate"><span class="pre">f</span></code> es <code class="docutils literal notranslate"><span class="pre">(&quot;dog&quot;++)</span></code> (que
es otra forma de decir que es <code class="docutils literal notranslate"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">&quot;dog&quot;</span> <span class="pre">++</span> <span class="pre">xs</span></code>) y la función <code class="docutils literal notranslate"><span class="pre">g</span></code> es
<code class="docutils literal notranslate"><span class="pre">(&quot;meat&quot;++)</span></code>, entonces <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">`append`</span> <span class="pre">g</span></code> crea una nueva función que será
equivalente a:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="s">&quot;dog&quot;</span> <span class="o">++</span> <span class="p">(</span><span class="s">&quot;meat&quot;</span> <span class="o">++</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Hemos concatenado dos listas de diferencia creando una nueva función que
primero aplica una lista de diferencia y luego aplica la otra.</p>
<p>Vamos a crear un <code class="docutils literal notranslate"><span class="pre">newtype</span></code> para estas listas de diferencia de forma que
podamos darle fácilmente una instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">DiffList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">{</span> <span class="n">getDiffList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>El tipo que estamos definiendo es <code class="docutils literal notranslate"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code> porque las listas de
diferencia son solo funciones que toma una lista y devuelven otra. Convertir
listas normales en listas de diferencia y viceversa es fácil:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">toDiffList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">DiffList</span> <span class="n">a</span>
<span class="nf">toDiffList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="n">xs</span><span class="o">++</span><span class="p">)</span>

<span class="nf">fromDiffList</span> <span class="ow">::</span> <span class="kt">DiffList</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">fromDiffList</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>Para crear una lista de diferencia a partir de una lista normal solo tenemos
que hacer lo que ya hicimos antes, crear una función que añada una lista a
ella. Como una lista de diferencia es una función que antepone algo a una
lista, si queremos ese algo tenemos que aplicar la función a la lista
vacía.</p>
<p>Aquí esta la instancia de <code class="docutils literal notranslate"><span class="pre">Monoid</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="kt">[]</span> <span class="o">++</span> <span class="n">xs</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">DiffList</span> <span class="n">f</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">xs</span><span class="p">))</span>
</pre></div>
</div>
<p>Fíjate que <code class="docutils literal notranslate"><span class="pre">mempty</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">id</span></code> y <code class="docutils literal notranslate"><span class="pre">mappend</span></code> es en realidad una
composición de funciones. Vamos a ver como funciona:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
[1,2,3,4,1,2,3]
</pre></div>
</div>
<p>Ahora podemos aumentar la eficiencia de la función <code class="docutils literal notranslate"><span class="pre">gcdReverse</span></code> haciendo
que utilice listas de diferencia en lugar de listas normales:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="kt">String</span><span class="p">)</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">])</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)])</span>
        <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Solo tenemos que cambiar el tipo del monoide de <code class="docutils literal notranslate"><span class="pre">[String]</span></code> a <code class="docutils literal notranslate"><span class="pre">DiffList</span>
<span class="pre">String</span></code> y luego cuando utilizamos <code class="docutils literal notranslate"><span class="pre">tell</span></code> convertir las listas normales a
listas de diferencia con <code class="docutils literal notranslate"><span class="pre">toDiffList</span></code>. Vamos a ver si se parecen:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34
Finished with 2
8 mod 2 = 0
34 mod 8 = 2
110 mod 34 = 8
</pre></div>
</div>
<p>Ejecutamos <code class="docutils literal notranslate"><span class="pre">gcdReverse</span> <span class="pre">110</span> <span class="pre">34</span></code>, luego utilizamos <code class="docutils literal notranslate"><span class="pre">runWriter</span></code> para extraer
desde <code class="docutils literal notranslate"><span class="pre">newtype</span></code>, luego aplicamos <code class="docutils literal notranslate"><span class="pre">snd</span></code> para obtener el registro, y para
terminar aplicamos <code class="docutils literal notranslate"><span class="pre">fromDiffList</span></code> para convertir la lista de diferencia en
una lista normal que luego mostramos por pantalla.</p>
</div>
<div class="section" id="comparando-el-rendimiento">
<h3>Comparando el rendimiento<a class="headerlink" href="#comparando-el-rendimiento" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para hacernos una idea de cuanto mejoran el rendimiento las listas de
diferencia, considera esta función que simplemente hace una cuenta atrás hasta
cero, pero produce el registro al revés, al igual que <code class="docutils literal notranslate"><span class="pre">gcdReverse</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finalCountDown</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="kt">String</span><span class="p">)</span> <span class="nb">()</span>
<span class="nf">finalCountDown</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="s">&quot;0&quot;</span><span class="p">])</span>
<span class="nf">finalCountDown</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">finalCountDown</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
<p>Si le pasamos un <code class="docutils literal notranslate"><span class="pre">0</span></code>, lo registra. Para cualquier otro número, primero
cuenta su predecesor y luego añade el número actual al registro. Así que
si aplicamos <code class="docutils literal notranslate"><span class="pre">finalCountDown</span></code> a <code class="docutils literal notranslate"><span class="pre">100</span></code>, la cadena <code class="docutils literal notranslate"><span class="pre">&quot;100&quot;</span></code> será la última
en registrar.</p>
<p>De cualquier modo, si cargamos esta función en <em>GHCi</em>  y la aplicamos a un
número muy grande, como <code class="docutils literal notranslate"><span class="pre">500000</span></code>, veremos que empieza a contar desde <code class="docutils literal notranslate"><span class="pre">0</span></code>
rápidamente.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000
0
1
2
...
</pre></div>
</div>
<p>Sin embargo, si cambiamos la función para que utilice listas normales:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">finalCountDown</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="nb">()</span>
<span class="nf">finalCountDown</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;0&quot;</span><span class="p">]</span>
<span class="nf">finalCountDown</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">finalCountDown</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Y luego le decimos a <em>GHCi</em> que empiece a contar:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn . snd . runWriter $ finalCountDown 500000
</pre></div>
</div>
<p>Veremos que va muy despacio.</p>
<p>Por supuesto, esta no es la forma correcta y científica de probar lo rápidos
que son nuestros programas, pero al menos podemos ver que para este caso,
utilizar listas de diferencia produce resultados de la forma apropiada
mientras que las listas normales tardan una eternidad.</p>
<p>Por cierto, te estará rondando por la cabeza el estribillo de la canción
<em>Final Countdown</em> de <em>Europe</em>, así que, ¡disfrútala!</p>
</div>
</div>
<div class="section" id="reader-o-no-otra-vez-la-misma-broma">
<h2>¿Reader? O no, otra vez la misma broma…<a class="headerlink" href="#reader-o-no-otra-vez-la-misma-broma" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En el capítulo que hablábamos de los
<a class="reference internal" href="funtores.html#cfuntores"><span class="std std-ref">funtores aplicativos</span></a>, vimos que el tipo función,
<code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code> posee una instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. Al mapear una función <code class="docutils literal notranslate"><span class="pre">f</span></code>
sobre una función <code class="docutils literal notranslate"><span class="pre">g</span></code> creamos una función que tomará los mismo parámetros
que <code class="docutils literal notranslate"><span class="pre">g</span></code>, aplicará la función <code class="docutils literal notranslate"><span class="pre">g</span></code> y luego aplicará <code class="docutils literal notranslate"><span class="pre">f</span></code> a su resultado.
Básicamente estamos creando una función igual que <code class="docutils literal notranslate"><span class="pre">g</span></code>, solo que en vez de
devolver su resultado, devuelve el resultado de aplicar <code class="docutils literal notranslate"><span class="pre">f</span></code>. Por ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let f = (*5)
ghci&gt; let g = (+3)
ghci&gt; (fmap f g) 8
55
</pre></div>
</div>
<p>También vimos que las funciones son funtores aplicativos. Nos permiten operar
sobre funciones como si se tratasen de los resultados. Un ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let f = (+) &lt;$&gt; (*2) &lt;*&gt; (+10)
ghci&gt; f 3
19
</pre></div>
</div>
<p>La expresión <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(*2)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(+10)</span></code> crea una función que toma un número,
pasa ese número a <code class="docutils literal notranslate"><span class="pre">(*2)</span></code> y a <code class="docutils literal notranslate"><span class="pre">(+10)</span></code> y luego suma ambos resultados. Por
ejemplo, si aplicamos esta función a <code class="docutils literal notranslate"><span class="pre">3</span></code>, aplica tanto <code class="docutils literal notranslate"><span class="pre">(*2)</span></code> como
<code class="docutils literal notranslate"><span class="pre">(+10)</span></code> a <code class="docutils literal notranslate"><span class="pre">3</span></code>, obteniendo <code class="docutils literal notranslate"><span class="pre">6</span></code> y <code class="docutils literal notranslate"><span class="pre">13</span></code> y luego los suma devolviendo
<code class="docutils literal notranslate"><span class="pre">19</span></code>.</p>
<p>El tipo función <code class="docutils literal notranslate"><span class="pre">(-&gt;)</span> <span class="pre">r</span></code> no es solo un funtor y un funtor aplicativo, sino
también una mónada. De la misma forma que cualquier otro valor monádico que
ya hemos visto, una función puede ser vista como un valor con un contexto. El
contexto en este caso es que el valor aún no esta presente de forma que
tenemos que aplicar esa función a algo antes de obtener el resultado.</p>
<p>Como ya sabemos como funcionan las funciones como funtores y funtores
aplicativos, vamos a ver como luce su instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. Se encuentra en
<code class="docutils literal notranslate"><span class="pre">Control.Monad.Instances</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span>
    <span class="n">h</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">h</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span>
</pre></div>
</div>
<p>Ya vimos como se implementaba <code class="docutils literal notranslate"><span class="pre">pure</span></code> para las funciones y <code class="docutils literal notranslate"><span class="pre">return</span></code> es
básicamente lo mismo. Toma un valor y lo introduce en el contexto mínimo que
siempre tendrá como resultado ese valor. Y la única forma de crear una
función que siempre tenga el mismo resultado es ignorando completamente su
parámetro.</p>
<p>La implementación de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> puede parecer algo compleja, pero en realidad en
muy sencilla. Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> para pasar un valor monádico a una
función, el resultado siempre es un valor monádico. Así que en este caso,
pasamos una función a otra función, y resultado será también una función. Por
este motivo la definición de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> es una función lambda. Todas las
implementaciones de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> que hemos visto hasta ahora siempre asilaban el
resultado del valor monádico de algún modo y luego le aplicaban la función
<code class="docutils literal notranslate"><span class="pre">f</span></code>. Aquí pasa lo mismo. Para obtener el resultado de una función, tenemos
que aplicarla a algo, por este motivo hacemos <code class="docutils literal notranslate"><span class="pre">(h</span> <span class="pre">w)</span></code> aquí, para obtener el
resultado de una función y luego le aplicamos <code class="docutils literal notranslate"><span class="pre">f</span></code>. <code class="docutils literal notranslate"><span class="pre">f</span></code> devuelve un valor
monádico, que es una función en este caso, así que que le aplicamos <code class="docutils literal notranslate"><span class="pre">w</span></code> de
nuevo.</p>
<p>Si no entiendes como funciona <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> en este momento, no te preocupes, con
unos cuantos ejemplos veremos que es una mónada muy simple. Aquí tienes un
ejemplo de como usar una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> con esta mónada:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.Instances</span>

<span class="nf">addStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addStuff</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Es básicamente la misma expresión aplicativa que escribimos antes, solo que
ahora vemos las funciones como mónadas. Una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> siempre resulta
en un valor monádico. En este caso tomamos un número y luego aplicamos
<code class="docutils literal notranslate"><span class="pre">(*2)</span></code> a ese número y el resultado lo ligamos a <code class="docutils literal notranslate"><span class="pre">a</span></code>. <code class="docutils literal notranslate"><span class="pre">(+10)</span></code> se aplica
de nuevo al mismo número y ligamos su resultado a <code class="docutils literal notranslate"><span class="pre">b</span></code>. <code class="docutils literal notranslate"><span class="pre">return</span></code>, como en
todas las demás mónadas, no tiene ningún otro efecto aparte de el de crear un
valor monádico que contendrá algún resultado. En este caso crea una función
que contendrá <code class="docutils literal notranslate"><span class="pre">(a+b)</span></code> como resultado. Si lo probamos veremos que obtenemos
los mismos resultados:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; addStuff 3
19
</pre></div>
</div>
<p>Tanto <code class="docutils literal notranslate"><span class="pre">(*2)</span></code> como <code class="docutils literal notranslate"><span class="pre">(+10)</span></code> se aplican al número <code class="docutils literal notranslate"><span class="pre">3</span></code>. <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(a+b)</span></code>
también se aplica a <code class="docutils literal notranslate"><span class="pre">3</span></code> pero lo ignora y siempre devuelve <code class="docutils literal notranslate"><span class="pre">(a+b)</span></code> como
resultado. Por este motivo, la mónada de las funciones es conocida como la
mónada lectora (<em>reader</em> en inglés, en contraposición de <em>writer</em>, escritora).
Todas las funciones leen de la misma fuente. Podemos ilustrar esto incluso
mejor, podemos reescribir <code class="docutils literal notranslate"><span class="pre">addStuff</span></code> como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">addStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addStuff</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span>
    <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">x</span>
    <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="n">x</span>
    <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<p>Podemos ver como la mónada lectora nos permite tratar a las funciones como
valores en un cierto contexto. Podemos actuar como ya conociéramos lo que van
a devolver. Lo que hacemos es unir todas las funciones en una sola y luego
pasamos el parámetro de esta función a todas las demás. Si tenemos un montón
de funciones a las que les faltan un solo parámetro y al final este parámetro
será igual para todas, podemos utilizar la mónada lectora para extraer sus
futuros resultados y la implementación de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> se encargará de que todo
funcione al final.</p>
</div>
<div class="section" id="monadas-monas-con-estado">
<h2>Mónadas monas con estado<a class="headerlink" href="#monadas-monas-con-estado" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="No juegues con Texas." class="align-left" src="../_images/texas.png" />
<p>Haskell es un lenguaje puro y como tal, los programas consisten en funciones
que no pueden cambiar ningún estado global o variables, solo pueden hacer
algunos cálculos o cómputos y devolver resultados. Esta restricción hace que
sea más fácil razonar acerca de los programas ya que no tenemos que
preocuparnos por el estado de una variable a lo largo del tiempo. Sin embargo,
algunos problemas posee de forma inherentemente estados que cambian con el
tiempo. Aunque estos estos estados no causan ningún problema a Haskell, a
veces pueden ser un poco tediosos de modelar. Por esta razón Haskell posee la
mónada estado, la cual nos permite tratar los problemas con estados como si
fueran un juego de niños y además mantiene todo el código puro.</p>
<p>Cuando estábamos trabajando con <a class="reference internal" href="entradasalida.html#aleatoriedad"><span class="std std-ref">números aleatorios</span></a>,
utilizábamos funciones que tomaban un generador de aleatoriedad como parámetro
y devolvían un número aleatorio y un nuevo generador de aleatoriedad. Si
queríamos generar varios números aleatorios, siempre teníamos que utilizar el
generador de aleatoriedad que devolvió la función anterior. Si queremos crear
una función que tome un generador de aleatoriedad y devuelva el resultado de
lanzar una moneda tres veces, tenemos que hacer esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">threeCoins</span> <span class="ow">::</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nf">threeCoins</span> <span class="n">gen</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="p">(</span><span class="n">secondCoin</span><span class="p">,</span> <span class="n">newGen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen</span>
        <span class="p">(</span><span class="n">thirdCoin</span><span class="p">,</span> <span class="n">newGen&#39;&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen&#39;</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">secondCoin</span><span class="p">,</span> <span class="n">thirdCoin</span><span class="p">)</span>
</pre></div>
</div>
<p>Toma un generador <code class="docutils literal notranslate"><span class="pre">gen</span></code> y luego <code class="docutils literal notranslate"><span class="pre">random</span> <span class="pre">gen</span></code> devuelve un <code class="docutils literal notranslate"><span class="pre">Bool</span></code> junto
con un nuevo generador. Para lanzar la segunda moneda, utilizamos el nuevo
generador, y así sucesivamente. La mayoría de los otros lenguajes no hubieran
devuelto un nuevo generador junto con el número aleatorio. Simplemente
habrían modificado el generador original. Pero Haskell es puro, no podemos
hacer esto, así que tenemos que tomar un estado, crear un resultado a partir
de él y producir un nuevo estado que será utilizado para generar nuevos
resultados.</p>
<p>Si crees que para evitar tratar manualmente con estos estado en Haskell
tenemos que perder la pureza de nuestro código, estás equivocado. Existe una
pequeña mónada, llamada la mónada estado, que se encarga de manejar todo lo
relaciona con estado sin renegar a la pureza.</p>
<p>Así que, para entender mejor todo este concepto de cómputos con estado vamos
a darle un tipo. Antes hemos dicho que un cómputo con estado es una función
que toma un estado y produce un resultado junto a un nuevo estado. Esta
función tendría un tipo como este:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">s</span></code> es el estado y <code class="docutils literal notranslate"><span class="pre">a</span></code> el resultado de estos cómputos con estado.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>En otros lenguajes, la asignación de variables puede verse como un
especie de cómputo con estado. Por ejemplo, si hacemos <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5</span></code> en
un lenguaje imperativo, se asignará el valor <code class="docutils literal notranslate"><span class="pre">5</span></code> a la variable
<code class="docutils literal notranslate"><span class="pre">x</span></code> y la expresión tendrá un resultado igual a <code class="docutils literal notranslate"><span class="pre">5</span></code>. Podemos ver
esta funcionalidad como si la asignación fuera una función que toma
un estado (es decir, todas las variables que han sido asignadas
anteriormente) y devuelve un resultado (en este caso <code class="docutils literal notranslate"><span class="pre">5</span></code>) y nuevo
estado que será el conjunto de todas las variables anteriores más
la nueva asignación.</p>
</div>
<p>Estos cómputos con estado, funciones que toman un estado y devuelven un
resultado junto con un nuevo estado, también se pueden ver como un valor en
cierto contexto. El valor real es es el resultado, mientras que el contexto es
el estado inicial del que hemos extraído el resultado, generando así un nuevo
estado.</p>
<div class="section" id="pilas-y-pilones">
<h3>Pilas y pilones<a class="headerlink" href="#pilas-y-pilones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Digamos que queremos modelar una pila. Tenemos un pila de cosas una encima de
otra y podemos o bien añadir otra cosa encima de la pila o bien tomar una cosa
de la cima de la pila. Cuando ponemos un objeto en la cima de la pila decimos
que estamos apilando un objeto, y cuando tomamos un objeto de la pila decimos
que estamos retirando un objeto. Si queremos el objeto que se encuentra más
abajo de la pila tenemos que retirar antes todos los objetos que se encuentran
por encima de éste.</p>
<p>Utilizaremos una lista para representar la pila, y su cabeza para representar
la cima de la pila. Para hacer las cosas más fáciles, vamos a crear dos
funciones: <code class="docutils literal notranslate"><span class="pre">pop</span></code> y <code class="docutils literal notranslate"><span class="pre">push</span></code>. <code class="docutils literal notranslate"><span class="pre">pop</span></code> tomará una pila y retirará un elemento
que devolverá como resultado, junto a una nueva pila sin dicho elemento en la
cima. <code class="docutils literal notranslate"><span class="pre">push</span></code> tomará un elemento y una pila y luego apilará dicho elemento en
la pila. Devolverá <code class="docutils literal notranslate"><span class="pre">()</span></code> como resultado, junto a una nueva pila.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">Stack</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>

<span class="nf">pop</span> <span class="ow">::</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Stack</span><span class="p">)</span>
<span class="nf">pop</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span>

<span class="nf">push</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="kt">Stack</span><span class="p">)</span>
<span class="nf">push</span> <span class="n">a</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">a</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>A la hora de apilar un elemento devolvemos <code class="docutils literal notranslate"><span class="pre">()</span></code> porque el hecho de apilar un
elemento no tienen ningún resulto importante, su principal objetivo es
modificar la pila. Fíjate que en <code class="docutils literal notranslate"><span class="pre">push</span></code> solo hemos añadido el primer
parámetro, obteniendo así un cómputo con estado. <code class="docutils literal notranslate"><span class="pre">pop</span></code> ya es de por si un
cómputo con estado debido a su tipo.</p>
<p>Vamos a escribir un trocito de código que simule el uso de estas funciones.
Tomaremos una pila, apilaremos un <code class="docutils literal notranslate"><span class="pre">3</span></code> y luego retiraremos dos elementos,
para pasar el rato más que nada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Stack</span><span class="p">)</span>
<span class="nf">stackManip</span> <span class="n">stack</span> <span class="ow">=</span> <span class="kr">let</span>
    <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">newStack1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">push</span> <span class="mi">3</span> <span class="n">stack</span>
    <span class="p">(</span><span class="n">a</span> <span class="p">,</span><span class="n">newStack2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pop</span> <span class="n">newStack1</span>
    <span class="kr">in</span> <span class="n">pop</span> <span class="n">newStack2</span>
</pre></div>
</div>
<p>Tomamos una pila (<code class="docutils literal notranslate"><span class="pre">stack</span></code>) y luego hacemos <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">3</span> <span class="pre">stack</span></code>, lo que nos
devuelve una tupla. La primera parte de la tupla es <code class="docutils literal notranslate"><span class="pre">()</span></code> y la segunda es
una nueva pila que llamaremos <code class="docutils literal notranslate"><span class="pre">newStack1</span></code>. Luego, retiramos un número de
<code class="docutils literal notranslate"><span class="pre">newStack1</span></code>, lo cual devuelve ese número <code class="docutils literal notranslate"><span class="pre">a</span></code> (que es <code class="docutils literal notranslate"><span class="pre">3</span></code>) y una nueva
pila que llamaremos <code class="docutils literal notranslate"><span class="pre">newStack2</span></code>. Luego retiramos otro elemento de
<code class="docutils literal notranslate"><span class="pre">newStack2</span></code> y obtenemos un número <code class="docutils literal notranslate"><span class="pre">b</span></code> y una pila <code class="docutils literal notranslate"><span class="pre">newStack3</span></code>. Devolvemos
una dupla que contendrá ese número y esa tupla. Vamos a probarlo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; stackManip [5,8,2,1]
(5,[8,2,1])
</pre></div>
</div>
<p>Genial, el resultado es <code class="docutils literal notranslate"><span class="pre">5</span></code> y la pila es <code class="docutils literal notranslate"><span class="pre">[8,2,1]</span></code>. El mismo
<code class="docutils literal notranslate"><span class="pre">stackManip</span></code> es un cómputo con estado. Hemos tomado un puñado de cómputos
con estado y de alguna forma los hemos unido todos. Mmm… Me recuerda a algo.</p>
<p>El código que acabamos de ver es algo tedioso ya que tenemos que pasar el
estado manualmente en cada cómputo, además de que tenemos que ligarlo a una
variable para luego pasarlo al siguiente cómputo ¿No sería mejor si, en lugar
de pasar una pila manualmente a cada función, pudiéramos escribir algo como
esto?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>Bueno, pues usando la mónada estado podemos hacerlo. Gracias a ella podemos
tomar cómputos con estado como estos y usarlos sin tener que preocuparnos por
manejar el estado de forma manual.</p>
</div>
<div class="section" id="la-monada-estado">
<h3>La mónada estado<a class="headerlink" href="#la-monada-estado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El módulo <code class="docutils literal notranslate"><span class="pre">Control.Monad.State</span></code> contiene un <code class="docutils literal notranslate"><span class="pre">newtype</span></code> para los cómputos
con estado. Aquí tienes su definición:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">{</span> <span class="n">runState</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Un <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">s</span> <span class="pre">a</span></code> es un cómputo con estado que manipula el estado del tipo
<code class="docutils literal notranslate"><span class="pre">s</span></code> y tiene como resultado el tipo <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>Ahora que ya hemos visto como funcionan los cómputos con estado y que incluso
podemos verlos como valores en cierto contexto, vamos a comprobar su
instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">State</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newState</span><span class="p">)</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">s</span>
                                        <span class="p">(</span><span class="kt">State</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
                                    <span class="kr">in</span>  <span class="n">g</span> <span class="n">newState</span>
</pre></div>
</div>
<p>Vamos a echar un vistazo primero a <code class="docutils literal notranslate"><span class="pre">return</span></code>. Nuestro objetivo con <code class="docutils literal notranslate"><span class="pre">return</span></code>
es tomar un valor y crear un cómputo con estado que siempre contenga ese
valor como resultado. Por este motivo creamos una función lamba
<code class="docutils literal notranslate"><span class="pre">\s</span> <span class="pre">-&gt;</span> <span class="pre">(s,a)</span></code>. Siempre devolvemos <code class="docutils literal notranslate"><span class="pre">x</span></code> como resultado del cómputo con
estado y además el estado se mantiene constante, ya que <code class="docutils literal notranslate"><span class="pre">return</span></code> debe
insertar un valor en el contexto mínimo. Recapitulando, <code class="docutils literal notranslate"><span class="pre">return</span></code> tomará un
valor y creará un cómputo con estado que revolverá ese valor como resultado
y mantendrá el estado intacto.</p>
<img alt="Soy un agente de la ley." class="align-right" src="../_images/badge.png" />
<p>¿Y <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>? Bueno, el resultado de pasar un cómputo con estado a una función
con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> es un cómputo con estado ¿no? Así que empezamos construyendo el
<code class="docutils literal notranslate"><span class="pre">newtype</span></code> <code class="docutils literal notranslate"><span class="pre">State</span></code> y luego utilizamos una función lambda. La función lambda
será el cómputo con estado. Pero, ¿qué es lo que hace? Bueno, de alguna forma
debemos extraer el resultado del primer cómputo con estado. Como nos
encontramos dentro de un cómputo con estado, podemos pasarle el estado actual
<code class="docutils literal notranslate"><span class="pre">s</span></code> a <code class="docutils literal notranslate"><span class="pre">h</span></code>, lo cual devolverá un dupla con el resultado y un nuevo estado
<code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">newState)</span></code>. Siempre que hemos implementado <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, una vez extraído el
resultado de un valor monádico aplicábamos la función <code class="docutils literal notranslate"><span class="pre">f</span></code> sobre éste para
obtener un nuevo valor monádico. Por ejemplo, con <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, luego de obtener
el nuevo valor monádico, aún teníamos que asegurarnos de tratar el nuevo
contexto aplicando <code class="docutils literal notranslate"><span class="pre">mappend</span></code> entre el valor monoidal antiguo y el nuevo.
Aquí, realizamos <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> para obtener un nuevo cómputo con estado <code class="docutils literal notranslate"><span class="pre">g</span></code>. Ahora
que ya tenemos un nuevo cómputo con estado y nuevo estado (con el nombre de
<code class="docutils literal notranslate"><span class="pre">newState</span></code>) solo tenemos que aplicar <code class="docutils literal notranslate"><span class="pre">g</span></code> sobre <code class="docutils literal notranslate"><span class="pre">newState</span></code>. El resultado
será una tupla, y al mismo tiempo, el resultado final.</p>
<p>Así que <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> básicamente se encarga de unir dos cómputos con estado, solo
que el segundo está oculto dentro de una función que se encarga de obtener el
resultado anterior. Como <code class="docutils literal notranslate"><span class="pre">pop</span></code> y <code class="docutils literal notranslate"><span class="pre">push</span></code> son ya cómputos con estado, es
muy fácil introducirlos dentro de <code class="docutils literal notranslate"><span class="pre">State</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">pop</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">pop</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span>

<span class="nf">push</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">push</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">a</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pop</span></code> ya es en si mismo un cómputo con estado y <code class="docutils literal notranslate"><span class="pre">push</span></code> es una función que
toma un <code class="docutils literal notranslate"><span class="pre">Int</span></code> y devuelve un cómputo con estado. Ahora podemos reescribir el
ejemplo anterior que apilaba un <code class="docutils literal notranslate"><span class="pre">3</span></code> y luego retiraba  dos números así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>¿Ves como hemos unido un <code class="docutils literal notranslate"><span class="pre">push</span></code> y dos <code class="docutils literal notranslate"><span class="pre">pop</span></code> juntos en un solo cómputo con
estado? Cuando extraemos el contenido del <code class="docutils literal notranslate"><span class="pre">newtype</span></code> obtenemos una función
a la que tenemos que pasarle el estado inicial:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runState stackManip [5,8,2,1]
(5,[8,2,1])
</pre></div>
</div>
<p>De hecho no tenemos porque ligar el segundo <code class="docutils literal notranslate"><span class="pre">pop</span></code> a <code class="docutils literal notranslate"><span class="pre">a</span></code> ya que no
utilizamos <code class="docutils literal notranslate"><span class="pre">a</span></code> luego. Así que podemos reescribirlo de nuevo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>Perfecto. Ahora queremos hacer esto: retiramos un número de la pila y si dicho
número es <code class="docutils literal notranslate"><span class="pre">5</span></code> lo devolvemos a la pila, si no, apilamos un <code class="docutils literal notranslate"><span class="pre">3</span></code> y un <code class="docutils literal notranslate"><span class="pre">8</span></code>.
Así sería el código:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stackStuff</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">stackStuff</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">5</span>
        <span class="kr">then</span> <span class="n">push</span> <span class="n">a</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="n">push</span> <span class="mi">3</span>
            <span class="n">push</span> <span class="mi">8</span>
</pre></div>
</div>
<p>Bastante sencillo. Vamos a ejecutarlo junto a un estado inicial.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runState stackStuff [9,0,2,1,0]
((),[8,3,0,2,1,0])
</pre></div>
</div>
<p>Recuerda que las expresiones <code class="docutils literal notranslate"><span class="pre">do</span></code> devuelve valores monádicos y en el caso
de la mónada <code class="docutils literal notranslate"><span class="pre">State</span></code>, cada expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> es también una función con
estado. Como tanto <code class="docutils literal notranslate"><span class="pre">stackStuff</span></code> y <code class="docutils literal notranslate"><span class="pre">stackManip</span></code> son cómputos con estado
normales y corrientes, podemos unirlos y producir un nuevo cómputo con estado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">moreStack</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">moreStack</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">stackManip</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">100</span>
        <span class="kr">then</span> <span class="n">stackStuff</span>
        <span class="kr">else</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Si el resultado de <code class="docutils literal notranslate"><span class="pre">stackManip</span></code> sobre la pila actual es <code class="docutils literal notranslate"><span class="pre">100</span></code>, ejecutamos
<code class="docutils literal notranslate"><span class="pre">stackStuff</span></code>, si no no hacemos nada. <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">()</span></code> simplemente mantiene el
estado.</p>
<p>El módulo <code class="docutils literal notranslate"><span class="pre">Control.Monad.State</span></code> contiene una clase de tipos llamada
<code class="docutils literal notranslate"><span class="pre">MonadState</span></code> y ésta a su vez contiene dos útiles funciones: <code class="docutils literal notranslate"><span class="pre">get</span></code> y
<code class="docutils literal notranslate"><span class="pre">put</span></code>. Para <code class="docutils literal notranslate"><span class="pre">State</span></code>, <code class="docutils literal notranslate"><span class="pre">get</span></code> se implementa así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">get</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Es decir, toma el estado actual y lo devuelve como resultado. La función
<code class="docutils literal notranslate"><span class="pre">put</span></code> toma un estado y crea una función con estado que remplazará el estado
actual por su parámetro:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">put</span> <span class="n">newState</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">newState</span><span class="p">)</span>
</pre></div>
</div>
<p>Gracias a estas funciones, podemos ver que el contenido de la pila actual o
incluso remplazar toda la pila por una nueva.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">stackyStack</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">stackyStack</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">stackNow</span> <span class="ow">&lt;-</span> <span class="n">get</span>
    <span class="kr">if</span> <span class="n">stackNow</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
        <span class="kr">then</span> <span class="n">put</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="kr">else</span> <span class="n">put</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Es bueno ver como quedaría el tipo de <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> si solo funcionará con valores
del tipo <code class="docutils literal notranslate"><span class="pre">State</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span>
</pre></div>
</div>
<p>Fíjate en que el tipo del estado <code class="docutils literal notranslate"><span class="pre">s</span></code> se mantiene constante pero sin embargo
el tipo del resultado puede cambiar de <code class="docutils literal notranslate"><span class="pre">a</span></code> a <code class="docutils literal notranslate"><span class="pre">b</span></code>. Esto significa que
podemos unir varios cómputos con estado cuyos resultados sean de diferentes
tipos pero el tipo de sus estados sea el mismo. Y, ¿por qué? Bueno, por
ejemplo, para <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> tiene este tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<p>Tiene sentido que la mónada en si misma, <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, no cambie. No tendría
sentido que pudiéramos usar <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> con dos mónadas distintas. Bueno, en el
caso de la mónada estado, en realidad la mónada es <code class="docutils literal notranslate"><span class="pre">State</span> <span class="pre">s</span></code>, así que si
<code class="docutils literal notranslate"><span class="pre">s</span></code> fuera distinta, estaríamos utilizando <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> entre dos mónadas
distintas.</p>
</div>
<div class="section" id="aleatoriedad-y-la-monada-estado">
<h3>Aleatoriedad y la mónada estado<a class="headerlink" href="#aleatoriedad-y-la-monada-estado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Al principio de esta sección vimos que como se generaban número aleatorios y
que a veces puede ser algo pesado ya que cada función aleatoria toma un
generador y devuelve un número aleatorio junto un nuevo generador, que
tendremos que utilizar en lugar del viejo para generar otro número diferente.
La mónada estado hace que trabajar con todo esto sea mucho más cómodo.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">random</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">System.Random</span></code> tiene este tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">random</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>Es decir, toma un generador de aleatoriedad y produce un número aleatorio
junto un nuevo generador. Podemos ver que en realidad se trata de un cómputo
con estado, así que podemos introducirlo en el constructor <code class="docutils literal notranslate"><span class="pre">newtype</span></code>
<code class="docutils literal notranslate"><span class="pre">State</span></code> y luego utilizarlo como un valor monádico de forma que no nos
tengamos que preocupar por manejar el estado:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">randomSt</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">State</span> <span class="n">g</span> <span class="n">a</span>
<span class="nf">randomSt</span> <span class="ow">=</span> <span class="kt">State</span> <span class="n">random</span>
</pre></div>
</div>
<p>Así que si ahora queremos lanzar tres monedas (<code class="docutils literal notranslate"><span class="pre">True</span></code> cruz, <code class="docutils literal notranslate"><span class="pre">False</span></code> cara)
solo tenemos que hacer lo siguiente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">threeCoins</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">StdGen</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Bool</span><span class="p">)</span>
<span class="nf">threeCoins</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>Ahora <code class="docutils literal notranslate"><span class="pre">threeCoins</span></code> es un cómputo con estado y luego de tomar un generador de
aleatoriedad inicial, lo pasa al primer <code class="docutils literal notranslate"><span class="pre">randomSt</span></code>, el cual producirá un
número aleatorio y un nuevo generador, el cual será pasado al siguiente y así
sucesivamente. Utilizamos <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(a,b,c)</span></code> para devolver <code class="docutils literal notranslate"><span class="pre">(a,b,c)</span></code> como
resultado manteniendo constante el generador más reciente.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runState threeCoins (mkStdGen 33)
((True,False,True),680029187 2103410263)
</pre></div>
</div>
<p>Ahora realizar todo este tipo de tareas que requieren el uso de algún tipo de
estado es mucho más cómodo.</p>
</div>
</div>
<div class="section" id="errores-errores-errores">
<h2>Errores, errores, errores…<a class="headerlink" href="#errores-errores-errores" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sabemos que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> se utiliza para dar el contexto de un posible fallo a
los valores. Un valor puede ser <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code> o <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Sin embargo,
cuando tenemos un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, puede resultar útil dar alguna información del
error que ha ocurrido, lo cual no podemos hacer con <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Por otra parte, el tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></code> nos permite incorporar el contexto de
un posible fallo al mismo tiempo que nos permite dar información acerca del
posible fallo, de forma que podemos describir que ha ido mal o dar alguna
información acerca del fallo. Un valor del tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></code> puede ser un
valor <code class="docutils literal notranslate"><span class="pre">Right</span></code>, lo cual representa un respuesta correcta, o un valor
<code class="docutils literal notranslate"><span class="pre">Left</span></code>, que representa un fallo. Por ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t Right 4
Right 4 :: (Num t) =&gt; Either a t
ghci&gt; :t Left &quot;out of cheese error&quot;
Left &quot;out of cheese error&quot; :: Either [Char] b
</pre></div>
</div>
<p>Básicamente es como un <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> mejorado, así que tiene sentido que sea una
mónada. También puede ser visto como un valor con el contexto de un posible
fallo, solo que ahora existe un valor añadido cuando ocurre un error.</p>
<p>Su instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> es parecida a la de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y se encuentra en
<code class="docutils literal notranslate"><span class="pre">Control.Monad.Error</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">x</span>
    <span class="kt">Right</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
    <span class="kt">Left</span> <span class="n">err</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
    <span class="n">fail</span> <span class="n">msg</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">strMsg</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">return</span></code>, como siempre, toma un valor y lo introduce en el contexto mínimo
por defecto. Introduce un valor en el constructor <code class="docutils literal notranslate"><span class="pre">Right</span></code> ya que utilizamos
<code class="docutils literal notranslate"><span class="pre">Right</span></code> para representar un cómputo con éxito donde existe un resultado. Se
parece mucho al <code class="docutils literal notranslate"><span class="pre">return</span></code> de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> examina dos posibles casos: un <code class="docutils literal notranslate"><span class="pre">Left</span></code> y un <code class="docutils literal notranslate"><span class="pre">Right</span></code>. En
caso de <code class="docutils literal notranslate"><span class="pre">Right</span></code>, la función <code class="docutils literal notranslate"><span class="pre">f</span></code> se aplica sobre el valor interior, de
forma similar a lo que sucedía con <code class="docutils literal notranslate"><span class="pre">Just</span></code>. En caso de que ocurra un error,
se mantiene constante el valor de <code class="docutils literal notranslate"><span class="pre">Left</span></code>, el cual da información acerca del
error.</p>
<p>La instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> para <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">e</span></code> tiene un requerimiento adicional,
y este es que el tipo del valor que está contenido en <code class="docutils literal notranslate"><span class="pre">Left</span></code>, el parámetro
de tipo <code class="docutils literal notranslate"><span class="pre">e</span></code> en este caso, tiene que formar parte de la clase de tipos
<code class="docutils literal notranslate"><span class="pre">Error</span></code>. La clase de tipos <code class="docutils literal notranslate"><span class="pre">Error</span></code> es para los tipos cuyos valores pueden
actuar como mensajes de error. Define la función <code class="docutils literal notranslate"><span class="pre">strMsg</span></code>, que toma un error
en forma de cadena y devuelve ese valor en forma de error. Un buen ejemplo de
instancia de <code class="docutils literal notranslate"><span class="pre">Error</span></code> es el tipo <code class="docutils literal notranslate"><span class="pre">String</span></code>. Para el caso de <code class="docutils literal notranslate"><span class="pre">String</span></code>, la
función <code class="docutils literal notranslate"><span class="pre">strMsg</span></code> simplemente devuelve la cadena que se le pasa:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; :t strMsg
strMsg :: (Error a) =&gt; String -&gt; a
ghci&gt; strMsg &quot;boom!&quot; :: String
&quot;boom!&quot;
</pre></div>
</div>
<p>Como normalmente utilizamos <code class="docutils literal notranslate"><span class="pre">String</span></code> para describir los errores no tenemos
que preocuparnos mucho por esto. Cuando un ajuste de patrones falla dentro de
una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>, se devuelve valor <code class="docutils literal notranslate"><span class="pre">Left</span></code> para representar este error.</p>
<p>De cualquier modo, aquí tienes unos cuantos ejemplos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Left &quot;boom&quot; &gt;&gt;= \x -&gt; return (x+1)
Left &quot;boom&quot;
ghci&gt; Right 100 &gt;&gt;= \x -&gt; Left &quot;no way!&quot;
Left &quot;no way!&quot;
</pre></div>
</div>
<p>Cuando utilizamos <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> para pasar un valor <code class="docutils literal notranslate"><span class="pre">Left</span></code> a una función, la
función se ignora y se devuelve un <code class="docutils literal notranslate"><span class="pre">Left</span></code> idéntico. Cuando pasamos un valor
<code class="docutils literal notranslate"><span class="pre">Right</span></code> a una función, la función se aplica al contenido de éste, pero en
este caso la función devuelve un valor <code class="docutils literal notranslate"><span class="pre">Left</span></code> de todas formas.</p>
<p>Si intentamos pasar una valor <code class="docutils literal notranslate"><span class="pre">Right``a</span> <span class="pre">una</span> <span class="pre">función</span> <span class="pre">que</span> <span class="pre">también</span> <span class="pre">devuelve</span> <span class="pre">un</span>
<span class="pre">valor</span> <span class="pre">``Right</span></code> en <em>GHCi</em>, nos encontraremos con un error peculiar.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100)

&lt;interactive&gt;:1:0:
    Ambiguous type variable `a&#39; in the constraints:
      `Error a&#39; arising from a use of `it&#39; at &lt;interactive&gt;:1:0-33
      `Show a&#39; arising from a use of `print&#39; at &lt;interactive&gt;:1:0-33
    Probable fix: add a type signature that fixes these type variable(s)
</pre></div>
</div>
<p>Haskell dice que no sabe que tipo elegir para la parte <code class="docutils literal notranslate"><span class="pre">e</span></code> del tipo
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></code>, incluso aunque solo mostremos la parte <code class="docutils literal notranslate"><span class="pre">Right</span></code>. Esto se debe
a la restricción <code class="docutils literal notranslate"><span class="pre">Error</span> <span class="pre">e</span></code> de la instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. Así que si no
quieres ver más errores de este tipo cuando trabajes con la mónada <code class="docutils literal notranslate"><span class="pre">Either</span></code>,
añade un anotación de tipo explícita:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100) :: Either String Int
Right 103
</pre></div>
</div>
<p>¡Bien! Ahora funciona.</p>
<p>Aparte de este pequeño detalle, esta mónada es muy similar a la mónada
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. En el capítulo anterior, utilizamos varios aspectos monádicos de
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> para simular el aterrizaje de las aves en la barra de equilibrio de
nuestro buen amigo Pierre. A modo de ejercicio, puedes reescribir estas
funciones con la mónada error de forma que cuando el funambulista se caiga,
podamos informar del número de pájaros que había en la barra cuando se cayó.</p>
</div>
<div class="section" id="algunas-funciones-monadicas-utiles">
<h2>Algunas funciones monádicas útiles<a class="headerlink" href="#algunas-funciones-monadicas-utiles" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En esta sección vamos a ver una cuantas funciones que pueden operar con
valores monádicos o devolver valores monádicos como resultado (¡o ambas
cosas!). Normalmente no referimos a estas funciones como funciones monádicas.
Mientras que algunas de éstas nos serán totalmente desconocidas, otras son las
versiones monádicas de algunas funciones que ya conocemos, como <code class="docutils literal notranslate"><span class="pre">filter</span></code> o
<code class="docutils literal notranslate"><span class="pre">foldl</span></code>.</p>
<div class="section" id="liftm-y-sus-amigos">
<h3><code class="docutils literal notranslate"><span class="pre">liftM</span></code> y sus amigos<a class="headerlink" href="#liftm-y-sus-amigos" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="¡Yo también soy un agente de la ley!" class="align-right" src="../_images/wolf.png" />
<p>Cuando empezamos nuestro viaje hacia la cima de las mónadas, primero vimos los
funtores, que son cosas que se pueden mapear. Luego vimos que podíamos mejorar
los funtores en algo que llamamos funtores aplicativos, que permitían aplicar
funciones normales entre valores aplicativos a la vez que permitían tomar
funciones e introducirlas en el contexto por defecto. Para terminar, vimos que
podíamos mejorar los funtores aplicativos y eso nos llevaba a las mónadas, que
añadían la habilidad de poder pasas esos valores con un cierto contexto a
funciones normales.</p>
<p>Resumiendo, todas las mónadas son funtores aplicativos y todos los funtores
aplicativos son funtores normales. La clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> posee una
restricción de clase que dice que su tipo debe poseer una instancia de la
clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code> antes de que se puede crear un instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.
Aunque la clase <code class="docutils literal notranslate"><span class="pre">Monad</span></code> debería tener la misma restricción con
<code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, ya que todas las mónadas son también funtores aplicativos, no
la tiene. Esto se debe a que la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monad</span></code> se introdujo en
Haskell antes que <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>.</p>
<p>Incluso aunque toda mónada es también un funtor, no tenemos que depender de
la instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code> gracias a la existencia de la función <code class="docutils literal notranslate"><span class="pre">liftM</span></code>.
<code class="docutils literal notranslate"><span class="pre">liftM</span></code> toma una función y un valor monádico y mapea la función sobre el
valor monádico. Vamos, ¡igual que <code class="docutils literal notranslate"><span class="pre">fmap</span></code>! Esta es su declaración de tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>Y esta es la de <code class="docutils literal notranslate"><span class="pre">map</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Si tanto la instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code> como la instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> obedecen
las leyes de los funtores y de las mónadas, estas dos funciones hacen lo mismo
(todas las mónadas que hemos visto cumplen ambas). Es lo mismo que pasaba con
<code class="docutils literal notranslate"><span class="pre">pure</span></code> y <code class="docutils literal notranslate"><span class="pre">return</span></code>, solo que una tiene la restricción de clase
<code class="docutils literal notranslate"><span class="pre">Applicative</span></code> y otra la de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. Vamos a probar <code class="docutils literal notranslate"><span class="pre">liftM</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; liftM (*3) (Just 8)
Just 24
ghci&gt; fmap (*3) (Just 8)
Just 24
ghci&gt; runWriter $ liftM not $ Writer (True, &quot;chickpeas&quot;)
(False,&quot;chickpeas&quot;)
ghci&gt; runWriter $ fmap not $ Writer (True, &quot;chickpeas&quot;)
(False,&quot;chickpeas&quot;)
ghci&gt; runState (liftM (+100) pop) [1,2,3,4]
(101,[2,3,4])
ghci&gt; runState (fmap (+100) pop) [1,2,3,4]
(101,[2,3,4])
</pre></div>
</div>
<p>Ya conocemos bastante bien como funciona <code class="docutils literal notranslate"><span class="pre">fmap</span></code> con los valores el tipo
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. <code class="docutils literal notranslate"><span class="pre">liftM</span></code> hace lo mismo. Para los valores del tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, la
función se mapea sobre el primer componente de la dupla, que es el resultado.
Hacer <code class="docutils literal notranslate"><span class="pre">fmap</span></code> o <code class="docutils literal notranslate"><span class="pre">liftM</span></code> sobre un cómputo con estado devuelve un nuevo
cómputo con estado, solo que su resultado final se vera modificado por la
función. Si no hubiésemos mapeado <code class="docutils literal notranslate"><span class="pre">(+100)</span></code> sobre <code class="docutils literal notranslate"><span class="pre">pop</span></code>, el resulto
hubiese sido <code class="docutils literal notranslate"><span class="pre">(1,[2,3,4])</span></code>.</p>
<p>Esta es la implementación de <code class="docutils literal notranslate"><span class="pre">liftM</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">liftM</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>O con notación <code class="docutils literal notranslate"><span class="pre">do</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">liftM</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Pasamos el valor monádico <code class="docutils literal notranslate"><span class="pre">m</span></code> a la función y luego aplicamos la función
<code class="docutils literal notranslate"><span class="pre">f</span></code> a su resultado, introduciendo el resultado de ésta en el contexto por
defecto. Gracias a las leyes de las mónadas, tenemos garantizado que el
contexto se mantendrá constante, solo se modificará el resultado del valor
monádico. Podemos ver que <code class="docutils literal notranslate"><span class="pre">liftM</span></code> está implementado sin hacer referencia a
<code class="docutils literal notranslate"><span class="pre">Functor</span></code>. Esto significa que podemos implementar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> (o <code class="docutils literal notranslate"><span class="pre">liftM</span></code>,
depende de ti) utilizando únicamente lo que nos ofrecen las mónadas. Por este
motivo, podemos concluir que las mónadas son más potentes que los funtores
normales.</p>
<p>La clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> nos permite aplicar funciones entre valores
con un contexto como si se trataran de funciones normales.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 5
Just 8
ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing
Nothing
</pre></div>
</div>
<p>Utilizar el estilo aplicativo hace las cosas muy fáciles. <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> es <code class="docutils literal notranslate"><span class="pre">fmap</span></code>
y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es una función de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> que tiene el
siguiente tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Es parecida a <code class="docutils literal notranslate"><span class="pre">fmap</span></code>, solo que la función en si misma posee un contexto.
Tenemos que extraer de alguna forma el resultado de <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">a</span></code> para poder mapear
la función sobre ella y luego volver a introducir el resultado en un contexto.
Como todas las funciones de Haskell están currificadas por defecto, podemos
utilizar la combinación de <code class="docutils literal notranslate"><span class="pre">&lt;$&gt;</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> para aplicar una función sobre
varios parámetros.</p>
<p>De cualquier forma, resulta que al igual que <code class="docutils literal notranslate"><span class="pre">fmap</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> también puede
ser implementado utilizando lo que nos ofrece la clase de tipos <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. La
función <code class="docutils literal notranslate"><span class="pre">ap</span></code> es básicamente <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code>, solo que posee un restricción de clase
<code class="docutils literal notranslate"><span class="pre">Monad</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>. Aquí tienes la definición:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ap</span> <span class="n">mf</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">mf</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">mf</span></code> es un valor monádico cuyo resultado es una función. Como tanto la
función como el valor están dentro de un contexto, extraemos la función del
contexto y la llamamos <code class="docutils literal notranslate"><span class="pre">f</span></code>. Luego extraemos el valor y lo llamamos <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Para terminar aplicamos la función sobre el valor y devolvemos el resultado.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; Just (+3) &lt;*&gt; Just 4
Just 7
ghci&gt; Just (+3) `ap` Just 4
Just 7
ghci&gt; [(+1),(+2),(+3)] &lt;*&gt; [10,11]
[11,12,12,13,13,14]
ghci&gt; [(+1),(+2),(+3)] `ap` [10,11]
[11,12,12,13,13,14]
</pre></div>
</div>
<p>Ahora podemos ver que las mónadas son también más potentes que los funtores
aplicativos, porque podemos utilizar las funciones de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> para
implementar las de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>. De hecho, a menudo la gente cuando sabe
que un tipo es un mónada, primero implementa la instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> y luego
crea la instancia de <code class="docutils literal notranslate"><span class="pre">Applicative</span></code> simplemente diciendo que <code class="docutils literal notranslate"><span class="pre">pure</span></code> es
<code class="docutils literal notranslate"><span class="pre">return</span></code> y <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> es <code class="docutils literal notranslate"><span class="pre">ap</span></code>. De forma similar, si sabemos que algo tiene
una instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>, podemos crear la instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>
simplemente estableciendo que <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">liftM</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">liftA2</span></code> es una función de conveniencia para aplicar una función
entre dos valores aplicativos. Su definición es así de sencilla:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="nf">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">liftM2</span></code> hace exactamente lo mismo, solo que posee una
restricción de clase <code class="docutils literal notranslate"><span class="pre">Monad</span></code>. También existe <code class="docutils literal notranslate"><span class="pre">liftM3</span></code>, <code class="docutils literal notranslate"><span class="pre">liftM4</span></code> y
<code class="docutils literal notranslate"><span class="pre">liftM5</span></code>.</p>
<p>Hemos visto como las mónadas son más potentes que los funtores aplicativos y
que los funtores normales y aunque todas las mónadas son también funtores
y funtores aplicativos, no necesariamente poseen una instancia de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>
y <code class="docutils literal notranslate"><span class="pre">Applicative</span></code>, y esta es la  razón por la que acabamos de ver las
funciones equivalentes entre los funtores y las mónadas.</p>
</div>
<div class="section" id="la-funcion-join">
<h3>La función <code class="docutils literal notranslate"><span class="pre">join</span></code><a class="headerlink" href="#la-funcion-join" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Piensa en esto: si el resultado de un valor monádico es otro valor monádico,
es decir, si un valor monádico es anidado dentro de otro, ¿Podemos convertir
ambos en un único valor monádico? Por ejemplo, si tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">9)</span></code>,
¿Podemos convertirlo en <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">9</span></code>? Pues resulta que convertir valores
monádicos anidados en valores monádicos simples es una de las propiedades
únicas de las mónadas. Por este motivo tiene su razón de ser la función
<code class="docutils literal notranslate"><span class="pre">join</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">join</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Toma una un valor monádico que contiene otro valor monádico y devuelve un solo
valor monádico. Aquí tienes un ejemplo de su uso con valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; join (Just (Just 9))
Just 9
ghci&gt; join (Just Nothing)
Nothing
ghci&gt; join Nothing
Nothing
</pre></div>
</div>
<p>La primera línea tiene un cómputo correcto como resultado de otro cómputo
correcto, así que ambos son unido en un solo cómputo correcto. La segunda
línea posee un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> como resultado de un valor <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Antes, cuando
trabajamos con valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> queríamos combinar varios valores en uno, ya
sea con <code class="docutils literal notranslate"><span class="pre">&lt;*&gt;</span></code> o con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, todos tenían que ser valores <code class="docutils literal notranslate"><span class="pre">Just</span></code> para que
el resultado fuese también un valor <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Si existe un fallo en algún
punto del camino, el resultado final será un fallo y lo mismo ocurre aquí. En
la tercera línea, vemos que si intentamos unir un único fallo, el resultado
es también un fallo.</p>
<p>Unir, o aplanar listas es bastante intuitivo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; join [[1,2,3],[4,5,6]]
[1,2,3,4,5,6]
</pre></div>
</div>
<p>Como puedes ver, para listas <code class="docutils literal notranslate"><span class="pre">join</span></code> es igual que <code class="docutils literal notranslate"><span class="pre">concat</span></code>. Para unir un
valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code> cuyo resultado es también un valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code> tenemos que
aplicar <code class="docutils literal notranslate"><span class="pre">mappend</span></code> al valor monádico.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runWriter $ join (Writer (Writer (1,&quot;aaa&quot;),&quot;bbb&quot;))
(1,&quot;bbbaaa&quot;)
</pre></div>
</div>
<p>El valor monádico exterior <code class="docutils literal notranslate"><span class="pre">&quot;bbb&quot;</span></code> se utiliza primero y luego se le añade
<code class="docutils literal notranslate"><span class="pre">&quot;aaa&quot;</span></code>. Dicho de otra forma, cuando queremos examinar el resultado de un
valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, primero tenemos que actualizar su registro y solo después de
esto podremos examinar sus contenidos.</p>
<p>Unir valores <code class="docutils literal notranslate"><span class="pre">Either</span></code> es muy parecido a unir valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; join (Right (Right 9)) :: Either String Int
Right 9
ghci&gt; join (Right (Left &quot;error&quot;)) :: Either String Int
Left &quot;error&quot;
ghci&gt; join (Left &quot;error&quot;) :: Either String Int
Left &quot;error&quot;
</pre></div>
</div>
<p>Si aplicamos <code class="docutils literal notranslate"><span class="pre">join</span></code> a un cómputo cuyo resultado sea otro cómputo con
estado, el resultado será un cómputo con estado que primero ejecutará el
cómputo exterior y luego el interior. Mira:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; runState (join (State $ \s -&gt; (push 10,1:2:s))) [0,0,0]
((),[10,1,2,0,0,0])
</pre></div>
</div>
<p>Aquí la función lambda toma un estado y apila <code class="docutils literal notranslate"><span class="pre">2</span></code> y <code class="docutils literal notranslate"><span class="pre">1</span></code> sobre la pila
y devuelve como resultado <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">10</span></code>, que es otro computo con estado. Así que
cuando todo esto se une con <code class="docutils literal notranslate"><span class="pre">join</span></code> y luego se ejecuta, primero se apila
<code class="docutils literal notranslate"><span class="pre">2</span></code> y <code class="docutils literal notranslate"><span class="pre">1</span></code> y luego se ejecuta <code class="docutils literal notranslate"><span class="pre">push</span> <span class="pre">10</span></code>, poniendo así <code class="docutils literal notranslate"><span class="pre">10</span></code> en la cima
de la pila.</p>
<p>La implementación de <code class="docutils literal notranslate"><span class="pre">join</span></code> es la siguiente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">join</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">join</span> <span class="n">mm</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mm</span>
    <span class="n">m</span>
</pre></div>
</div>
<p>Como el resultado de <code class="docutils literal notranslate"><span class="pre">mm</span></code> es un valor monádico, obtenemos ese resultado y
luego simplemente lo ponemos solo en la última línea porque por si solo ya es
un valor monádico. El truco aquí esta en <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&lt;-</span> <span class="pre">mm</span></code>, el contexto de la mónada
de la que estamos obteniendo un resultado se tiene en cuenta. Por este motivo,
por ejemplo, los valores <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> solo devuelven <code class="docutils literal notranslate"><span class="pre">Just</span></code> cuando tanto el
valor exterior como el valor interior son ambos <code class="docutils literal notranslate"><span class="pre">Just</span></code>. Así se vería esto
si <code class="docutils literal notranslate"><span class="pre">mm</span></code> fuera desde el principio <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">8)</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">joinedMaybes</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">joinedMaybes</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">m</span>
</pre></div>
</div>
<img alt="¡Incluso yo soy un ajente de la ley!" class="align-right" src="../_images/tipi.png" />
<p>Quizá lo más interesante de <code class="docutils literal notranslate"><span class="pre">join</span></code> es que funciona para cualquier mónada,
pasar un valor monádico a una función con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> es lo mismo que mapear esa
función sobre el valor monádico y luego utilizar <code class="docutils literal notranslate"><span class="pre">join</span></code> para unir el
resultado. Dicho de otro modo, <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> es siempre igual que
<code class="docutils literal notranslate"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></code>. Vale la pena que le dediques un poco de atención. Con
<code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, siempre pensamos que estamos pasando un valor monádico a una función
que toma un valor normal pero devuelve un valor monádico. Si mapeamos
directamente la función sobre el valor monádico, tendremos un valor como
resultado un valor monádico dentro de otro valor monádico. Por ejemplo,
digamos que tenemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">9</span></code> y la función <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">(x+1)</span></code>. Si mapeamos
esta función sobre <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">9</span></code> nos dará como resultado <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">10)</span></code>.</p>
<p>El hecho de que <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> sea siempre igual a <code class="docutils literal notranslate"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></code> es muy
útil porque si estamos creando una instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code> para un tipo,
siempre es más fácil averiguar como se deben unir dos valores monádicos
anidados que averiguar como implementar <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>.</p>
</div>
<div class="section" id="filterm">
<h3>filterM<a class="headerlink" href="#filterm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <code class="docutils literal notranslate"><span class="pre">filter</span></code> junto a la función <code class="docutils literal notranslate"><span class="pre">map</span></code> son de las funciones más
utilizadas en Haskell. Toma un predicado y una lista y la filtra de forma que
la lista resultante solo contenga los resultados que satisfagan el predicado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>El predicado toma un elemento de la lista y devuelve un valor <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. Pero,
¿y si el valor <code class="docutils literal notranslate"><span class="pre">Bool</span></code> que devuelve el predicado fuera en realidad un valor
monádico? ¿¡Qué!? En otras palabras, ¿y si el resultado tuviera un contexto?
¿Podría funcionar? Por ejemplo, ¿qué pasaría ti todos los valores <code class="docutils literal notranslate"><span class="pre">True</span></code> y
<code class="docutils literal notranslate"><span class="pre">False</span></code> que el predicado produce vienen acompañados de un valor monádico
como <code class="docutils literal notranslate"><span class="pre">[&quot;Número</span> <span class="pre">5</span> <span class="pre">aceptado&quot;]</span></code> o <code class="docutils literal notranslate"><span class="pre">[&quot;3</span> <span class="pre">es</span> <span class="pre">muy</span> <span class="pre">pequeño&quot;]</span></code>? Dicho así podría
funcionar. Si ese fuera el caso, cabe esperar que la lista resultante venga
con un registro que contenga el registro de todos los valores que se han
ido produciendo. Así que si el valor <code class="docutils literal notranslate"><span class="pre">Bool</span></code> que produce el resultado viene
con un contexto, lo normal es que la lista resultante también venga con
un contexto, de otro modo el contexto de cada <code class="docutils literal notranslate"><span class="pre">Bool</span></code> se perdería.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">filterM</span></code> de <code class="docutils literal notranslate"><span class="pre">Control.Monad</span></code> hace exactamente lo que estamos
buscando.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">filterM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>El predicado devuelve un valor monádico cuyo resultado es un <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, pero
como es un valor monádico, su contexto puede ser cualquier cosa, desde un
fallo hasta un no determinismo. Para asegurarnos de que el resultado final
refleja el contexto, el resultado también debe ser un valor monádico.</p>
<p>Vamos a tomar una lista y vamos a filtrarla de forma que solo nos quedemos con
los números que sean menores que 4. Para empezar, vamos a utilizar la función
normal <code class="docutils literal notranslate"><span class="pre">filter</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; filter (\x -&gt; x &lt; 4) [9,1,5,2,10,3]
[1,2,3]
</pre></div>
</div>
<p>Muy fácil. Ahora, vamos hacer que este predicado, además de devolver
<code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>, también adjunte un registro indicando lo que ha hecho.
Por supuesto vamos a utilizar la mónada <code class="docutils literal notranslate"><span class="pre">Writer</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">keepSmall</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Bool</span>
<span class="nf">keepSmall</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Keeping &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">return</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; is too large, throwing it away&quot;</span><span class="p">]</span>
        <span class="n">return</span> <span class="kt">False</span>
</pre></div>
</div>
<p>En lugar de devolver un <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, esta función devuelve un
<code class="docutils literal notranslate"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Bool</span></code>. Es un predicado monádico. Suena excesivo, ¿no crees?
Si el número es menor que <code class="docutils literal notranslate"><span class="pre">4</span></code> registramos que lo vamos a mantener y
luego hacemos <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">True</span></code>.</p>
<p>Ahora vamos a utilizar <code class="docutils literal notranslate"><span class="pre">filterM</span></code> con una lista. Como el predicado devuelve
un valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, el resultado de la lista será también un valor
<code class="docutils literal notranslate"><span class="pre">Writer</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
[1,2,3]
</pre></div>
</div>
<p>Examinando el resultado del valor de tipo <code class="docutils literal notranslate"><span class="pre">Writer</span></code> vemos que todo está en
orden. Ahora, vamos a mostrar el registro:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]
9 is too large, throwing it away
Keeping 1
5 is too large, throwing it away
Keeping 2
10 is too large, throwing it away
Keeping 3
</pre></div>
</div>
<p>Increíble. Simplemente utilizando un predicado monádico con <code class="docutils literal notranslate"><span class="pre">filterM</span></code> somos
capaces de filtrar una lista a la vez que mantenemos el contexto del que
estamos utilizando.</p>
<p>Existe un truco en Haskell para obtener el superconjunto de una lista (si
vemos las listas como un conjunto). El superconjunto de un conjunto es un
conjunto de todos los posible subconjuntos de éste. Así que si tenemos un
conjunto como <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code>, su superconjunto incluirá los siguientes
conjuntos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div>
</div>
<p>En otras palabras, obtener el superconjunto es como obtener todas las posibles
combinaciones de mantener o eliminar elementos de un conjunto. <code class="docutils literal notranslate"><span class="pre">[2,3]</span></code> sería
el conjunto original al que hemos eliminado el número <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>Para crear una función que devuelva el superconjunto de una lista vamos a
utilizar el no determinismo. Tomamos una lista como <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span></code> y luego
miramos el primer elemento, que es <code class="docutils literal notranslate"><span class="pre">1</span></code>, y nos preguntamos: ¿lo debemos
mantener o lo debemos eliminar? Bueno, en realidad queremos hacer ambas cosas.
Resumiendo, vamos a filtrar una lista y vamos a un utilizar un predicado no
determinista que elimine y mantenga cada elemento de la lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">powerset</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">powerset</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">filterM</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">])</span> <span class="n">xs</span>
</pre></div>
</div>
<p>¿Qué es esto? Bueno, elegimos eliminar y mantener cada elemento,
independientemente del valor de dicho elemento. Tenemos un predicado no
determinista, así que el resultado también será no determinista y por lo tanto
su tipo será una lista de listas. Vamos a probarlo.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; powerset [1,2,3]
[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
</pre></div>
</div>
<p>Quizá esto puede que no se entienda a la primera, pero si consideramos las
listas como valores no deterministas que no saben que valor escoger y por
tanto deciden ser todos a la vez, es más fácil de ver.</p>
</div>
<div class="section" id="foldm">
<h3><code class="docutils literal notranslate"><span class="pre">foldM</span></code><a class="headerlink" href="#foldm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La versión monádica de <code class="docutils literal notranslate"><span class="pre">foldl</span></code> es <code class="docutils literal notranslate"><span class="pre">foldM</span></code>. Si recuerdas bien los
<a class="reference internal" href="ordensuperior.html#pliegues"><span class="std std-ref">pliegues</span></a>, sabrás que <code class="docutils literal notranslate"><span class="pre">foldl</span></code> toma una función binaria,
un acumulador inicial y una lista y pliega la lista desde la izquierda
reduciendo la lista a un solo valor. <code class="docutils literal notranslate"><span class="pre">foldM</span></code> hace básicamente lo mismo, solo
que toma una función binaria que devuelve un valor monádico.
Sorprendentemente, el resultado final también es un valor monádico. La
declaración de tipo de <code class="docutils literal notranslate"><span class="pre">foldl</span></code> es:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Mientras que la de <code class="docutils literal notranslate"><span class="pre">foldM</span></code> es:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>El valor que devuelve la función binaria es un valor monádico por lo tanto
el valor final del pliegue también lo es. Vamos a sumar una lista de números
con un pliegue:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]
14
</pre></div>
</div>
<p>El acumulador inicial es <code class="docutils literal notranslate"><span class="pre">0</span></code> y luego se suma <code class="docutils literal notranslate"><span class="pre">2</span></code> al acumulador, el
resultado pasa a ser el nuevo acumulador que tiene un valor de <code class="docutils literal notranslate"><span class="pre">2</span></code>. Luego
se suma <code class="docutils literal notranslate"><span class="pre">8</span></code> al acumulador devolviendo así <code class="docutils literal notranslate"><span class="pre">10</span></code> que pasa a ser el nuevo
acumulador y así hasta que alcance el final de la lista, donde el acumulador
final será el resultado final de la función.</p>
<p>¿Y si queremos sumar una lista de números y además queremos añadir la
condición de que si en la lista existe un número mayor a <code class="docutils literal notranslate"><span class="pre">9</span></code>, todo el
cómputo falle? Tendría sentido utilizar la función binaria para comprobar si
el número actual es mayor que <code class="docutils literal notranslate"><span class="pre">9</span></code> y si lo es, falle, y si no continúe.
Debido a esta nueva posibilidad de fallo, vamos a hacer que la función binaria
devuelva un acumulador dentro de un tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> en lugar de un acumulador
normal. Así sería la función binaria:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">binSmalls</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">binSmalls</span> <span class="n">acc</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span>     <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Como la función binaria es ahora una función monádica, ya no podemos utilizar
un pliegue normal como <code class="docutils literal notranslate"><span class="pre">foldl</span></code>, tendremos que usar un pliegue monádico.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foldM binSmalls 0 [2,8,3,1]
Just 14
ghci&gt; foldM binSmalls 0 [2,11,3,1]
Nothing
</pre></div>
</div>
<p>¡Genial! Como había un número mayor que <code class="docutils literal notranslate"><span class="pre">9</span></code>, el resultado final fue
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. También es útil realizar un pliegue con una función binaria que
devuelva un valor <code class="docutils literal notranslate"><span class="pre">Writer</span></code>, ya que de este modo podemos obtener un registro
conforme recorremos la lista.</p>
</div>
<div class="section" id="creando-una-version-segura-de-la-calculadora-rpn">
<h3>Creando una versión segura de la calculadora RPN<a class="headerlink" href="#creando-una-version-segura-de-la-calculadora-rpn" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="¡Encontré oro!" class="align-left" src="../_images/miner.png" />
<p>Cuando estábamos solucionando el problema de implementar la
<a class="reference internal" href="problemas.html#rpn"><span class="std std-ref">calculadora RPN</span></a>, vimos que funcionaría bien siempre y cuando la
entrada tuviera sentido. Pero si algo iba mal, el programa entero terminaba.
Ahora que ya sabemos como convertir código en su versión monádica, vamos a
hacer una versión de la calculador RPN más segura ayudándonos de la mónada
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<p>Implementamos la calculadora RPN de forma que tomaba una cadena, como
<code class="docutils literal notranslate"><span class="pre">&quot;1</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*&quot;</span></code>, la dividiera en palabras para obtener algo como
<code class="docutils literal notranslate"><span class="pre">[&quot;1&quot;,&quot;3&quot;,&quot;+&quot;,&quot;2&quot;,&quot;*&quot;]</span></code> y luego la plegara utilizando como acumulador
inicial una pila vacía y una función binaria que apilaba números en la pila,
o sumaba los dos elementos superiores, o los dividía, etc.</p>
<p>Este era la función principal:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">solveRPN</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="o">.</span> <span class="n">words</span>
</pre></div>
</div>
<p>Convertíamos la expresión en una lista de cadenas, la plegábamos utilizando
una función binaria y luego devolvíamos el único elemento que quedaba en la
pila. Así era la función binaria:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="kt">:</span><span class="n">xs</span>
</pre></div>
</div>
<p>En este caso el acumulador del pliegue era la pila, la cual representábamos
como una lista de valores <code class="docutils literal notranslate"><span class="pre">Double</span></code>. Conforme la función de pliegue avanzaba
por la expresión RPN, si el elemento actual era un operador, obteníamos los
dos elementos superiores de la pila, aplicábamos el operador y luego
apilábamos el resultado de nuevo. Si el elemento actual era una cadena que
representaba un número, convertíamos la cadena en un número real y lo
apilábamos.</p>
<p>Primero vamos a hacer que esta función pueda fallar de forma correcta. Su
declaración de tipo cambiará de esta forma:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
</pre></div>
</div>
<p>Así que ahora su resultado será o bien un valor <code class="docutils literal notranslate"><span class="pre">Just</span></code> con una pila o bien
fallará con <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>La función <code class="docutils literal notranslate"><span class="pre">reads</span></code> es igual que <code class="docutils literal notranslate"><span class="pre">read</span></code>, solo que devuelve una lista con
un único elemento en caso de que tenga éxito. Si no puede leer algo, devuelve
una lista vacía. Aparte de devolver el valor que lee, también devuelve la
parte de la cadena que no ha consumido. Vamos a decir que siempre tiene que
leer toda la cadena para que funcione correctamente y vamos a crear una
función <code class="docutils literal notranslate"><span class="pre">readMaybe</span></code> por conveniencia.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">readMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">readMaybe</span> <span class="n">st</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">reads</span> <span class="n">st</span> <span class="kr">of</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>
                                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>La probamos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; readMaybe &quot;1&quot; :: Maybe Int
Just 1
ghci&gt; readMaybe &quot;GO TO HELL&quot; :: Maybe Int
Nothing
</pre></div>
</div>
<p>Vale, parece que funciona. Ahora vamos a convertir la función binaria en
una función binaria que puede fallar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">numberString</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;¡whops!&quot;</span>
</pre></div>
</div>
<p>Los primeros tres casos son iguales que los originales, solo que ahora la
pila nueva se introduce en <code class="docutils literal notranslate"><span class="pre">Just</span></code> (hemos utilizado <code class="docutils literal notranslate"><span class="pre">return</span></code> para lograrlo,
pero podíamos haber utilizado simplemente <code class="docutils literal notranslate"><span class="pre">Just</span></code> también). En el cuarto
caso, hacemos <code class="docutils literal notranslate"><span class="pre">readMaybe</span> <span class="pre">numberString</span></code> y luego mapeamos <code class="docutils literal notranslate"><span class="pre">(:xs)</span></code> sobre su
resultado. Es decir, si la pila <code class="docutils literal notranslate"><span class="pre">xs</span></code> es <code class="docutils literal notranslate"><span class="pre">[1.0,2.0]</span></code> y
<code class="docutils literal notranslate"><span class="pre">readMaybe</span> <span class="pre">numberString</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">3.0</span></code>, el resultado será
<code class="docutils literal notranslate"><span class="pre">[1.0,2.0,3.0]</span></code>. Si <code class="docutils literal notranslate"><span class="pre">readMaybe</span> <span class="pre">numberString</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> el
resultado final será <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Vamos a probar esta función:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; foldingFunction [3,2] &quot;*&quot;
Just [6.0]
ghci&gt; foldingFunction [3,2] &quot;-&quot;
Just [-1.0]
ghci&gt; foldingFunction [] &quot;*&quot;
Nothing
ghci&gt; foldingFunction [] &quot;1&quot;
Just [1.0]
ghci&gt; foldingFunction [] &quot;1 wawawawa&quot;
Nothing
</pre></div>
</div>
<p>¡Parece que funciona! Ahora es hora de mejorar la función <code class="docutils literal notranslate"><span class="pre">solveRPN</span></code> ¡Aquí
la tienen!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="nf">solveRPN</span> <span class="n">st</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="ow">&lt;-</span> <span class="n">foldM</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">words</span> <span class="n">st</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Al igual que antes, tomamos una cadena y la dividimos en palabras. Luego,
realizamos el pliegue, empezando con una pila vacía, solo que en lugar de
realizar un pliegue normal con <code class="docutils literal notranslate"><span class="pre">foldl</span></code> utilizamos <code class="docutils literal notranslate"><span class="pre">foldM</span></code>. El resultado
de <code class="docutils literal notranslate"><span class="pre">foldM</span></code> debe ser un valor del tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> que contendrá una lista
(es decir, la pila final) que a su vez solo debería contener un valor.
Utilizamos una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> para obtener el valor y lo llamamos
<code class="docutils literal notranslate"><span class="pre">result</span></code>. En caso de que <code class="docutils literal notranslate"><span class="pre">foldM</span></code> devuelva <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, el resultado final
será <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, porque así es como funciona la mónada <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Fíjate
también en el ajuste del patrón en el interior de la expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>, de esta
forma si la lista tiene más de un solo o ningún elemento, el ajuste fallará
y se producirá un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. En la última línea simplemente hacemos
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">result</span></code> para devolver el resultado de la expresión RPN dentro de un
valor del tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<p>Probémoslo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; solveRPN &quot;1 2 * 4 +&quot;
Just 6.0
ghci&gt; solveRPN &quot;1 2 * 4 + 5 *&quot;
Just 30.0
ghci&gt; solveRPN &quot;1 2 * 4&quot;
Nothing
ghci&gt; solveRPN &quot;1 8 wharglbllargh&quot;
Nothing
</pre></div>
</div>
<p>El primer fallo sucede porque la pila final no contiene un único elemento y
por tanto el ajuste de patrones contenido en la expresión <code class="docutils literal notranslate"><span class="pre">do</span></code> falla. El
segundo fallo se debe a que <code class="docutils literal notranslate"><span class="pre">readMaybe</span></code> devuelve <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
</div>
<div class="section" id="componiendo-funciones-monadicas">
<h3>Componiendo funciones monádicas<a class="headerlink" href="#componiendo-funciones-monadicas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando hablamos de las leyes de las mónadas, vimos que la función <code class="docutils literal notranslate"><span class="pre">&lt;=&lt;</span></code> era
parecida a la composición de funciones, solo que en lugar de tratar con
funciones normales <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></code>, funcionaba con funciones monádicas como
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></code>. Por ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let f = (+1) . (*100)
ghci&gt; f 4
401
ghci&gt; let g = (\x -&gt; return (x+1)) &lt;=&lt; (\x -&gt; return (x*100))
ghci&gt; Just 4 &gt;&gt;= g
Just 401
</pre></div>
</div>
<p>En este ejemplo primero componemos dos funciones normales, y luego las
aplicamos la función resultante a <code class="docutils literal notranslate"><span class="pre">4</span></code>. Luego componemos dos funciones
monádicas, y luego le pasamos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">4</span></code> a la función resultante utilizando
<code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>.</p>
<p>Si tenemos una lista de funciones, podemos componerlas en una sola gran
función utilizando <code class="docutils literal notranslate"><span class="pre">id</span></code> como acumulador inicial y la función <code class="docutils literal notranslate"><span class="pre">.</span></code> como
función binaria. O también utilizando la función <code class="docutils literal notranslate"><span class="pre">foldr1</span></code>. Aquí tienes un
ejemplo:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; let f = foldr (.) id [(+1),(*100),(+1)]
ghci&gt; let g = foldr1 (.) [(+1),(*100),(+1)]
ghci&gt; f 1
201
ghci&gt; g 1
201
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">f</span></code> toma un número y luego le suma <code class="docutils literal notranslate"><span class="pre">1</span></code>, luego multiplica el
resultado por <code class="docutils literal notranslate"><span class="pre">100</span></code> y luego le suma <code class="docutils literal notranslate"><span class="pre">1</span></code> al resultado anterior. De
todos modos, podemos componer funciones monádicas de la misma forma, solo que
en lugar de utilizar una composición de funciones normal utilizamos <code class="docutils literal notranslate"><span class="pre">&lt;=&lt;</span></code>, y
en lugar de utilizar <code class="docutils literal notranslate"><span class="pre">id</span></code> utilizamos <code class="docutils literal notranslate"><span class="pre">return</span></code>. No tenemos que utilizar
<code class="docutils literal notranslate"><span class="pre">foldM</span></code> en lugar de <code class="docutils literal notranslate"><span class="pre">foldr</span></code> ya que <code class="docutils literal notranslate"><span class="pre">&lt;=&lt;</span></code> se encarga de que la
composición sea monádica.</p>
<p>Cuando vimos la mónada lista en el <a class="reference internal" href="monadas.html#mlista"><span class="std std-ref">capítulo anterior</span></a>, la
utilizamos para encontrar a qué posiciones podía desplazarse un caballo en
un tablero de ajedrez con exactamente tres movimientos. Teníamos una función
que se llamaba <code class="docutils literal notranslate"><span class="pre">moveKnight</span></code>, la cual tomaba la posición en el tablero del
caballo y devolvía todos los posibles movimientos que podía tomar. Luego,
para generar todos los posibles posiciones que podía alcanzar en tres
movimientos utilizábamos una función como estas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">in3</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">start</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span>
</pre></div>
</div>
<p>Y para comprobar si el caballo podía llegar desde <code class="docutils literal notranslate"><span class="pre">start</span></code> hasta <code class="docutils literal notranslate"><span class="pre">end</span></code> en
tres movimientos utilizábamos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">canReachIn3</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">canReachIn3</span> <span class="n">start</span> <span class="n">end</span> <span class="ow">=</span> <span class="n">end</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">in3</span> <span class="n">start</span>
</pre></div>
</div>
<p>Utilizando la composición de funciones podemos crear una función como <code class="docutils literal notranslate"><span class="pre">in3</span></code>,
solo que en lugar de generar todas las posibles soluciones que puede alcanzar
el caballo en tres movimientos, podemos hacerlo para un número arbitrario de
movimientos. Si nos fijamos en <code class="docutils literal notranslate"><span class="pre">in3</span></code>, vemos que hemos utilizado
<code class="docutils literal notranslate"><span class="pre">moveKnight</span></code> tres veces y hemos utilizado <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> en cada paso para pasar
las posibles posiciones anteriores. Ahora vamos a hacerlo más general.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">inMany</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">KnightPos</span><span class="p">]</span>
<span class="nf">inMany</span> <span class="n">x</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">start</span> <span class="o">&gt;&gt;=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&lt;=&lt;</span><span class="p">)</span> <span class="n">return</span> <span class="p">(</span><span class="n">replicate</span> <span class="n">x</span> <span class="n">moveKnight</span><span class="p">)</span>
</pre></div>
</div>
<p>Primero utilizamos <code class="docutils literal notranslate"><span class="pre">replicate</span></code> para crear una lista que contenga <code class="docutils literal notranslate"><span class="pre">x</span></code>
veces la función <code class="docutils literal notranslate"><span class="pre">moveKnight</span></code>. Luego, componemos monádicamente todas esas
funciones en una, lo cual resulta en una función que toma una posición incial
y mueve el caballo de forma no determinista <code class="docutils literal notranslate"><span class="pre">x</span></code> veces. Luego, simplemente
creamos una lista unitaria con la posición inicial con <code class="docutils literal notranslate"><span class="pre">return</span></code> y se la
pasamos a la función.</p>
<p>Ahora también podemos cambiar la función <code class="docutils literal notranslate"><span class="pre">canReachIn3</span></code> para que sea más
general:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">canReachIn</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">canReachIn</span> <span class="n">x</span> <span class="n">start</span> <span class="n">end</span> <span class="ow">=</span> <span class="n">end</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">inMany</span> <span class="n">x</span> <span class="n">start</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creando-monadas">
<h2>Creando mónadas<a class="headerlink" href="#creando-monadas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="kewl" class="align-center" src="../_images/spearhead.png" />
<p>En esta sección vamos a ver un ejemplo de como se crea un tipo, como se
identifica que se trata de una mónada y luego como darle una instancia
<code class="docutils literal notranslate"><span class="pre">Monad</span></code> apropiada. Normalmente no nos ponemos a crear una mónada por el
simple hecho de crear mónadas. En lugar de ello, solemos crear un tipo con el
propósito de modelar un aspecto de algún problema y luego si vemos que ese
tipo representa valores con un contexto y puede comportarse como una mónada,
le damos una instancia de <code class="docutils literal notranslate"><span class="pre">Monad</span></code>.</p>
<p>Como ya hemos visto, las listas se utilizan para representar valores
no deterministas. Una lista como <code class="docutils literal notranslate"><span class="pre">[3,5,9]</span></code> puede ser vista como un solo
valor no determinista que no puede decidir que valor ser. Cuando pasamos una
lista a una función con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>, simplemente crea todas las posibilidades
de tomar un elemento concreto de la lista y le aplica la función, de forma que
los resultados que produzca aparezcan en el resultado final.</p>
<p>Si vemos la lista <code class="docutils literal notranslate"><span class="pre">[3,5,9]</span></code> como los número <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">5</span></code> y <code class="docutils literal notranslate"><span class="pre">9</span></code> al mismo
tiempo, podemos darnos cuenta de que no tenemos ninguna información de la
probabilidad de que esos números aparezcan. ¿y si quisiéramos un modelar un
valor no determinista como <code class="docutils literal notranslate"><span class="pre">[3,5,9]</span></code>, pero que expresará también que <code class="docutils literal notranslate"><span class="pre">3</span></code>
tiene un 50% probabilidades de ocurrir y <code class="docutils literal notranslate"><span class="pre">5</span></code> y <code class="docutils literal notranslate"><span class="pre">9</span></code> tienen un 25% de
probabilidades? Es una pregunta muy larga, lo se, pero vamos a buscar una
respuesta.</p>
<p>Digamos que cada elemento de la lista va acompañado de otro valor, la
probabilidad de que ocurra. Podría tener sentido representarlo así:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[(3,0.5),(5,0.25),(9,0.25)]
</pre></div>
</div>
<p>En las matemáticas, las probabilidades no se suelen representar con
porcentajes sino con valores reales que van desde el 0 hasta el 1. Un 0
significa que no hay ninguna posibilidad de que ocurra un suceso mientras que
un 1 representa que el suceso va ocurrir sí o sí. Los número en coma flotante
pueden ser muy eficientes ya que tienden a perder precisión, así que Haskell
nos ofrece un tipo de dato para los números racionales de forma que no pierda
precisión. Este tipo se llama <code class="docutils literal notranslate"><span class="pre">Rational</span></code> y reside en el módulo
<code class="docutils literal notranslate"><span class="pre">Data.Ratio</span></code>. Para crear un número del tipo <code class="docutils literal notranslate"><span class="pre">Rational</span></code> lo escribimos en
forma de fracción. Separamos el numerador y el denominador por <code class="docutils literal notranslate"><span class="pre">%</span></code>. Aquí
tienes unos ejemplos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; 1%4
1 % 4
ghci&gt; 1%2 + 1%2
1 % 1
ghci&gt; 1%3 + 5%4
19 % 12
</pre></div>
</div>
<p>La primera línea representa un cuarto. En la segunda línea sumamos dos
medios y obtenemos la unidad y en la tercera línea sumamos un tercero a
cinco cuartos y obtenemos diecinueve docenas de huevos. Vamos a utilizar
número <code class="docutils literal notranslate"><span class="pre">Rational</span></code> en lugar de números en coma flotante para representar las
probabilidades.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; [(3,1%2),(5,1%4),(9,1%4)]
[(3,1 % 2),(5,1 % 4),(9,1 % 4)]
</pre></div>
</div>
<p>Vale, <code class="docutils literal notranslate"><span class="pre">3</span></code> tiene la mitad de posibilidades de ocurrir y <code class="docutils literal notranslate"><span class="pre">5</span></code> y <code class="docutils literal notranslate"><span class="pre">9</span></code> tienen
un cuarto de posibilidades de salir. Muy bonito.</p>
<p>Tomamos las listas y les añadimos un contexto adicional, así que esto también
representa valores en cierto contexto. Antes de continuar, vamos representar
esto con <code class="docutils literal notranslate"><span class="pre">newtype</span></code> porque algo me dice que vamos a crear alguna instancias.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Ratio</span>

<span class="kr">newtype</span> <span class="kt">Prob</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">{</span> <span class="n">getProb</span> <span class="ow">::</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="kt">Rational</span><span class="p">)]</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Muy bien ¿Esto es un funtor? Bueno, la lista es un funtor, así que
probablemente esto sea un funtor también ya que solo hemos añadido algo más
de contexto. Cuando mapeamos una función sobre una lista, la aplicamos a todos
los elementos. Ahora también aplicaremos la función a todos los elementos,
solo que mantendremos las probabilidades intactas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Prob</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Extraemos el valor del <code class="docutils literal notranslate"><span class="pre">newtype</span></code> utilizando un ajuste de patrones, aplicamos
la función <code class="docutils literal notranslate"><span class="pre">f</span></code> a los valores mientras nos aseguramos de mantener constantes
las probabilidades. Vamos a ver si funciona:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])
Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}
</pre></div>
</div>
<p>Otra cosa que tenemos que tener en cuenta es que todas estas probabilidades
deben sumar <code class="docutils literal notranslate"><span class="pre">1</span></code>. Si todo esto son cosas que pueden ocurrir, no tiene sentido
que la suma de sus probabilidades sea distinta de <code class="docutils literal notranslate"><span class="pre">1</span></code>. Una moneda que al
lanzarla salga un 75% de las veces cruz y un 50% de las veces caras es algo
que solo podría en otro extraño universo.</p>
<p>Ahora, la gran pregunta, ¿es una mónada? Dado que las listas son mónadas,
parece que esto puede también puede ser una mónada. Primero vamos a pensar
en <code class="docutils literal notranslate"><span class="pre">return</span></code> ¿Cómo funciona con las listas? Toma un valor y crea una lista
unitaria que lo contenga ¿Qué sucederá aquí? Bueno, como se supone que es el
contexto mínimo por defecto, también creará una lista unitaria ¿Qué hay de la
probabilidad? Bueno, <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">x</span></code> se supone que siempre crea un valor monádico
capaz de albergar <code class="docutils literal notranslate"><span class="pre">x</span></code> como resultado, así que no tiene sentido que su
probabilidad sea <code class="docutils literal notranslate"><span class="pre">0</span></code>. Como siempre devuelve el mismo resultado, su
probabilidad debe ser <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>¿Qué pasa con <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>? Parece algo complicado, así que vamos a utilizar el
hecho de que <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> siempre sea igual a <code class="docutils literal notranslate"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></code> para todas
las mónadas y centrarnos en como unir una lista de probabilidades que contiene
listas de probabilidades. Como ejemplo vamos a considerar una lista donde
existe un 25% de probabilidades de que ocurra <code class="docutils literal notranslate"><span class="pre">'a'</span></code> o <code class="docutils literal notranslate"><span class="pre">'b'</span></code>. Tanto <code class="docutils literal notranslate"><span class="pre">'a'</span></code>
como <code class="docutils literal notranslate"><span class="pre">'b'</span></code> tienen la misma probabilidad de ocurrir. También existe un 75% de
probabilidades de que salga <code class="docutils literal notranslate"><span class="pre">'c'</span></code> o <code class="docutils literal notranslate"><span class="pre">'d'</span></code>. Tanto <code class="docutils literal notranslate"><span class="pre">'c'</span></code> como <code class="docutils literal notranslate"><span class="pre">'d'</span></code>
tienen la misma probabilidad de ocurrir. Aquí tienes una imagen que representa
este posible escenario.</p>
<img alt="Probabilidades" class="align-left" src="../_images/prob.png" />
<p>¿Cuáles son las probabilidades de cada uno de estos valores ocurra? Si
dibujamos todas estas probabilidades como cajas, cada una con una
probabilidad, ¿cuáles serían estas probabilidades? Para calcularlas, todo
lo que tenemos que hacer es multiplicar la probabilidad con la probabilidad
que lo contenga. <code class="docutils literal notranslate"><span class="pre">'a'</span></code> tendrá una probabilidad de un octavo, al igual que
<code class="docutils literal notranslate"><span class="pre">'b'</span></code>, ya que si multiplicamos un medio por un cuarto obtenemos un octavo.
<code class="docutils literal notranslate"><span class="pre">'c'</span></code> ocurrirá tres octavos de las veces porque si multiplicamos un medio
por tres cuartos obtenemos tres octavos. <code class="docutils literal notranslate"><span class="pre">'d'</span></code> ocurrirá tres octavos. Si
sumamos todas las probabilidades dará uno como resultado.</p>
<p>Así se representaría la situación actual:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">thisSituation</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="p">(</span><span class="kt">Prob</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">thisSituation</span> <span class="ow">=</span> <span class="kt">Prob</span>
    <span class="p">[(</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span> <span class="p">,</span> <span class="mi">1</span><span class="o">%</span><span class="mi">4</span> <span class="p">)</span>
    <span class="p">,(</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span> <span class="p">,</span> <span class="mi">3</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Fíjate que el tipo es <code class="docutils literal notranslate"><span class="pre">Prob</span> <span class="pre">(Pron</span> <span class="pre">Char)</span></code>. Así que ahora que hemos averiguado
como unir varias listas de probabilidades anidadas, solo tenemos que escribir
el código y utilizarlo para implementar <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code> como <code class="docutils literal notranslate"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></code> y
ya tendremos nuestra mónada lista. Aquí tenemos la función <code class="docutils literal notranslate"><span class="pre">flattern</span></code>, tiene
este nombre porque alguien ya utilizo antes que nosotros el nombre <code class="docutils literal notranslate"><span class="pre">join</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">flatten</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Prob</span> <span class="n">a</span>
<span class="nf">flatten</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="o">$</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="n">multAll</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">multAll</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">innerxs</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="o">*</span><span class="n">r</span><span class="p">))</span> <span class="n">innerxs</span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">multAll</span></code> toma un dupla con una lista de probabilidades y una
probabilidad <code class="docutils literal notranslate"><span class="pre">p</span></code> y produce una nueva lista de probabilidades en las que
las probabilidades de todos los elementos han sido multiplicadas por <code class="docutils literal notranslate"><span class="pre">p</span></code>.
Mapeamos <code class="docutils literal notranslate"><span class="pre">multAll</span></code> sobre cada dupla de la lista anidada y luego la aplanamos
con <code class="docutils literal notranslate"><span class="pre">concat</span></code>.</p>
<p>Ahora que ya tenemos todo lo que necesitamos podemos escribir la instancia de
<code class="docutils literal notranslate"><span class="pre">Monad</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Prob</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">flatten</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="kt">[]</span>
</pre></div>
</div>
<img alt="Cavalgando" class="align-right" src="../_images/ride.png" />
<p>Como ya hemos hecho todo el trabajo sucio, la instancia es muy simple. También
hemos definido la función <code class="docutils literal notranslate"><span class="pre">fail</span></code>, que al igual que la instancia de la
listas, devuelve una lista vacía. Así que si ocurre un fallo en un ajuste de
patrones dentro de una expresión <code class="docutils literal notranslate"><span class="pre">do</span></code>, ocurrirá un fallo en el contexto en
si mismo.</p>
<p>Es importante también comprobar si se cumple la leyes de las mónadas. La
primera ley dice que <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> debe ser igual que <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code>. Una prueba
rigurosa sería algo tediosa, pero podemos ver que si tomamos un valor y lo
introducimos en contexto mínimo por defecto con <code class="docutils literal notranslate"><span class="pre">return</span></code> y luego mapeamos
una función con <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre este valor para después aplanar la lista de
probabilidades resultante, cada probabilidad que produzca la función será
multiplicada por <code class="docutils literal notranslate"><span class="pre">1%1</span></code>, así que el contexto no se verá afectado. El
razonamiento por el cual <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span></code> es igual a <code class="docutils literal notranslate"><span class="pre">m</span></code> es similar. La
tercera ley dice que <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">(g</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h)</span></code> debe ser igual a <code class="docutils literal notranslate"><span class="pre">(f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">g)</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h</span></code>.
Esta ley también se cumple ya que mantenemos la mónada lista como base de esta
nueva mónada y por que la multiplicación es asociativa. <code class="docutils literal notranslate"><span class="pre">1%2</span> <span class="pre">*</span> <span class="pre">(1%3</span> <span class="pre">*</span> <span class="pre">1%5)</span></code>
es igual que <code class="docutils literal notranslate"><span class="pre">(1%2</span> <span class="pre">*</span> <span class="pre">1%3)</span> <span class="pre">*</span> <span class="pre">1%5</span></code>.</p>
<p>Ahora que tenemos una mónada, ¿qué podemos hacer con ella? Bueno, nos puede
ayudar a hacer cálculos con probabilidades. Podemos tratar eventos
probabilísticos como valores con un cierto contexto y la mónada probabilidad
se encargará de que las probabilidades se reflejen en el resultado final.</p>
<p>Digamos que tenemos dos monedas normales y una moneda trucada que siempre
saca cruz nueve de cada diez veces. Si lanzamos todas estas monedas a la vez,
¿cuáles son las probabilidad de que todas ellas sean cruz? Primero, vamos
a crear unas listas de probabilidades para las monedas normales y para la
trucada:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Coin</span> <span class="ow">=</span> <span class="kt">Heads</span> <span class="o">|</span> <span class="kt">Tails</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="nf">coin</span><span class="p">,</span> <span class="n">loadedCoin</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="kt">Coin</span>
<span class="nf">coin</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="kt">Heads</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="kt">Tails</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span>

<span class="nf">loadedCoin</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="kt">Heads</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">10</span><span class="p">),(</span><span class="kt">Tails</span><span class="p">,</span><span class="mi">9</span><span class="o">%</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
<p>Luego creamos la acción de lanzar las monedas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">all</span><span class="p">)</span>

<span class="nf">flipThree</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="kt">Bool</span>
<span class="nf">flipThree</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">coin</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">coin</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">loadedCoin</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">all</span> <span class="p">(</span><span class="o">==</span><span class="kt">Tails</span><span class="p">)</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<p>Vemos que las probabilidades de que todas ellas sean cara no son muy buenas,
incluso aunque tengamos una moneda trucada.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ghci&gt; getProb flipThree
[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),
 (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
</pre></div>
</div>
<p>Las tres serán cruz nueve veces de cuarenta lanzamientos, lo cual es menos
del 25%. Podemos ver que la mónada no sabe como unir todos los valores iguales
a <code class="docutils literal notranslate"><span class="pre">False</span></code>, donde no todas las tres monedas fueron cruz. No es un gran
problema, ya que podemos crear una función que tome elemento a elemento y
vaya sumando las probabilidades del mismo suceso. Ya tienes algo que hacer.</p>
<p>En esta sección hemos pasado de tener una pregunta (¿qué pasaría si añadimos
información sobre la probabilidad de un elemento?) a crear un tipo,
identificando una mónada y finalmente creando una instancia para trabajar con
ella. Creo que hemos hecho bastante. A esta alturas ya deberíamos tener una
buena idea que son las mónadas y como trabajar con ellas.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="zippers.html" title="Zippers"
             >siguiente</a></li>
        <li class="right" >
          <a href="monadas.html" title="Un puñado de mónadas"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>