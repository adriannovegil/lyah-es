
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Resolviendo problemas de forma funcional &#8212; documentación de ¡Aprende Haskell por el bien de todos! - 0.1</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Funtores, funtores aplicativos y monoides" href="funtores.html" />
    <link rel="prev" title="Entrada y salida" href="entradasalida.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="funtores.html" title="Funtores, funtores aplicativos y monoides"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="entradasalida.html" title="Entrada y salida"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="resolviendo-problemas-de-forma-funcional">
<h1>Resolviendo problemas de forma funcional<a class="headerlink" href="#resolviendo-problemas-de-forma-funcional" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En este capítulo, veremos un par de problemas interesantes y como resolverlos
de forma funcional y elegante. Probablemente no introduciremos ningún concepto
nuevo, solo vamos a practicar nuestras habilidades de programación y calentar
un poco. Cada sección presentará un problema diferente. Primero describiremos
el problema, luego intentaremos resolverlo y trataremos de encontrar la mejor
(o al menos no la peor) forma de resolverlo.</p>
<div class="section" id="notacion-polaca-inversa">
<span id="rpn"></span><h2>Notación polaca inversa<a class="headerlink" href="#notacion-polaca-inversa" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Normalmente cuando escribíamos expresiones matemáticas en la escuela lo
hacíamos de forma infija. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">-</span> <span class="pre">(4</span> <span class="pre">+</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">2</span></code>. <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code> y
<code class="docutils literal notranslate"><span class="pre">-</span></code> son operadores infijos, al igual que los funciones infijas que conocemos
de Haskell (<code class="docutils literal notranslate"><span class="pre">+</span></code>, <cite>elem</cite>, etc.). Resulta bastante útil, ya que nosotros, como
humanos, podemos analizar fácilmente estas expresiones. La pega es que tenemos
que utilizar paréntesis para especificar la precedencia.</p>
<p>La <a class="reference external" href="http://es.wikipedia.org/wiki/Notaci%C3%B3n_polaca_inversa">Notación polaca inversa</a>
es otra forma de escribir expresiones matemáticas. Al principio parece un poco
enrevesado, pero en realidad es bastante fácil de entender y utilizar ya que
no hay necesidad de utilizar paréntesis y muy fácil de utilizar en la
calculadoras. Aunque las calculadoras más modernas usan una notación infija,
todavía hay gente que lleva calculadoras RPN (del inglés, <em>Reverse</em> <em>Polish</em>
<em>Notation</em>). Así se vería la expresión infija anterior en RPN:
<code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">-</span></code> ¿Cómo calculamos el resultado de esto? Bueno, piensa en una
pila. Recorremos la expresión de izquierda a derecha. Cada vez que encontramos
un número, lo apilamos. Cuando encontramos un operador, retiramos los dos
números que hay en la cima de la pila, utilizamos el operador con ellos y
apilamos el resultado de nuevo. Cuando alcancemos el final de la expresión,
debemos tener un solo número en la pila si la expresión estaba bien formada, y
éste representa el resultado de la expresión</p>
<img alt="¡Esto es una expresión!" class="align-center" src="../_images/rpn.png" />
<p>¡Vamos a realizar la operación <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">-</span></code> juntos! Primero apilamos
<code class="docutils literal notranslate"><span class="pre">10</span></code> de forma que ahora nuestra pila contiene un <code class="docutils literal notranslate"><span class="pre">10</span></code>. El siguiente
elemento es un <code class="docutils literal notranslate"><span class="pre">4</span></code>, así que lo apilamos también. La pila ahora contiene
<code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">4</span></code>. Hacemos los mismo para el <code class="docutils literal notranslate"><span class="pre">3</span></code> y conseguimos una pila que contiene
<code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">4,</span> <span class="pre">3</span></code>. Ahora, encontramos un operador, <code class="docutils literal notranslate"><span class="pre">+</span></code>. Retiramos los dos números
que se encuentran en la cima de la pila (de forma que la pila se quedaría de
nuevo solo con <code class="docutils literal notranslate"><span class="pre">10</span></code>), sumamos esos dos números y apilamos el resultado. La
pila contiene <code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">7</span></code> ahora mismo. Apilamos <code class="docutils literal notranslate"><span class="pre">2</span></code> y obtenemos <code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">7,</span> <span class="pre">2</span></code>.
Multiplicamos <code class="docutils literal notranslate"><span class="pre">7</span></code> y <code class="docutils literal notranslate"><span class="pre">2</span></code> y obtenemos <code class="docutils literal notranslate"><span class="pre">14</span></code>, así que lo apilamos y la pila
ahora contendrá <code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">14</span></code>. Para terminar hay un <code class="docutils literal notranslate"><span class="pre">-</span></code>. Retiramos <code class="docutils literal notranslate"><span class="pre">10</span></code> y
<code class="docutils literal notranslate"><span class="pre">14</span></code> de la pila, restamos <code class="docutils literal notranslate"><span class="pre">14</span></code> a <code class="docutils literal notranslate"><span class="pre">10</span></code> y apilamos el resultado. El número
que contiene la pila es <code class="docutils literal notranslate"><span class="pre">-4</span></code> y como no hay más números ni operadores en la
expresión, ese es el resultado.</p>
<p>Ahora que ya sabemos como calcular una expresión RPN a mano, vamos a pensar en
como podríamos hacer que una función Haskell tomara como parámetro una cadena
que contenga una expresión RPN, como <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">-</span></code>, y nos devolviera el
resultado.</p>
<p>¿Cuál sería el tipo que debería tener esta función? Queremos que tome una
cadena y produzca un número como resultado. Así que lo más seguro es que el
tipo sea algo como <code class="docutils literal notranslate"><span class="pre">solveRPN</span> <span class="pre">::</span> <span class="pre">(Num</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Ayuda mucho pensar primero en cual será la declaración de tipo de
una función antes de preocuparnos en como implementarla para luego
escribirla. Gracias al sistema de tipos de Haskell, la declaración
de tipo de una función nos da mucha información acerca de ésta.</p>
</div>
<img alt="¡Ja ja ja!" class="align-left" src="../_images/calculator.png" />
<p>Bien. Cuando implementemos la solución de un problema en Haskell, a veces es
bueno volver a ver como lo solucionamos a mano para ver si podemos sacar algo
que nos ayude. En este caso vimos que tratábamos cada número u operador que
estaba separado por un espacio como un solo elemento. Así que podría ayudarnos
si empezamos rompiendo una cadena como <code class="docutils literal notranslate"><span class="pre">&quot;10</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">-&quot;</span></code> en una lista de
elementos como <code class="docutils literal notranslate"><span class="pre">[&quot;10&quot;,&quot;4&quot;,&quot;3&quot;,&quot;+&quot;,&quot;2&quot;,&quot;*&quot;,&quot;-&quot;]</span></code>.</p>
<p>A continuación ¿Qué fue lo siguiente que hicimos mentalmente? Recorrimos la
expresión de izquierda a derecha mientras manteníamos una pila ¿Te recuerda la
frase anterior a algo? Recuerda la sección que hablaba de los
<a class="reference internal" href="ordensuperior.html#pliegues"><span class="std std-ref">pliegues</span></a>, dijimos que cualquier función que recorra una
lista de izquierda a derecha, elemento a elemento, y genere (o acumule) un
resultado (ya sea un número, una lista, una pila o lo que sea) puede ser
implementado con un pliegue.</p>
<p>En este caso, vamos a utilizar un pliegue por la izquierda, ya que vamos a
recorrer la lista de izquierda a derecha. Nuestro acumulador será la pila, y
por la tanto el resultado será también una pila, solo que, como ya hemos
visto, contendrá un solo elemento.</p>
<p>Una cosa más que tenemos que pensar es, bueno ¿Cómo vamos a representar la
pila? Propongo que utilicemos una lista. También propongo que mantengamos en
la cabeza de la lista la cima de la pila. De esta forma añadir un elemento en
la cabeza de la lista es mucho más eficiente que añadirlo al final. Así que si
tenemos una pila como, <code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">4,</span> <span class="pre">3</span></code>, la representaremos con una lista como
<code class="docutils literal notranslate"><span class="pre">[3,4,10]</span></code>.</p>
<p>Ahora tenemos suficiente información para bosquejar vagamente nuestra función.
Tomará una cadena como <code class="docutils literal notranslate"><span class="pre">&quot;10</span> <span class="pre">4</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">-&quot;</span></code> y la romperá en una lista de
elementos utilizando <code class="docutils literal notranslate"><span class="pre">words</span></code> de forma que obtenga
<code class="docutils literal notranslate"><span class="pre">[&quot;10&quot;,&quot;4&quot;,&quot;3&quot;,&quot;+&quot;,&quot;2&quot;,&quot;*&quot;,&quot;-&quot;]</span></code>. Luego, utilizará un pliegue por la
izquierda sobre esa lista y generará una pila con un único elemento, como
<code class="docutils literal notranslate"><span class="pre">[-4]</span></code>. Tomará ese único elemento de la lista y ese será nuestro resultado
final.</p>
<p>Aquí tienes el esqueleto de esta función:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">solveRPN</span> <span class="n">expression</span> <span class="ow">=</span> <span class="n">head</span> <span class="p">(</span><span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">words</span> <span class="n">expression</span><span class="p">))</span>
    <span class="kr">where</span>   <span class="n">foldingFunction</span> <span class="n">stack</span> <span class="n">item</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Tomamos una expresión y la convertimos en una lista de elementos. Luego
plegamos una función sobre esta lista. Ten en cuenta que <code class="docutils literal notranslate"><span class="pre">[]</span></code> representa es
acumulador inicial. Dicho acumulador es nuestra pila, así que <code class="docutils literal notranslate"><span class="pre">[]</span></code>
representa la pila vacía con la que comenzamos. Luego de obtener la pila final
que contiene un único elemento, llamamos a <code class="docutils literal notranslate"><span class="pre">head</span></code> sobre esa lista para
extraer el elemento y aplicamos <code class="docutils literal notranslate"><span class="pre">read</span></code>.</p>
<p>Solo nos queda implementar la función de pliegue que tomará una pila, como
<code class="docutils literal notranslate"><span class="pre">[4,10]</span></code> y un elemento, como <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code> y devolverá una nueva pila
<code class="docutils literal notranslate"><span class="pre">[4,10,3]</span></code>. Si la pila es <code class="docutils literal notranslate"><span class="pre">[4,10]</span></code> y el elemento es <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code>, entonces
tenemos que devolver <code class="docutils literal notranslate"><span class="pre">[40]</span></code>. Pero antes, vamos a transformar nuestra función
al <a class="reference internal" href="ordensuperior.html#estilolibrepuntos"><span class="std std-ref">estilo libre de puntos</span></a> ya que tiene muchos
paréntesis y me está dando grima.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">solveRPN</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="kr">where</span>   <span class="n">foldingFunction</span> <span class="n">stack</span> <span class="n">item</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Ahí lo tienes. Mucho mejor. Como vemos, la función de pliegue tomará una pila
y un elemento y devolverá una nueva pila. Utilizaremos ajuste de patrones para
obtener los elementos de la cima de la pila y para obtener los operadores,
como <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">&quot;-&quot;</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">solveRPN</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">solveRPN</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="kr">where</span>   <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="kt">:</span><span class="n">xs</span>
</pre></div>
</div>
<p>Hemos utilizado cuatro patrones. Los patrones se ajustarán de arriba a abajo.
Primero, la función de pliegue verá si el elemento actual es <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code>. Si lo
es, tomará una lista como podría ser <code class="docutils literal notranslate"><span class="pre">[3,4,9,3]</span></code> y llamará a sus dos
primeros elementos <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> respectivamente. En este caso, <code class="docutils literal notranslate"><span class="pre">x``sería</span>
<span class="pre">``3</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> sería <code class="docutils literal notranslate"><span class="pre">4</span></code>. <code class="docutils literal notranslate"><span class="pre">ys</span></code> sería <code class="docutils literal notranslate"><span class="pre">[9,3]</span></code>. Devolverá una lista como
<code class="docutils literal notranslate"><span class="pre">ys</span></code>, solo que tendrá <code class="docutils literal notranslate"><span class="pre">x</span></code> por <code class="docutils literal notranslate"><span class="pre">y</span></code> como cabeza. Con esto retiramos los
dos elementos superiores de la pila, los multiplicamos y apilamos el resultado
de nuevo en la pila. Si el elemento no es <code class="docutils literal notranslate"><span class="pre">&quot;*&quot;</span></code>, el ajuste de patrones
fallará y continuará con <code class="docutils literal notranslate"><span class="pre">&quot;+&quot;</span></code>, y así sucesivamente.</p>
<p>Si el elemento no es ninguno de los operadores, asumimos que es una cadena que
representa un número. Simplemente llamamos a <code class="docutils literal notranslate"><span class="pre">read</span></code> sobre esa esa cadena
para obtener el número y devolver la misma pila pero con este número en la
cima.</p>
<p>¡Y eso es todo! Fíjate que hemos añadido una restricción de clase extra
(<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">a</span></code>) en la declaración de la función, ya que llamamos a <code class="docutils literal notranslate"><span class="pre">read</span></code> sobre
la cadena para obtener un número. De esta forma la declaración dice que puede
devolver cualquier tipo que forme parte de las clases de tipos <code class="docutils literal notranslate"><span class="pre">Num</span></code> y
<code class="docutils literal notranslate"><span class="pre">Read</span></code> (como <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Float</span></code>, etc.).</p>
<p>Para la lista de elementos <code class="docutils literal notranslate"><span class="pre">[&quot;2&quot;,</span> <span class="pre">&quot;3&quot;,</span> <span class="pre">&quot;+&quot;]</span></code>, nuestra función empezará
plegando la lista desde la izquierda. La pila inicial será <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Llamará a
la función de pliegue con <code class="docutils literal notranslate"><span class="pre">[]</span></code> como pila (acumulador) y <code class="docutils literal notranslate"><span class="pre">&quot;2&quot;</span></code> como
elemento. Como dicho elemento no es un operador, utilizará <code class="docutils literal notranslate"><span class="pre">read</span></code> y añadirá
el número al inicio de <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Así que ahora la pila es <code class="docutils literal notranslate"><span class="pre">[2]</span></code> y la función
de pliegue será llamada con <code class="docutils literal notranslate"><span class="pre">[2]</span></code> como pila y <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code> como elemento,
produciendo una nueva pila <code class="docutils literal notranslate"><span class="pre">[3,2]</span></code>. Luego, será llamada por tercera vez con
<code class="docutils literal notranslate"><span class="pre">[3,2]</span></code> como pila y con <code class="docutils literal notranslate"><span class="pre">&quot;+&quot;</span></code> como elemento. Esto hará que los dos números
sean retirados de la pila, se sumen, y que el resultado sea apilado de nuevo.
La pila final es <code class="docutils literal notranslate"><span class="pre">[5]</span></code>, que contiene el número que devolveremos.</p>
<p>Vamos a jugar con esta función:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;10 4 3 + 2 * -&quot;</span>
<span class="o">-</span><span class="mi">4</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;2 3 +&quot;</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;90 34 12 33 55 66 + * - +&quot;</span>
<span class="o">-</span><span class="mi">3947</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;90 34 12 33 55 66 + * - + -&quot;</span>
<span class="mi">4037</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;90 34 12 33 55 66 + * - + -&quot;</span>
<span class="mi">4037</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;90 3 -&quot;</span>
<span class="mi">87</span>
</pre></div>
</div>
<p>¡Genial, funciona! Un detalle de esta función es que se puede modificar
fácilmente para que soporte nuevos operadores. No tienen porque ser operadores
binarios. Por ejemplo, podemos crear el operador <code class="docutils literal notranslate"><span class="pre">&quot;log&quot;</span></code> que solo retira un
número de la pila y apila su logaritmo. También podemos crear operadores
ternarios que retiren tres números de la pila y apilen un resultado, o
operadores como <code class="docutils literal notranslate"><span class="pre">sum</span></code> que retiraría todos los números de la pila y
devolvería su suma.</p>
<p>Vamos a modificar nuestra función para que acepte unos cuantos operadores más.
Para simplificar, vamos a cambiar la declaración de tipo de forma que devuelva
un número del tipo <code class="docutils literal notranslate"><span class="pre">Float</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">solveRPN</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="kr">where</span>   <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;/&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;^&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">**</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
            <span class="n">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="s">&quot;ln&quot;</span> <span class="ow">=</span> <span class="n">log</span> <span class="n">x</span><span class="kt">:</span><span class="n">xs</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="s">&quot;sum&quot;</span> <span class="ow">=</span> <span class="p">[</span><span class="n">sum</span> <span class="n">xs</span><span class="p">]</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="kt">:</span><span class="n">xs</span>
</pre></div>
</div>
<p>¡Perfecto! “”/”” es la división y <code class="docutils literal notranslate"><span class="pre">**</span></code> la potencia de número en coma
flotante. Con el operador logarítmico, usamos el ajuste de
patrones para obtener un solo elemento y el resto de la lista, ya que solo
necesitamos un elemento para obtener su logaritmo neperiano. Con el operador
<code class="docutils literal notranslate"><span class="pre">sum</span></code>, devolvemos una pila con un solo elemento, el cual es la suma de toda
la pila.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;2.7 ln&quot;</span>
<span class="mf">0.9932518</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;10 10 10 10 sum 4 /&quot;</span>
<span class="mf">10.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;10 10 10 10 10 sum 4 /&quot;</span>
<span class="mf">12.5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;10 2 ^&quot;</span>
<span class="mf">100.0</span>
</pre></div>
</div>
<p>Fíjate que podemos incluir números en coma flotante en nuestra expresión
porque <code class="docutils literal notranslate"><span class="pre">read</span></code> sabe como leerlos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">solveRPN</span> <span class="s">&quot;43.2425 0.5 ^&quot;</span>
<span class="mf">6.575903</span>
</pre></div>
</div>
<p>En mi opinión, crear una función que calcule expresiones arbitrarias RPN en
coma flotante y tenga la opción de ser fácilmente extensible en solo 10 líneas
es bastante impresionante.</p>
<p>Una cosa a tener en cuenta es que esta función no es tolerante a fallos.
Cuando se da una entrada que no tiene sentido, simplemente bloqueará todo.
Crearemos una versión tolerante a fallos de esta función con una declaración
de tipo como <code class="docutils literal notranslate"><span class="pre">solveRPN</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">Float</span></code> una vez conozcamos las
mónadas (no dan miedo, créeme). Podríamos crear una función como esta ahora
mismo, pero sería un poco pesado ya que requeriría un montón de comprobaciones
para <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> en cada paso. Si crees que puede ser un reto, puedes
continuar e intentarla crearla tu mismo. Un consejo: puedes utilizar <code class="docutils literal notranslate"><span class="pre">reads</span></code>
para ver si una lectura a sido correcta o no.</p>
</div>
<div class="section" id="de-heathrow-a-londres">
<h2>De Heathrow a Londres<a class="headerlink" href="#de-heathrow-a-londres" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Nuestro siguiente problema es este: tu avión acaba de aterrizar en Inglaterra
y alquilas un coche. Tienes una entrevista dentro de nada y tienes que llegar
desde el aeropuerto de Heathrow a Londres tan pronto como puedas (¡Pero si
arriesgar tu vida!).</p>
<p>Existen dos vías principales de Heathrow a Londres y hay cierto número
de carreteras regionales que unen ambas vías. Debes encontrar la ruta óptima
que te lleve a Londres tan rápido como puedas. Empiezas en el lado izquierdo y
puedes o bien cruzar a la otra vía o continuar recto.</p>
<img alt="Heathrow - Londres" class="align-center" src="../_images/roads.png" />
<p>Como puedes ver en la imagen, la ruta más corta de Heathrow a Londres en este
caso es empezando en la vía principal B, cruzamos y continuamos por A,
cruzamos otra vez y continuamos dos veces más por B. Si tomamos esta ruta,
tardaremos 75 minutos en llegar. Si tomamos cualquier otra ruta, tardaríamos
más en llegar.</p>
<p>Nuestro trabajo es crear un programa que tome una entrada que represente un
sistema de caminos y muestre cual es la ruta más corta. Así se vería la
entrada para este caso.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>50
10
30
5
90
20
40
2
25
10
8
0
</pre></div>
</div>
<p>Para analizar mentalmente el fichero de entrada, separa los números en grupos
de tres. Cada grupo se compone de la vía A, la vía B y un camino que los
une. Para que encajen perfectamente en grupos de tres, diremos que hay un
último camino de cruce que recorrerlo toma cero minutos. Esto se debe a que
no nos importa a que parte de Londres lleguemos, mientras lleguemos a Londres.</p>
<p>De la misma forma que solucionamos el problema de la calculadora RPN, este
problema lo resolveremos en tres pasos:</p>
<blockquote>
<div><ul class="simple">
<li><p>Olvida Haskell por un instante y piensa como solucionarías el problema a
mano.</p></li>
<li><p>Piensa como vamos a representar la información en Haskell.</p></li>
<li><p>Encuentra un modo de operar sobre esta información en Haskell que produzca
una solución.</p></li>
</ul>
</div></blockquote>
<p>En el problema de la calculadora, primero nos dimos cuenta de que cuando
calculábamos una expresión a mano, manteníamos una especie de pile en nuestra
cabeza y recorríamos la expresión elemento a elemento. Decidimos utilizar una
lista de cadenas para representar la expresión. Para terminar, utilizamos un
pliegue por la izquierda para recorrer la lista de cadenas mientras
manteníamos un pila que producía una solución.</p>
<p>Vale ¿Cómo encontraríamos la ruta más corta de Heathrow a Londres a mano?
Bueno, podemos simplemente ver todas las rutas y suponer cual será la más
corta y seguramente sea verdad. Esa solución funciona bien para problemas
pequeños, pero ¿Qué pasaría si las vías tuvieran más de 10.000 secciones? Ni
siquiera podríamos dar una solución optima.</p>
<p>Así que no es una buena solución. Aquí tienes una imagen simplificada del
sistema de caminos:</p>
<img alt="Caminos" class="align-center" src="../_images/roads_simple.png" />
<p>Esta bien ¿Puedes decir cual sería la ruta más corta hasta la primera
intersección (El primer punto en A, marcado como A1) de la vía A? Es bastante
trivial. Simplemente vemos si es mas corto ir recto desde A o si es más corto
partir desde B y luego cruzar a la otra vía. Obviamente, es más corto ir por B
y luego cruzar ya que toma 40 minutos, mientras que ir directamente desde A
toma 50 minutos ¿Qué pasaría si quisiéramos ir a B1? Lo mismo. Vemos que es
mucho más corto ir directamente desde B (10 minutos), ya que ir desde A y
luego cruzan nos llevaría un total de 80 minutos.</p>
<p>Ahora sabemos la ruta más corta hasta A1 (ir desde la vía B y cruzar, diríamos
algo como que es <code class="docutils literal notranslate"><span class="pre">B,</span> <span class="pre">C</span></code> con un coste de 40) y sabemos cual es la ruta más
corta hasta B1 (ir directamente desde la vía B, simplemente <code class="docutils literal notranslate"><span class="pre">B</span></code> con coste
10) ¿Nos ayudaría en algo esta información si queremos saber la ruta más corta
hasta la próxima intersección de ambas vías principales? ¡Por supuesto que sí!</p>
<p>Vamos a ver cual sería la ruta más corta hasta A2. Para llegar a A2, o bien
iríamos directamente desde A1 o bien partiríamos desde B1, continuaríamos
adelante y luego cruzaríamos (recuerda, solo podemos ir adelante o cruzar al
otro lado). Y como sabemos el coste de A1 y B1, podemos encontrar fácilmente
cual será la ruta más corta de A1 a A2. Costaría 40 minutos llegar a A1 y
luego otros 5 minutos en llegar desde A1 a A2, así que el resultado sería <code class="docutils literal notranslate"><span class="pre">B,</span>
<span class="pre">C,</span> <span class="pre">A</span></code> con un coste de 45 minutos. Solo cuesta 10 minutos llegar hasta B1,
pero luego costaría otros 110 minutos más para llegar hasta A2. Así que, de
forma bastante obvia, la forma más rápida de llegar a A2 es <code class="docutils literal notranslate"><span class="pre">B,</span> <span class="pre">C,</span> <span class="pre">A</span></code>. Del
mismo modo, la forma más rápida de llegar hasta B2 es continuar por A1 y luego
cruzar.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>¿Qué pasaría si para llegar a A2 primero cruzamos desde B1 y luego
continuamos adelante? Bien, ya hemos cubierto la posibilidad de
cruzar de B1 a A1 cuando buscábamos la mejor forma de llegar hasta
A1, así que no tenemos que tomar en cuenta esta posibilidad en el
siguiente paso.</p>
</div>
<p>Ahora que tenemos la mejor ruta para llegar hasta A2 y B2, podemos repetir
este proceso indefinidamente hasta que alcancemos el final. Una vez tengamos
las mejores rutas para llegar a A4 y B4, la mejor será la ruta óptima.</p>
<p>En el segundo paso básicamente hemos repetido lo que hicimos en el primer
paso, solo que tuvimos en cuenta cuales fueron las mejores rutas para llegar a
A y B. También podríamos decir que tomamos en cuenta las mejores rutas para
llegar hasta A y B en el primer paso, solo que ambas rutas tendrían coste 0.</p>
<p>Así que en resumen, para obtener las mejor ruta ruta de Heathrow a Londres,
hacemos esto: primero vemos cual es la mejor ruta hasta el próximo cruce de la
vía principal A. Las dos opciones que tenemos son o bien ir directamente o
bien empezar en la vía opuesta, continuar adelante y luego cruzar. Memorizamos
la mejor ruta y el coste. Usamos el mismo método para ver cual es la mejor
ruta hasta el próximo cruce desde B y la memorizamos. Luego, vemos si la ruta
del siguiente cruce en A es mejor si la tomamos desde el cruce anterior en A o
desde el cruce anterior en B y luego cruzar. Memorizamos la mejor ruta y
hacemos lo mismo para la vía opuesta. Repetimos estos pasos hasta que
alcancemos el final. La mejor de las dos rutas resultantes será la ruta
óptima.</p>
<p>Básicamente lo que hacemos es mantener la mejor ruta por A y la mejor ruta por
B hasta que alcancemos el final, y la mejor de ambas es el resultado. Sabemos
como calcular la ruta más corta a mano. Si tuviéramos suficiente tiempo, papel
y lápiz, podríamos calcular la ruta más corta de un sistema de caminos con
cualquier número de secciones.</p>
<p>¡Siguiente paso! ¿Cómo representamos este sistema de caminos con los tipos de
datos de Haskell? Una forma es ver los puntos iniciales y las intersecciones
como nodos de un grafo que se conectan con otras intersecciones. Si imaginamos
que los nodos iniciales en realidad se conectan con cada otro nodo con un
camino, veríamos que cada nodo se conecta con el nodo del otro lado y con el
nodo siguiente del mismo lado. Exceptuando los nodos finales, que únicamente
se conectan con el nodo del otro lado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Node</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Road</span> <span class="kt">Road</span> <span class="o">|</span> <span class="kt">EndNode</span> <span class="kt">Road</span>
<span class="kr">data</span> <span class="kt">Road</span> <span class="ow">=</span> <span class="kt">Road</span> <span class="kt">Int</span> <span class="kt">Node</span>
</pre></div>
</div>
<p>Un nodo es o bien un nodo normal que contiene información acerca del camino
que lleva al otro nodo de la otra vía principal o del camino que lleva al
siguiente nodo, o bien un nodo final, que solo contiene información acerca del
camino que lleva al otro nodo de la otra vía principal. Un camino contiene la
información que indica lo que se tarda en recorrerlo y el nodo al que lleva.
Por ejemplo, la primera parte del camino de la vía A sería <code class="docutils literal notranslate"><span class="pre">Road</span> <span class="pre">50</span> <span class="pre">a1</span></code>
donde <code class="docutils literal notranslate"><span class="pre">a1</span></code> sería un nodo <code class="docutils literal notranslate"><span class="pre">Node</span> <span class="pre">x</span> <span class="pre">y</span></code>, donde <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code> serían los
caminos a B1 y a A2.</p>
<p>Otra forma de representar el sistema sería utilizando <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> para los
caminos que llevan al siguiente nodo. Cada nodo tendría un camino que llevara
a otro punto de la vía opuesta, pero solo los nodos que no están al final
tendrían un camino que les llevará adelante.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Node</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Road</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Road</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Road</span> <span class="ow">=</span> <span class="kt">Road</span> <span class="kt">Int</span> <span class="kt">Node</span>
</pre></div>
</div>
<p>Ambas son buenas formas de representar el sistema de caminos en Haskell y en
realidad podríamos resolver el problema usándolas, pero, quizá podemos
encontrar algo más simple. Si pensamos de nuevo en la forma de resolverlo a
mano, vemos que en realidad siempre comprobamos los tiempos de los tres
caminos de una sección a la vez: la parte del camino en la vía A, la parte
opuesta en B y la parte C, que conecta ambas entre sí. Cuando estábamos
buscando la ruta más corta entre A1 y B1, solo tuvimos que tratar con los
tiempos de las primeras tres partes, los cuales eran 50, 10 y 30 minutos. Nos
referiremos a esto como una sección. Así que el sistema de caminos que
utilizamos para este ejemplo puede representarse fácilmente como cuatro
secciones: <code class="docutils literal notranslate"><span class="pre">50,</span> <span class="pre">10,</span> <span class="pre">30</span></code>, <code class="docutils literal notranslate"><span class="pre">5,</span> <span class="pre">90,</span> <span class="pre">20</span></code>, <code class="docutils literal notranslate"><span class="pre">40,</span> <span class="pre">2,</span> <span class="pre">25</span></code> y <code class="docutils literal notranslate"><span class="pre">10,</span> <span class="pre">8,</span> <span class="pre">0</span></code>.</p>
<p>Siempre es bueno mantener nuestros tipos de datos tan simple como sea posible,
pero ¡No más simple!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Section</span> <span class="ow">=</span> <span class="kt">Section</span> <span class="p">{</span> <span class="n">getA</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">getB</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">getC</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">RoadSystem</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Section</span><span class="p">]</span>
</pre></div>
</div>
<p>¡Es casi perfecto! Es simple y tengo la sensación de que va a funcionar
perfectamente para la implementación de nuestra solución. <code class="docutils literal notranslate"><span class="pre">Section</span></code> es un
tipo de dato algebraico simple que contiene tres enteros para los tiempos de
los tres caminos de una sección. También hemos utilizado un sinónimo de tipo
que dice que <code class="docutils literal notranslate"><span class="pre">RoadSystem</span></code> es una lista de secciones.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>También podríamos haber utilizado una tripla como
<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code> para representar una sección. Está bien utilizar
tuplas en lugar de tipos de datos algebraicos propios para cosas
pequeñas y puntuales, pero normalmente es mejor crear nuevos tipos
para cosas como esta. De esta forma el sistema de tipos tiene más
infomación acerca de que es cada cosa. Podemos utilizar
<code class="docutils literal notranslate"><span class="pre">(Int,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code> para representar una sección de un camino o para
representar un vector en un espacio tridimensional y podemos
trabajar con ambos a la vez, pero de este modo podríamos acabar
mezclandolos entre sí. Si utilizamos los tipos <code class="docutils literal notranslate"><span class="pre">Section</span></code> y
<code class="docutils literal notranslate"><span class="pre">Vector</span></code>, no podremos, ni si quiera accidentalmente, sumar un
vector a una sección.</p>
</div>
<p>Ahora el sistema de caminos de Heathrow a Londres se puede representar así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">heathrowToLondon</span> <span class="ow">::</span> <span class="kt">RoadSystem</span>
<span class="nf">heathrowToLondon</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Section</span> <span class="mi">50</span> <span class="mi">10</span> <span class="mi">30</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">5</span> <span class="mi">90</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">40</span> <span class="mi">2</span> <span class="mi">25</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">10</span> <span class="mi">8</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Todo lo que nos queda por hacer es implementar la solución a la que llegamos
con Haskell ¿Cual sería la declaración de tipo de una función que calcule el
camino más corto para cualquier sistema de caminos? Tendría que tomar un
sistema de caminos y devolver una ruta. Vamos a representar una ruta con una
lista también. Crearemos el tipo <code class="docutils literal notranslate"><span class="pre">Label</span></code> que será una simple enumeración
cuyos valores serán <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code> o <code class="docutils literal notranslate"><span class="pre">C</span></code>. También crearemos un sinónimo de
tipo: <code class="docutils literal notranslate"><span class="pre">Path</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Label</span> <span class="ow">=</span> <span class="kt">A</span> <span class="o">|</span> <span class="kt">B</span> <span class="o">|</span> <span class="kt">C</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Path</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Label</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
</pre></div>
</div>
<p>Llamaremos a nuestra función <code class="docutils literal notranslate"><span class="pre">optimalPath</span></code> y tendrá una declaración de tipo
como <code class="docutils literal notranslate"><span class="pre">optimalPath</span> <span class="pre">::</span> <span class="pre">RoadSystem</span> <span class="pre">-&gt;</span> <span class="pre">Path</span></code>. Si es llamada con el sistema
<code class="docutils literal notranslate"><span class="pre">heathrowToLondon</span></code> deberá devolver una ruta como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">A</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">8</span><span class="p">)]</span>
</pre></div>
</div>
<p>Vamos a tener que recorrer la lista de secciones de izquierda a derecha y
mantener un camino óptimo hasta A y un camino óptimo hasta B conforme vayamos
avanzando. Acumularemos la mejor ruta conforme vayamos avanzando, de izquierda
a derecha ¿A qué te suena esto? ¡Ding, ding, ding! ¡Correcto, es un pliegue
por la izquierda!</p>
<p>Cuando resolvimos el problema a mano, había un paso que repetíamos una y otra
vez. Requería comprobar el camino óptimo de A y B hasta el momento, además
de la sección actual para producir un nuevo par de rutas óptimas hasta A y B.
Por ejemplo, al principio la rutas óptimas son <code class="docutils literal notranslate"><span class="pre">[]</span></code> y <code class="docutils literal notranslate"><span class="pre">[]</span></code> para A y B.
Analizamos la sección <code class="docutils literal notranslate"><span class="pre">Section</span> <span class="pre">50</span> <span class="pre">10</span> <span class="pre">30</span></code> y concluimos que la nueva ruta
óptima para A es <code class="docutils literal notranslate"><span class="pre">[(B,10),(C,30)]</span></code> y que la nueva ruta óptima para B es
<code class="docutils literal notranslate"><span class="pre">[(B,10)]</span></code>. Si vemos este paso como una función, tomaría un par de rutas y
una sección y produciría un nuevo par de rutas. El tipo sería
<code class="docutils literal notranslate"><span class="pre">(Path,</span> <span class="pre">Path)</span> <span class="pre">-&gt;</span> <span class="pre">Section</span> <span class="pre">-&gt;</span> <span class="pre">(Path,</span> <span class="pre">Path)</span></code>. Vamos a seguir adelante e
implementar esta función que parece que será útil.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Será util porque <code class="docutils literal notranslate"><span class="pre">(Path,</span> <span class="pre">Path)</span> <span class="pre">-&gt;</span> <span class="pre">Section</span> <span class="pre">-&gt;</span> <span class="pre">(Path,</span> <span class="pre">Path)</span></code> puede
ser utilizado como una función binaría para un pliegue por la
derecha, el cual tiene un tipo <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>.</p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">roadStep</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Path</span><span class="p">,</span> <span class="kt">Path</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Section</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Path</span><span class="p">,</span> <span class="kt">Path</span><span class="p">)</span>
<span class="nf">roadStep</span> <span class="p">(</span><span class="n">pathA</span><span class="p">,</span> <span class="n">pathB</span><span class="p">)</span> <span class="p">(</span><span class="kt">Section</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">priceA</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">pathA</span>
        <span class="n">priceB</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">pathB</span>
        <span class="n">forwardPriceToA</span> <span class="ow">=</span> <span class="n">priceA</span> <span class="o">+</span> <span class="n">a</span>
        <span class="n">crossPriceToA</span> <span class="ow">=</span> <span class="n">priceB</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">forwardPriceToB</span> <span class="ow">=</span> <span class="n">priceB</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">crossPriceToB</span> <span class="ow">=</span> <span class="n">priceA</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">newPathToA</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">forwardPriceToA</span> <span class="o">&lt;=</span> <span class="n">crossPriceToA</span>
                        <span class="kr">then</span> <span class="p">(</span><span class="kt">A</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="kt">:</span><span class="n">pathA</span>
                        <span class="kr">else</span> <span class="p">(</span><span class="kt">C</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="kt">B</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="kt">:</span><span class="n">pathB</span>
        <span class="n">newPathToB</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">forwardPriceToB</span> <span class="o">&lt;=</span> <span class="n">crossPriceToB</span>
                        <span class="kr">then</span> <span class="p">(</span><span class="kt">B</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="kt">:</span><span class="n">pathB</span>
                        <span class="kr">else</span> <span class="p">(</span><span class="kt">C</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="kt">:</span><span class="n">pathA</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">newPathToA</span><span class="p">,</span> <span class="n">newPathToB</span><span class="p">)</span>
</pre></div>
</div>
<img alt="¡Este eres tú!" class="align-right" src="../_images/guycar.png" />
<p>¿Qué hace esto? Primero, calculamos el coste óptimo en la vía A basandonos
en el camino óptimo hasta el momento en A, y luego hacemos lo mismo para B.
Hacemos <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">$</span> <span class="pre">map</span> <span class="pre">snd</span> <span class="pre">pathA</span></code>, así que si <code class="docutils literal notranslate"><span class="pre">pathA</span></code> es algo como
<code class="docutils literal notranslate"><span class="pre">[(A,100),(C,20)]</span></code>, <code class="docutils literal notranslate"><span class="pre">priceA</span></code> será <code class="docutils literal notranslate"><span class="pre">120</span></code>. <code class="docutils literal notranslate"><span class="pre">forwardPriceToA</span></code> es el coste
de que tendría continuar hasta el siguiente cruce si fuéramos directamente
desde el cruce anterior en A. Es igual al coste anterior de A, más el coste
de la parte A de la sección actual. <code class="docutils literal notranslate"><span class="pre">crossPriceToA</span></code> es el coste que tendría
si fuéramos hasta el siguiente cruce de A partiendo de B y luego cruzáramos.
Este coste sería el coste óptimo de llegar al anterior cruce de B más el
coste de continuar por B más el coste de cruzar por C. Calculamos
<code class="docutils literal notranslate"><span class="pre">forwardPriceToB</span></code> y <code class="docutils literal notranslate"><span class="pre">crossPriceToB</span></code> de la misma forma.</p>
<p>Ahora que sabemos el mejor camino hasta A y B, solo tenemos que crear nuevas
rutas para llegar hasta la siguiente intersección de A y B basándonos en
estos. Si tardamos menos en llegar partiendo de A y continuando adelante,
establecemos <code class="docutils literal notranslate"><span class="pre">newPathToA</span></code> a <code class="docutils literal notranslate"><span class="pre">(A,a):pathA</span></code>. Básicamente añadimos <code class="docutils literal notranslate"><span class="pre">Label</span></code>
<code class="docutils literal notranslate"><span class="pre">A</span></code> y el coste de la sección <code class="docutils literal notranslate"><span class="pre">a</span></code> al camino óptimo de A hasta el momento.
Dicho de otro modo, decimos que la mejor forma de llegar al siguiente cruce de
A es la ruta de llegar al cruce de A anterior y luego continuando adelante
por la vía A. Recuerda que es <code class="docutils literal notranslate"><span class="pre">A</span></code> es una simple etiqueta, mientras que <code class="docutils literal notranslate"><span class="pre">a</span></code>
tiene el tipo <code class="docutils literal notranslate"><span class="pre">Int</span></code> ¿Por qué añadimos el nuevo elemento al inicio en lugar
de hacer algo como <code class="docutils literal notranslate"><span class="pre">pathA</span> <span class="pre">++</span> <span class="pre">[(A,a)]</span></code>? Bueno, añadir un elemento al
principio de una lista es mucho más rápido que añadirlo al final. De este modo
la ruta estará invertida cuando terminemos el pliegue con esta función, pero
podemos invertirla de nuevo luego. Si tardamos menos en llegar al siguiente
cruce de A partiendo del cruce anterior en B y luego cruzando, entonces
<code class="docutils literal notranslate"><span class="pre">newPathToB</span></code> será la ruta anterior por B, continuar adelante y cruzar a A.
Hacemos lo mismo para <code class="docutils literal notranslate"><span class="pre">newPathToB</span></code>, solo que al revés.</p>
<p>Terminamos devolviendo <code class="docutils literal notranslate"><span class="pre">newPathToA</span></code> y <code class="docutils literal notranslate"><span class="pre">newPathToB</span></code> en una tupla.</p>
<p>Vamos a ejecutar esta función con la primera sección de <code class="docutils literal notranslate"><span class="pre">heathrowToLondon</span></code>.
Como es la primera sección, las mejores rutas hasta A y B serán un par de
listas vacías.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">roadStep</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">head</span> <span class="n">heathrowToLondon</span><span class="p">)</span>
<span class="p">([(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">)])</span>
</pre></div>
</div>
<p>Recuerda que las rutas están invertidas, así que léelas de derecha a
izquierda. Podemos ver que la mejor ruta hasta el siguiente cruce en A es
empezando por B y luego cruzar hasta A y que la mejor ruta hasta B es
simplemente continuando adelante a partir de B.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando hacemos <code class="docutils literal notranslate"><span class="pre">priceA</span> <span class="pre">=</span> <span class="pre">sum</span> <span class="pre">$</span> <span class="pre">map</span> <span class="pre">snd</span> <span class="pre">pathA</span></code>, estamos calculando
el coste de la ruta en cada paso. No tendríamos que hacerlo si
implementamos <code class="docutils literal notranslate"><span class="pre">roadStep</span></code> como una función
<code class="docutils literal notranslate"><span class="pre">(Path,</span> <span class="pre">Path,</span> <span class="pre">Int,</span> <span class="pre">Int)</span> <span class="pre">-&gt;</span> <span class="pre">Section</span> <span class="pre">-&gt;</span> <span class="pre">(Path,</span> <span class="pre">Path,</span> <span class="pre">Int,</span> <span class="pre">Int)</span></code>
donde los enteros representan el coste de A y B.</p>
</div>
<p>Ahora que tenemos una función que toma un par de rutas y una sección y produce
una nueva ruta óptima, podemos hacer fácilmente un pliegue por la izquierda
de la lista de secciones. <code class="docutils literal notranslate"><span class="pre">roadStep</span></code> se llamará con <code class="docutils literal notranslate"><span class="pre">([],[])</span></code> y la primera
sección y devolverá una dupla con las rutas óptimas para esa sección. Luego
será llamada con esa dupla de rutas y la sección siguiente y así
sucesivamente. Cuando hayamos recorrido todas las secciones, tendremos una
dupla con las rutas óptimas, y la mas corta será nuestra respuesta. Tendiendo
esto en cuenta, podemos implementar <code class="docutils literal notranslate"><span class="pre">optimalPath</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">optimalPath</span> <span class="ow">::</span> <span class="kt">RoadSystem</span> <span class="ow">-&gt;</span> <span class="kt">Path</span>
<span class="nf">optimalPath</span> <span class="n">roadSystem</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">bestAPath</span><span class="p">,</span> <span class="n">bestBPath</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">roadStep</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span> <span class="n">roadSystem</span>
    <span class="kr">in</span>  <span class="kr">if</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">snd</span> <span class="n">bestAPath</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">snd</span> <span class="n">bestBPath</span><span class="p">)</span>
            <span class="kr">then</span> <span class="n">reverse</span> <span class="n">bestAPath</span>
            <span class="kr">else</span> <span class="n">reverse</span> <span class="n">bestBPath</span>
</pre></div>
</div>
<p>Plegamos <code class="docutils literal notranslate"><span class="pre">roadSystem</span></code> por la izquierda (recuerda, es una lista de secciones)
con un acumulador inicial que es una dupla de listas vacías. El resultado de
ese pliegue es una dupla de rutas, así que usamos un ajuste de patrones sobre
ella y obtenemos las rutas. Luego, comprobamos cual de esas dos es mejor y
la devolvemos. Antes de devolverla, la invertimos, ya que las rutas óptimas
están al revés debido a que decidimos añadir las secciones al principio de las
listas.</p>
<p>¡Vamos a probarla!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">optimalPath</span> <span class="n">heathrowToLondon</span>
<span class="p">[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">A</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<p>¡Este es el resultado que se supone que debíamos obtener! ¡Genial! Se
diferencia un poco del resultado que esperábamos ya que hay un paso <code class="docutils literal notranslate"><span class="pre">(C,0)</span></code>
al final, lo que significa que tomamos un cruce cuando ya estamos en Londres,
pero como tomar dicho camino no cuesta nada, sigue siendo la solución
correcta.</p>
<p>Ahora que ya tenemos la función que encuentra la ruta óptima, solo tenemos
que leer la representación textual del sistema de caminos por la entrada
estándar, convertirlo en el tipo <code class="docutils literal notranslate"><span class="pre">RoadSystem</span></code>, ejecutar <code class="docutils literal notranslate"><span class="pre">optimalPath</span></code>
sobre él y mostrar el resultado.</p>
<p>Antes de nada, vamos a crear una función que tome una lista y la divida en
grupos del mismo tamaño. La llamaremos <code class="docutils literal notranslate"><span class="pre">groupsOf</span></code>. Con un parámetro como
<code class="docutils literal notranslate"><span class="pre">[1..10]</span></code>, <code class="docutils literal notranslate"><span class="pre">groupsOf</span> <span class="pre">3</span></code> deberá devolver
<code class="docutils literal notranslate"><span class="pre">[[1,2,3],[4,5,6],[7,8,9],[10]]</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">groupsOf</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">groupsOf</span> <span class="mi">0</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">undefined</span>
<span class="nf">groupsOf</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">groupsOf</span> <span class="n">n</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">n</span> <span class="n">xs</span> <span class="kt">:</span> <span class="n">groupsOf</span> <span class="n">n</span> <span class="p">(</span><span class="n">drop</span> <span class="n">n</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Una función recursiva estándar. Para un <code class="docutils literal notranslate"><span class="pre">xs</span></code> de <code class="docutils literal notranslate"><span class="pre">[1..10]</span></code> y un <code class="docutils literal notranslate"><span class="pre">n</span></code> de
<code class="docutils literal notranslate"><span class="pre">3</span></code>, equivale a <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span> <span class="pre">:</span> <span class="pre">groupsOf</span> <span class="pre">3</span> <span class="pre">[4,5,6,7,8,9,10]</span></code>. Cuando la
recursión termina, obtenemos una lista de grupos de tres elementos. Y aquí
esta la función <code class="docutils literal notranslate"><span class="pre">main</span></code>, la cual leer desde la entrada estándar, crea
un <code class="docutils literal notranslate"><span class="pre">RoadSystem</span></code> y muestra la ruta más corta:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
    <span class="kr">let</span> <span class="n">threes</span> <span class="ow">=</span> <span class="n">groupsOf</span> <span class="mi">3</span> <span class="p">(</span><span class="n">map</span> <span class="n">read</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">contents</span><span class="p">)</span>
        <span class="n">roadSystem</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Section</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="n">threes</span>
        <span class="n">path</span> <span class="ow">=</span> <span class="n">optimalPath</span> <span class="n">roadSystem</span>
        <span class="n">pathString</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">show</span> <span class="o">.</span> <span class="n">fst</span><span class="p">)</span> <span class="n">path</span>
        <span class="n">pathPrice</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">path</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The best path to take is: &quot;</span> <span class="o">++</span> <span class="n">pathString</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The price is: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">pathPrice</span>
</pre></div>
</div>
<p>Primero, obtenemos todos los contenidos de la entrada estándar. Luego llamamos
a <code class="docutils literal notranslate"><span class="pre">lines</span></code> con los contenidos para convertir algo como <code class="docutils literal notranslate"><span class="pre">&quot;50\n10\n30\n...</span></code>
en <code class="docutils literal notranslate"><span class="pre">[&quot;50&quot;,&quot;10&quot;,&quot;30&quot;...</span></code> y luego mapeamos <code class="docutils literal notranslate"><span class="pre">read</span></code> sobre ella para obtener
una lista de números. También llamamos a <code class="docutils literal notranslate"><span class="pre">groupsOf</span> <span class="pre">3</span></code> sobre ella de forma
que obtengamos una lista de listas de longitud tres. Mapeamos la función
lambda <code class="docutils literal notranslate"><span class="pre">(\[a,b,c]</span> <span class="pre">-&gt;</span> <span class="pre">Section</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c)</span></code> sobre esta lista de listas. Como puedes
ver, esta función lambda toma una lista de tamaño tres y devuelve una sección.
Así que <code class="docutils literal notranslate"><span class="pre">roadSystem</span></code> es nuestro sistema de caminos e incluso tiene el
tipo correcto, <code class="docutils literal notranslate"><span class="pre">RoadSystem</span></code> (o <code class="docutils literal notranslate"><span class="pre">[Section]</span></code>). Llamamos <code class="docutils literal notranslate"><span class="pre">optimalPath</span></code>
sobre éste y mostramos la ruta y el coste de la ruta óptima que obtenemos.</p>
<p>Guardamos el siguiente texto:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>50
10
30
5
90
20
40
2
25
10
8
0
</pre></div>
</div>
<p>En un fichero llamado <code class="docutils literal notranslate"><span class="pre">paths.txt</span></code> y luego se lo pasamos a nuestro programa.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cat paths.txt | runhaskell heathrow.hs
The best path to take is: BCACBBC
The price is: 75
</pre></div>
</div>
<p>¡Funciona perfecto! Puedes usar tu conocimiento del módulo <code class="docutils literal notranslate"><span class="pre">Data.Random</span></code>
para generar un sistema de caminos mucho más grande, que luego podrás pasar a
nuestro programa de la misma forma que hemos hecho. Si obtienes errores de
desbordamiento de pila, intenta usar <code class="docutils literal notranslate"><span class="pre">foldl'</span></code> en lugar <code class="docutils literal notranslate"><span class="pre">foldl</span></code>, ya que
<code class="docutils literal notranslate"><span class="pre">foldl'</span></code> es estricto.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="funtores.html" title="Funtores, funtores aplicativos y monoides"
             >siguiente</a></li>
        <li class="right" >
          <a href="entradasalida.html" title="Entrada y salida"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>