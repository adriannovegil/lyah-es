
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Módulos &#8212; documentación de ¡Aprende Haskell por el bien de todos! - 0.1</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Creando nuestros propios tipos y clases de tipos" href="clasesdetipos.html" />
    <link rel="prev" title="Funciones de orden superior" href="ordensuperior.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="clasesdetipos.html" title="Creando nuestros propios tipos y clases de tipos"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="ordensuperior.html" title="Funciones de orden superior"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="modulos">
<h1>Módulos<a class="headerlink" href="#modulos" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="cargando-modulos">
<h2>Cargando módulos<a class="headerlink" href="#cargando-modulos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Módulos" class="align-right" src="../_images/modules.png" />
<p>Un módulo de Haskell es una colección de funciones, tipos y clases de tipos
relacionadas entre sí. Un programa Haskell es una colección de módulos donde
el módulo principal carga otros módulos y utiliza las funciones definidas
en ellos para realizar algo. Tener el código divido en módulos tiene bastantes
ventajas. Si un módulo es lo suficientemente genérico, las funciones que son
exportadas pueden ser utilizadas en una gran variedad de programas. Si tu
código esta separado en módulos que no dependen mucho entre ellos (también
decimos que están débilmente acoplados), luego puedes reutilizarlos. Esto hace
que la tarea de programar sea más manejable teniendo ya que está todo dividido
en varias partes, cada una con su propio propósito.</p>
<p>La librería estándar de Haskell está dividida en varios módulos, cada uno de
ellos está formado por funciones y tipos que de alguna forma están
relacionados y sirven para propósito común. Existe un módulo para manipular
listas, un módulos para la programación concurrente, un módulo para trabajar
con números complejos, etc. Todas las funciones, tipos y clases de tipos con
las que hemos trabajado hasta ahora son parte del módulo <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, el cual
es importado por defecto. En este capítulo vamos a ver unos cuantos módulos
útiles y sus respectivas funciones. Pero primero, vamos a ver como se importan
los módulos.</p>
<p>La sintaxis para importar módulos en un script de Haskell es <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&lt;module</span>
<span class="pre">name&gt;</span></code>. Debe aparecer antes de que definamos cualquier función, así que las
importaciones de módulos suelen estar al principio de los ficheros. Un script
puede, obviamente, importar varios módulos. Simplemente hay que poner cada
<code class="docutils literal notranslate"><span class="pre">import</span></code> en líneas separadas. Vamos a importar el módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>, el
cual contiene un puñado de útiles funciones para trabajar con listas, y
utilizaremos una función que exporta dicho módulo para crear una función que
nos diga cuantos elementos únicos hay en una lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">numUniques</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">numUniques</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">nub</span>
</pre></div>
</div>
<p>Cuando realizamos <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Data.List</span></code>, todas las funciones que <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>
exporta están disponibles en el espacio de nombres global. Esto significa que
podemos acceder a todas estas funciones desde nuestro script. <code class="docutils literal notranslate"><span class="pre">nub</span></code> es una
función que está definida en <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> la cual toma una lista y devuelve
otra sin elementos duplicados. Componer <code class="docutils literal notranslate"><span class="pre">length</span></code> y <code class="docutils literal notranslate"><span class="pre">nub</span></code> haciendo
<code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">.</span> <span class="pre">nub</span></code> produce una función equivalente a <code class="docutils literal notranslate"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">length</span> <span class="pre">(nub</span> <span class="pre">xs)</span></code>.</p>
<p>También puedes importar módulos y utilizarlos cuando estamos trabajando con
GHCi. Si estamos en una sesión de GHCi y queremos utilizar las funciones que
exporta <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> hacemos esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
</pre></div>
</div>
<p>Si queremos cargar varios módulos dentro de GHCi no tenemos porque utilizar
<code class="docutils literal notranslate"><span class="pre">:m</span> <span class="pre">+</span></code> varias veces, simplemente podemos cargar varios módulos de golpe:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span>
</pre></div>
</div>
<p>Sin embargo, si ya has cargado un script que importa algún módulo, no tienes
que utilizar <code class="docutils literal notranslate"><span class="pre">:m</span> <span class="pre">+</span></code> para poder utilizarlo.</p>
<p>Si únicamente necesitas algunas funciones de un módulo, puedes seleccionarlas
para que solamente se importen dichas funciones. Si queremos importan solo las
funciones <code class="docutils literal notranslate"><span class="pre">nub</span></code> y <code class="docutils literal notranslate"><span class="pre">sort</span></code> de <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> hacemos lo siguiente:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">nub</span><span class="p">,</span> <span class="nf">sort</span><span class="p">)</span>
</pre></div>
</div>
<p>También puede importar todas las funciones de un módulo excepto algunas
seleccionadas. Normalmente esto se utiliza cuando tenemos varios módulos que
exportan una función con el mismo nombre y nos queremos librar de una de
ellas. Digamos que ya tenemos una función llamada <code class="docutils literal notranslate"><span class="pre">nub</span></code> y queremos importar
todas las funciones de <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> excepto la función <code class="docutils literal notranslate"><span class="pre">nub</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">nub</span><span class="p">)</span>
</pre></div>
</div>
<p>Otra forma de tratar con las colisiones de nombres es con las importaciones
cualificadas. El módulo <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>, que ofrece una estructura de datos para
buscar valores por clave, exporta un montón de funciones con nombres iguales
a las funciones de <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>, como <code class="docutils literal notranslate"><span class="pre">filter</span></code> o <code class="docutils literal notranslate"><span class="pre">null</span></code>. Así que cuando
importamos <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> y llamamos a <code class="docutils literal notranslate"><span class="pre">filter</span></code>, Haskell no sabe a que función
llamar. Aquí tienes como lo solucionamos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span>
</pre></div>
</div>
<p>De esta forma, si queremos referirnos a la función <code class="docutils literal notranslate"><span class="pre">filter</span></code> de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>,
tenemos que usar <code class="docutils literal notranslate"><span class="pre">Data.Map.filter</span></code>, mientras que si usamos simplemente
<code class="docutils literal notranslate"><span class="pre">filter</span></code> nos estamos referimos al filtro normal que todos conocemos.
Escribir <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> delante de todas las funciones es bastante pesado. Por
este motivo podemos renombrar una importación cualificada con algo un poco
más corto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
</pre></div>
</div>
<p>De esta forma, para referirnos a la función <code class="docutils literal notranslate"><span class="pre">filter</span></code> de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> solo
tenemos que usar <code class="docutils literal notranslate"><span class="pre">M.filter</span></code>.</p>
<p>Puede usar es útil
<a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/libraries/">referencia</a>  para
ver que módulos están en la librería estándar. Una forma de obtener
información acerca de Haskell es simplemente hacer click por la referencia
de la librería estándar y explorar sus módulos y sus funciones. También puedes
ver el código fuente de cada módulo. Leer el código fuente de algunos módulos
es una muy buena forma de aprender Haskell.</p>
<p>Puedes buscar funciones o buscar donde están localizadas usando
<a class="reference external" href="http://haskell.org/hoogle">Hoogle</a>. Es un increíble motor de búsqueda de
Haskell. Puedes buscar por nombre de función, nombre de módulo o incluso por
la definición de tipo de una función.</p>
</div>
<div class="section" id="data-list">
<h2>Data.List<a class="headerlink" href="#data-list" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> trata exclusivamente con listas, obviamente. Ofrece
funciones muy útiles para trabajar con listas. Ya hemos utilizado alguna de
estas funciones (como <code class="docutils literal notranslate"><span class="pre">map</span></code> y <code class="docutils literal notranslate"><span class="pre">filter</span></code>) ya que el módulo <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>
exporta algunas funciones de <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> por conveniencia. No hace falta
importar el módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> de forma cualificada porque no colisiona con
ningún nombre de <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> excepto por los que ya toma este de
<code class="docutils literal notranslate"><span class="pre">Data.List</span></code>. Vamos a dar un vistazo a algunas funciones que aún no hemos
conocido.</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">intersperse</span></code> toma un elemento y una lista pone ese elemento entre cada
par de elementos de la lista. Una demostración:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="sc">&#39;.&#39;</span> <span class="s">&quot;MONKEY&quot;</span>
<span class="s">&quot;M.O.N.K.E.Y&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">intercalate</span></code> toma una lista y una listas de listas. Inserta la primera
lista entre todas las demás lista, dando como resultado una única lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="s">&quot; &quot;</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there guys&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">transpose</span></code> transpone una lista de listas. Si miras la lista de listas
como una matriz 2D, las columnas se convierten en filas y viceversa.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;htg&quot;</span><span class="p">,</span><span class="s">&quot;ehu&quot;</span><span class="p">,</span><span class="s">&quot;yey&quot;</span><span class="p">,</span><span class="s">&quot;rs&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Supongamos que tenemos los polinomios <span class="math notranslate nohighlight">\(3x^{2} + 5x + 9\)</span>,
<span class="math notranslate nohighlight">\(10x^{3} + 9\)</span> y <span class="math notranslate nohighlight">\(8x^{3} + 5x^{2} + x - 1\)</span> y queremos sumarlos.
Podemos usar las listas <code class="docutils literal notranslate"><span class="pre">[0,3,5,9]</span></code>, <code class="docutils literal notranslate"><span class="pre">[10,0,0,9]</span></code> y <code class="docutils literal notranslate"><span class="pre">[8,5,1,-1]</span></code> para
representarlos en Haskell. Ahora, para sumarlos lo único que tenemos que
hacer es:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span>
</pre></div>
</div>
<p>Cuando transponemos estas tres listas, las potencias cúbicas están en la
primera fila, los cuadrados en la segunda fila, etc. Al mapear <code class="docutils literal notranslate"><span class="pre">sum</span></code>
sobre esto produce el resultado que buscamos.</p>
</li>
<li><img alt="Listas lego" class="align-right" src="../_images/legolists.png" />
<p><code class="docutils literal notranslate"><span class="pre">foldl'</span></code> y <code class="docutils literal notranslate"><span class="pre">foldl1'</span></code> son versiones estrictas de sus respectivas
versiones perezosas. Cuando usamos pliegues perezosos sobre listas
muy grandes solemos obtener errores de desbordamiento de pila. El motivo
de que suceda esto es que dada la naturaleza de los pliegues perezosos,
el valor acumulador no es actualizado hasta que se realiza el pliegue. Lo
que en realidad pasa es que el acumulador hace un especie de promesa de que
él calculará el valor cuando se le pide que produzca un resultado (a esto
también se le llama thunk). Esto pasa para cada valor intermedio del
acumulador y todos esos <em>thunks</em> desbordan la pila. Los pliegues estrictos
no sufren de este error ya que van calculando de verdad los valores
intermedios según recorren la lista en lugar de de llenar la pila con
<em>thunks</em>. Ya sabes, si alguna vez te encuentras con errores de desbordamiento
de pila mientras realizas un pliegue, prueba estas funciones.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">concat</span></code> aplana una lista de listas en una simple lista con los mismos
elementos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="s">&quot;car&quot;</span><span class="p">]</span>
<span class="s">&quot;foobarcar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Básicamente elimina un nivel de anidamiento. Si quieras aplanar
completamente <code class="docutils literal notranslate"><span class="pre">[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</span></code>, que es una lista de
listas de listas, tienes que aplanarla dos veces.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">concatMap</span></code> es lo mismo que hacer primero un mapeado con una función a
una lista y concatenar todos los resultados.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">and</span></code> toma una lista de booleanos y devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> solo si todos los
elementos de la lista son <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">or</span></code> es como <code class="docutils literal notranslate"><span class="pre">and</span></code> solo que devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> solo si existe algún
elemento <code class="docutils literal notranslate"><span class="pre">True</span></code> en la lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">any</span></code> y <code class="docutils literal notranslate"><span class="pre">all</span></code> toman un predicado y una lista y comprueban si el
predicado se satisface para algún o para todos los elementos
respectivamente. Normalmente usamos estas funciones en lugar de tener que
mapear un lista y luego usar <code class="docutils literal notranslate"><span class="pre">and</span></code> o <code class="docutils literal notranslate"><span class="pre">or</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">True</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">iterate</span></code> toma una función y un valor inicial. Aplica esa función al
valor inicial, luego aplica la función al resultado anterior, luego aplica
es misma función al resultado anterior otra vez, etc. Devuelve todos los
resultados en forma de lista infinita.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span> <span class="s">&quot;haha&quot;</span>
<span class="p">[</span><span class="s">&quot;haha&quot;</span><span class="p">,</span><span class="s">&quot;hahahaha&quot;</span><span class="p">,</span><span class="s">&quot;hahahahahaha&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">splitAt</span></code> toma un número y una lista. Luego divide la lista por el
índice indicado y devuelve una dupla con ambas listas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;man&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">100</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;heyman&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;heyman&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;foobar&quot;</span> <span class="kr">in</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
<span class="s">&quot;barfoo&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">takeWhile</span></code> es una función realmente útil. Toma elemento de una lista
mientras el predicado se mantenga a cierto, y luego cuando encuentra un
elemento que no satisface el predicado, corta la lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This&quot;</span>
</pre></div>
</div>
<p>Digamos que queremos saber la suma de todas las potencias cúbicas que
están por debajo de 10.000. No podemos mapear <code class="docutils literal notranslate"><span class="pre">(^3)</span></code> a <code class="docutils literal notranslate"><span class="pre">[1..]</span></code>, aplicar
un filtro y luego sumar el resultado ya que filtrar una lista infinita
nunca termina. Tu sabes que todos los elementos son ascendentes pero
Haskell no lo sabe. Por eso usamos esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="mi">53361</span>
</pre></div>
</div>
<p>Aplicamos <code class="docutils literal notranslate"><span class="pre">(^3)</span></code> a una lista infinita y una vez que una elemento mayor
que 10.000 es encontrado, se corta la lista. De esa forma, luego podemos
sumar la lista fácilmente.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dropWhile</span></code> es similar, solo que descarta elemento mientras el predicado
se cumpla. Una vez que el predicado se evalúa a <code class="docutils literal notranslate"><span class="pre">False</span></code>, devuelve el
resto de la lista. ¡Una función encantadora!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot; is a sentence&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Nos dan una lista que representa los valores de las acciones por fechas.
La lista contiene 4-tuplas cuyo primer elemento es el valor de la acción,
el segundo el año, el tercero es el mes y el cuarto el día. Si quisiéramos
saber cuando una acción alcanzara por primera vez los 1000$, podríamos usar
esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stock</span> <span class="ow">=</span> <span class="p">[(</span><span class="mf">994.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mf">995.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mf">999.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mf">998.3</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">(</span><span class="n">dropWhile</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="n">stock</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">span</span></code> es un tipo de <code class="docutils literal notranslate"><span class="pre">takeWhile</span></code>, solo que devuelve una dupla de
listas. La primera lista contiene todo lo que tendría la lista resultante
de <code class="docutils literal notranslate"><span class="pre">takeWhile</span></code>. La lista contendría toda la lista que hubiese sido
cortada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
      <span class="kr">in</span> <span class="s">&quot;First word:&quot;</span> <span class="o">++</span> <span class="n">fw</span> <span class="o">++</span> <span class="s">&quot;, the rest:&quot;</span> <span class="o">++</span> <span class="n">rest</span>
<span class="s">&quot;First word: This, the rest: is a sentence&quot;</span>
</pre></div>
</div>
</li>
<li><p>Mientras que <code class="docutils literal notranslate"><span class="pre">span</span></code> divide la lista cuando el predicado deja de
cumplirse, <code class="docutils literal notranslate"><span class="pre">break</span></code> divide la lista cuando el predicado se cumple por
primera vez. Equivale a <code class="docutils literal notranslate"><span class="pre">span</span> <span class="pre">(not</span> <span class="pre">.</span> <span class="pre">p)</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
<p>Cuando usamos <code class="docutils literal notranslate"><span class="pre">break</span></code>, la segunda lista comenzará con el primer elemento
que satisfaga el predicado.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code> simplemente ordena una lista. El tipo de elementos que contenga
la lista tiene que ser miembro de clase de tipos <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, ya que si los
elementos de la lista no se pueden poner en algún tipo de orden, la lista
no se puede ordenar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="s">&quot;This will be sorted soon&quot;</span>
<span class="s">&quot;    Tbdeehiillnooorssstw&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">group</span></code> toma una lista y agrupa los elementos adyacentes que sean iguales
en sublistas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">]]</span>
</pre></div>
</div>
<p>Si ordenamos una lista antes de agruparla podemos obtener cuantas veces se
repite cada elemento.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">length</span> <span class="n">l</span><span class="p">))</span> <span class="o">.</span> <span class="n">group</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">inits</span></code> y <code class="docutils literal notranslate"><span class="pre">tails</span></code> son como <code class="docutils literal notranslate"><span class="pre">init</span></code> y <code class="docutils literal notranslate"><span class="pre">tail</span></code>, solo que se aplican
recursivamente hasta que no queda nada en la lista. Observa:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">inits</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tails</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">w</span> <span class="ow">=</span> <span class="s">&quot;w00t&quot;</span> <span class="kr">in</span> <span class="n">zip</span> <span class="p">(</span><span class="n">inits</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">tails</span> <span class="n">w</span><span class="p">)</span>
<span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">),(</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">),(</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">),(</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">),(</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Vamos a usar un pliegue para implementar una búsqueda de una sublista
dentro de una lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">search</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">search</span> <span class="n">needle</span> <span class="n">haystack</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">nlen</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">needle</span>
    <span class="kr">in</span>  <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">take</span> <span class="n">nlen</span> <span class="n">x</span> <span class="o">==</span> <span class="n">needle</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="n">tails</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div>
</div>
<p>Primero llamamos a <code class="docutils literal notranslate"><span class="pre">tails</span></code> con la lista en la que estamos buscando. Luego
recorremos cada cola y vemos si empieza con lo que estamos buscando.</p>
</li>
<li><p>Con esto, en realidad hemos creado una función que se comporta como
<code class="docutils literal notranslate"><span class="pre">isInfixOf</span></code>. <code class="docutils literal notranslate"><span class="pre">isInfixOf</span></code> busca una sublista dentro de una lista y
devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code> si la sublista que estamos buscando está en algún lugar
de la lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cats&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">isPrefixOf</span></code> y <code class="docutils literal notranslate"><span class="pre">isSuffixOf</span></code> buscan una sublista desde el principio o
des el final de una lista, respectivamente.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">elem</span></code> y <code class="docutils literal notranslate"><span class="pre">notElem</span></code> comprueban si un elemento está dentro de una lista.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code> toma una lista y un predicado y devuleve una dupla de listas.
La primera lista contiene todos los elementos que satisfacen el predicado,
la segunda todos los que no.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOBMORGAN&quot;</span><span class="p">,</span><span class="s">&quot;sidneyeddy&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Es importante conocer las diferencias que tiene esta función con <code class="docutils literal notranslate"><span class="pre">span</span></code> y
<code class="docutils literal notranslate"><span class="pre">break</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOB&quot;</span><span class="p">,</span><span class="s">&quot;sidneyMORGANeddy&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tanto <code class="docutils literal notranslate"><span class="pre">span</span></code> como <code class="docutils literal notranslate"><span class="pre">break</span></code> terminan cuando encuentran el primer elemento
que satisface o no satisface el predicado, <code class="docutils literal notranslate"><span class="pre">partition</span></code> recorre la lista
entera y la va dividiendo según el predicado.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">find</span></code> toma una lista y un predicado y devuelve el primer elemento que
satisface el predicado. Pero, devuelve el elemento envuelto en un valor
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Veremos con más detalles los tipos de datos algebraicos en el
siguiente capítulo pero de momento esto es todo lo que necesitas saber: un
valor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> puede ser o un <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code> o <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. De la misma
forma que una lista puede ser o una lista vacía o una con elementos, un
valor <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> puede ser o un elemento o ninguno. Y como el tipo de la
lista dice que, por ejemplo, una lista de enteros es <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>, el tipo de
un <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> que contenga un entero es <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>. De todas formas,
vamos a ver la función <code class="docutils literal notranslate"><span class="pre">find</span></code> en acción.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">find</span>
<span class="nf">find</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>Fíjate en el tipo de <code class="docutils literal notranslate"><span class="pre">find</span></code>. Su resultado es del tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. Esto
es parecido a tener algo del tipo <code class="docutils literal notranslate"><span class="pre">[a]</span></code>, solo que un valor del tipo
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code> solo puede tener o un elemento o ninguno, mientras que una lista
puede tener ningún elemento, un solo elemento, o varios de ellos.</p>
<p>Recuerda cuando estábamos buscando la primera vez que una acción superaba
los 1000$. Utilizamos <code class="docutils literal notranslate"><span class="pre">head</span> <span class="pre">(dropWhile</span> <span class="pre">(\(val,y,m,d)</span> <span class="pre">-&gt;</span> <span class="pre">val</span> <span class="pre">&lt;</span> <span class="pre">1000)`</span>
<span class="pre">stock</span></code>. Recuerda también que <code class="docutils literal notranslate"><span class="pre">head</span></code> no es una función segura. ¿Qué
pasaría si nunca hubiésemos alcanzado los 1000$? <code class="docutils literal notranslate"><span class="pre">dropWhile</span></code> hubiese
devuelto una lista vacía y aplicar <code class="docutils literal notranslate"><span class="pre">head</span></code> en una lista vacía solo da un
resultado, un error. Sin embargo, si usamos <code class="docutils literal notranslate"><span class="pre">find</span> <span class="pre">(\(val,y,m,d)</span> <span class="pre">-&gt;</span> <span class="pre">val</span> <span class="pre">&gt;</span>
<span class="pre">1000)</span> <span class="pre">stock</span></code>, podemos estar mucho más tranquilos. Si nuestras acciones
nunca superan los 1000$ (es decir, ningún elemento satisface el predicado),
obtendremos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, y si sí lo hacen obtendremos una respuesta válida,
como <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(1001.4,2008,9,4)</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndex</span></code> es parecido a <code class="docutils literal notranslate"><span class="pre">elem</span></code>, solo que no devuelve un valor
booleano. Quizá devuelva el índice del elemento que estamos buscando. Si
elemento no está en la lista devolverá <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">elemIndex</span>
<span class="nf">elemIndex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">elemIndices</span></code> es como <code class="docutils literal notranslate"><span class="pre">elemIndex</span></code>, solo que devuelve una lista de
índices en caso de que el elemento que estamos buscando aparezca varias
veces por la lista. Como estamos usando una lista para representar los
índices, no necesitamos el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, ya que el caso de que no se
encuentre nada puede ser representado con la lista vacía, la cual es
sinónimo de <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39; &#39;</span> <span class="p">`</span><span class="n">elemIndices</span><span class="p">`</span> <span class="s">&quot;Where are the spaces?&quot;</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">findIndex</span></code> es como <code class="docutils literal notranslate"><span class="pre">find</span></code>, solo que puede devolver el índice del
primer elemento que satisfaga el predicado. <code class="docutils literal notranslate"><span class="pre">findIndices</span></code> devuelve el
indice de todos los elementos que satisfagan el predicado en forma de
lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndices</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;Where Are The Caps?&quot;</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>Ya hemos hablado de <code class="docutils literal notranslate"><span class="pre">zip</span></code> y de <code class="docutils literal notranslate"><span class="pre">zipWith</span></code>. Vimos que estas funciones
combinaban dos listas, ya sea con una dupla o con una función binaria (en
el sentido de que toma dos parámetros) ¿Y si queremos combinar tres listas?
¿O combinar tres listas con una función que toma tres parámetros? Bueno,
para eso tenemos <code class="docutils literal notranslate"><span class="pre">zip3</span></code>, <code class="docutils literal notranslate"><span class="pre">zip4</span></code>, etc. y <code class="docutils literal notranslate"><span class="pre">zipWith3</span></code>, <code class="docutils literal notranslate"><span class="pre">zipWith4</span></code>,
etc. Estas variantes llegan hasta 7. Esto puede parece algún tipo arreglo,
pero funciona muy bien en la realidad, ya que no hay tantas ocasiones en
las que queramos combinar 8 listas. También existe una forma muy ingeniosa
de combinar un número infinito de listas, pero no hemos avanzado aún lo
suficiente como para explicarlo aquí.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith3</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip4</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div>
</div>
<p>Como las otras funciones, la listas resultantes son tan largas como la
lista más corta.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code> es una función muy útil cuando tratamos con algún tipo de
entrada, como ficheros. Toma una cadena y devuelve cada línea de esa cadena
separada en una lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line&quot;</span>
<span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span><span class="s">&quot;second line&quot;</span><span class="p">,</span><span class="s">&quot;third line&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">'\n'</span></code> es el carácter que representa el salto de línea unix. Las barras
invertidas tienen un significado especial en las cadenas y caracteres de
Haskell.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">unlines</span></code> es la función inversa de <code class="docutils literal notranslate"><span class="pre">lines</span></code>. Toma una lista de cadenas
y las une utilizando un <code class="docutils literal notranslate"><span class="pre">'\n'</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unlines</span> <span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span> <span class="s">&quot;second line&quot;</span><span class="p">,</span> <span class="s">&quot;third line&quot;</span><span class="p">]</span>
<span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">words</span></code> y <code class="docutils literal notranslate"><span class="pre">unwords</span></code> sirven para separar separar una línea de texto por
palabras. Muy útil.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these are the words in this sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these           are    the words in this</span><span class="se">\n</span><span class="s">sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unwords</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;mate&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there mate&quot;</span>
</pre></div>
</div>
</li>
<li><p>Ya hemos visto antes <code class="docutils literal notranslate"><span class="pre">nub</span></code>. Toma una lista y elimina los elementos
repetidos, devolviendo una lista en la que cada elemento es único. Esta
función tiene un nombre muy raro. Resulta que <code class="docutils literal notranslate"><span class="pre">nub</span></code> significa una
pequeña parte o una parte esencial de algo. En mi opinión, creo que
deberían usar nombres reales para las funciones en lugar de palabras
ancestrales.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;Lots of words and stuff&quot;</span>
<span class="s">&quot;Lots fwrdanu&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">delete</span></code> toma un elemento y una lista y elimina el primer elemento
idéntico de esa lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey there ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere gang!&quot;</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">\\</span></code> es la función división. Funciona como una división basicamente.
Elimina la primera ocurrencia de la lista de la derecha de los elementos
de la lista de la izquierda.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">\\</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Im a big baby&quot;</span> <span class="o">\\</span> <span class="s">&quot;big&quot;</span>
<span class="s">&quot;Im a  baby&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[1..10]</span> <span class="pre">\\</span> <span class="pre">[2,5,9]</span></code> es como hacer <code class="docutils literal notranslate"><span class="pre">delete</span> <span class="pre">2</span> <span class="pre">.</span> <span class="pre">delete</span> <span class="pre">5</span> <span class="pre">.</span> <span class="pre">delete</span> <span class="pre">9</span> <span class="pre">$</span>
<span class="pre">[1..10]</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">union</span></code> funciona como la unión de conjuntos. Devuelve la unión de dos
listas. Básicamente recorre cada elemento de la segunda lista y lo añade
a la primera lista si está aún no lo contenía. Ten cuidado, los duplicados
solo son eliminados de la primera lista.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey man&quot;</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="s">&quot;man what&#39;s up&quot;</span>
<span class="s">&quot;hey manwt&#39;sup&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">intersect</span></code> funciona como la intersección de conjuntos. Devuelve los
elementos que están en ambas listas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">intersect</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert</span></code> toma un elemento y una lista que puede ser ordenada e inserta
este elemento en la última posición donde sea menor o igual que el elemento
siguiente. En otras palabras, <code class="docutils literal notranslate"><span class="pre">insert</span></code> recorrerá la lista hasta que
encuentre un elemento mayor que el elemento que estamos insertando, y lo
insertará antes de dicho elemento.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>El <code class="docutils literal notranslate"><span class="pre">4</span></code> es insertado justo después del <code class="docutils literal notranslate"><span class="pre">3</span></code> y antes del <code class="docutils literal notranslate"><span class="pre">5</span></code> en el
primer ejemplo, y entre <code class="docutils literal notranslate"><span class="pre">3</span></code> y el <code class="docutils literal notranslate"><span class="pre">4</span></code> en el segundo.</p>
<p>Si usamos <code class="docutils literal notranslate"><span class="pre">insert</span></code> para introducir algo en una lista ordenada el
resultado seguirá estando ordenado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="sc">&#39;g&#39;</span> <span class="o">$</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;f&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;h&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>Lo que <code class="docutils literal notranslate"><span class="pre">length</span></code>, <code class="docutils literal notranslate"><span class="pre">take</span></code>, <code class="docutils literal notranslate"><span class="pre">drop</span></code>, <code class="docutils literal notranslate"><span class="pre">splitAt</span></code>, <code class="docutils literal notranslate"><span class="pre">!!</span></code> y <code class="docutils literal notranslate"><span class="pre">replicate</span></code>
tienen en común es que toman un <code class="docutils literal notranslate"><span class="pre">Int</span></code> como parámetro (o lo devulen),
incluso aunque estas funciones podrían ser más genéricas y útiles si
simplemente tomaran cualquier tipo que fuera parte de las clases de tipos
<code class="docutils literal notranslate"><span class="pre">Integral</span></code> o <code class="docutils literal notranslate"><span class="pre">Num</span></code> (dependiendo de las funciones). Lo hacen por mótivos
hístoricos. Probablemente si arreglaran esto dejaría de funcionar mucho código
ya existente. Este es el motivo por el que <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> tiene sus propias
variantes más genéricas, se llaman <code class="docutils literal notranslate"><span class="pre">genericLength</span></code>, <code class="docutils literal notranslate"><span class="pre">genericTake</span></code>,
<code class="docutils literal notranslate"><span class="pre">genericDrop</span></code>, <code class="docutils literal notranslate"><span class="pre">genericSplitAt</span></code>, <code class="docutils literal notranslate"><span class="pre">genericIndex</span></code> y <code class="docutils literal notranslate"><span class="pre">genericReplicate</span></code>.
Por ejemplo, <code class="docutils literal notranslate"><span class="pre">length</span></code> tiene el tipo <code class="docutils literal notranslate"><span class="pre">length</span> <span class="pre">::</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. Si intentamos
obtener la media de una lista de número usando <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">[1..6]</span> <span class="pre">in</span> <span class="pre">sum</span> <span class="pre">xs</span> <span class="pre">/</span>
<span class="pre">length</span> <span class="pre">xs</span></code> obtendremos un error de tipo, ya que no podemos usar <code class="docutils literal notranslate"><span class="pre">/</span></code> con un
<code class="docutils literal notranslate"><span class="pre">Int</span></code>. Por otra parte <code class="docutils literal notranslate"><span class="pre">genericLength</span></code> tiene el tipo <code class="docutils literal notranslate"><span class="pre">genericLength</span> <span class="pre">::</span>
<span class="pre">(Num</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">[b]</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>. Como <code class="docutils literal notranslate"><span class="pre">Num</span></code> puede comportarse como un número en coma
flotante, obtener la media haciendo <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">[1..6]</span> <span class="pre">in</span> <span class="pre">sum</span> <span class="pre">xs</span> <span class="pre">/</span>
<span class="pre">genericLength</span> <span class="pre">xs</span></code> funciona perfectamente.</p>
<p>Las funciones <code class="docutils literal notranslate"><span class="pre">nub</span></code>, <code class="docutils literal notranslate"><span class="pre">delete</span></code>, <code class="docutils literal notranslate"><span class="pre">union</span></code>, <code class="docutils literal notranslate"><span class="pre">intersect</span></code> y <code class="docutils literal notranslate"><span class="pre">group</span></code> tienen
sus repectivas funciones más generales llamadas <code class="docutils literal notranslate"><span class="pre">nubBy</span></code>, <code class="docutils literal notranslate"><span class="pre">deleteBy</span></code>,
<code class="docutils literal notranslate"><span class="pre">unionBy</span></code>, <code class="docutils literal notranslate"><span class="pre">intersectBy</span></code> y <code class="docutils literal notranslate"><span class="pre">groupBy</span></code>. La diferencia entre ellas es que
el primer conjunto de funciones usa <code class="docutils literal notranslate"><span class="pre">==</span></code> para comprobar la igualdad,
mientras que el otro conjunto toman una función de igualdad y comparan
elementos utilizando esta función. <code class="docutils literal notranslate"><span class="pre">group</span></code> es lo mismo que <code class="docutils literal notranslate"><span class="pre">groupBy</span> <span class="pre">(==)</span></code>.</p>
<p>Por ejemplo, digamos que tenemos una lista que contiene el valor de una
función para cada segundo. Queremos segmentar la lista en sublistas basandonos
en cuando un valor estaba por debajo de cero y cuando estaba por encima. Si
usaramos un <code class="docutils literal notranslate"><span class="pre">group</span></code> normal simplemente agruparía lod valores iguales
adyacentes. Pero lo que nosotros queremos es agruparlos según vaya siendo
positivos o no. Aqui es donde entra en juengo <code class="docutils literal notranslate"><span class="pre">groupBy</span></code>. La función de
igualdad que toman las funciones con el sufijo <code class="docutils literal notranslate"><span class="pre">By</span></code> deben tomar dos
parámetros del mismo tipo y devolver <code class="docutils literal notranslate"><span class="pre">True</span></code> si consideran que son iguales
por su propio criterio.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">values</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.9</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mf">29.1</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]]</span>
</pre></div>
</div>
<p>De est forma podemos ver claramente que secciones son positivas y cuales
negativas. La función de igualdad que hemos utilizado solo devuleve <code class="docutils literal notranslate"><span class="pre">True</span></code>
cuando los dos valores son positivos o son los dos negativos. Esta función
de igualdad también se puede escribir como <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">||</span> <span class="pre">(x</span>
<span class="pre">&lt;=</span> <span class="pre">0)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(y</span> <span class="pre">&lt;=</span> <span class="pre">0)</span></code> aunque para mi gusto la primera es más legible. Existe
incluso una forma más clara de escribir funciones de igualdad para estas
funciones si importamos la función <code class="docutils literal notranslate"><span class="pre">on</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">Data.Function</span></code>. <code class="docutils literal notranslate"><span class="pre">on</span></code>
se define como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">on</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que <code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">`on`</span> <span class="pre">(&gt;</span> <span class="pre">0)</span></code> devuelve una función de igualdad que se
comporta igual que <code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">==</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">0)</span></code>. <code class="docutils literal notranslate"><span class="pre">on</span></code> se utiliza mucho con
todas estas funciones, ya que con ella, podemos hacer cosas como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]]</span>
</pre></div>
</div>
<p>¡Muy legible! Puedes leerlo de golpe: Agrupa esto por igualdad en si los
elementos son mayores que cero.</p>
<p>De forma similar, la funciones <code class="docutils literal notranslate"><span class="pre">sort</span></code>, <code class="docutils literal notranslate"><span class="pre">insert</span></code>, <code class="docutils literal notranslate"><span class="pre">maximum</span></code> y <code class="docutils literal notranslate"><span class="pre">minimum</span></code>
también tienen sus equivalentes más generales. Fucniones como <code class="docutils literal notranslate"><span class="pre">groupBy</span></code>
toman funciones que determinan si dos elemento son iguales o no. <code class="docutils literal notranslate"><span class="pre">sortBy</span></code>,
<code class="docutils literal notranslate"><span class="pre">insertBy</span></code>, <code class="docutils literal notranslate"><span class="pre">maximumBy</span></code> y <code class="docutils literal notranslate"><span class="pre">minimumBy</span></code> toman una función que determina si
si un elemento es mayor, igual o menor que otro. El tipo de <code class="docutils literal notranslate"><span class="pre">sortBy</span></code> es
<code class="docutils literal notranslate"><span class="pre">sortBy</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Ordering)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></code>. Si recuerdas, el tipo
<code class="docutils literal notranslate"><span class="pre">Ordering</span></code> puede tomar los valores <code class="docutils literal notranslate"><span class="pre">GT</span></code>, <code class="docutils literal notranslate"><span class="pre">EQ</span></code> y <code class="docutils literal notranslate"><span class="pre">LT</span></code>. <code class="docutils literal notranslate"><span class="pre">sort</span></code> es
equivalente a <code class="docutils literal notranslate"><span class="pre">sort</span> <span class="pre">compare</span></code>, ya que <code class="docutils literal notranslate"><span class="pre">comapare</span></code> simplemente toma dos
elementos cuyos tipos esten en la clase de tipos <code class="docutils literal notranslate"><span class="pre">Ord</span></code> y devuelve su relación
de orden.</p>
<p>Las listas pueden ser comparadas por orden lexicográfico ¿Y si tenemos una
lista de listas y no queremos ordenarlas en base al contenido de las listas
interiores sino a sus tamaños? Bueno, como probablemente hayas imaginado, para
eso está la función <code class="docutils literal notranslate"><span class="pre">sortBy</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sortBy</span> <span class="p">(</span><span class="n">compare</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">length</span><span class="p">)</span> <span class="n">xs</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>¡Increíble! <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">length</span></code>, eso se lee casi como el inglés real. Si
no estás seguro de como funciona <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">length</span></code> aquí, equivalente a
<code class="docutils literal notranslate"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">length</span> <span class="pre">x</span> <span class="pre">`compare`</span> <span class="pre">length</span> <span class="pre">y</span></code>. Cuando tratamos con funciones que
tienen el sufijo <code class="docutils literal notranslate"><span class="pre">By</span></code> que toman funciones de igualdad normalmente utilizamos
<code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">`on`</span> <span class="pre">algo</span></code> y cuando tratamos con las que toman funciones de orden
solemos utilizar <code class="docutils literal notranslate"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">algo</span></code>.</p>
</div>
<div class="section" id="data-char">
<h2>Data.Char<a class="headerlink" href="#data-char" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="¡caracteres lego!" class="align-right" src="../_images/legochar.png" />
<p>El módulo <code class="docutils literal notranslate"><span class="pre">Data.Char</span></code> contiene lo que su nombre sugiere. Exporta funciones
que tratan con caracteres. También es útil cuando mapeamos o filtramos
cadenas ya que al fin y al cabo son listas de caracteres.</p>
<p><code class="docutils literal notranslate"><span class="pre">Data.Char</span></code> exporta un buen puñado de predicados sobre caracteres. Esto es,
funciones que toman un carácter y nos dicen si una suposición acerca de él
es verdadera o falsa. Aquí los tienes:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">isControl</span></code> comprueba si un carácter es de control o no.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSpace</span></code> comprueba si un carácter es uno de los caracteres de espacio
en blanco. Eso incluye espacios, tabuladores, saltos de línea, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isLower</span></code> comprueba si un carácter está en minúsculas.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isUpper</span></code> comprueba si un carácter está en mayúsculas.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isAlpha</span></code> comprueba si un carácter es una letra.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isAlphaNum</span></code> comprueba si un carácter es una letra o un número.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isPrim</span></code> comprueba si un carácter es imprimible. Los caracteres de
control, por ejemplo, no lo son.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isDigit</span></code> comprueba si un carácter es un dígito.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isOctDigit</span></code> comprueba si un carácter es un dígito octal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isHexDigit</span></code> comprueba si un carácter es un dígito hexadecimal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isLetter</span></code> comprueba si un carácter es una letra.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isMark</span></code> comprueba si un carácter es una marca Unicode. Esto caracteres
que se combinan con sus adyacentes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isNumber</span></code> comprueba si un carácter numérico.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isPunctuation</span></code> comprueba si un carácter es un signo de puntuación.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSymbol</span></code> comprueba si un carácter es símbolo matemático o el de una
moneda.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isSeparator</span></code> comprueba si un carácter es un espacio o un separador
Unicode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isAscii</span></code> comprueba si un carácter es uno de los primeros 128 caracteres
del conjunto de caracteres Unicode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isLatin1</span></code> comprueba si un carácter es uno de los primeros 256 caracteres
del conjunto de caracteres Unicode.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isAsciiUpper</span></code> comprueba si un carácter está en mayúsculas y además es
ascii.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">isAsciiLower</span></code> comprueba si un carácter está en minúsculas y además es
ascii.</p></li>
</ul>
</div></blockquote>
<p>Todas estas funciones tienen el tipo <code class="docutils literal notranslate"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. La mayoría de las veces
las usaras para filtrar cadenas o algo parecido. Por ejemplo, digamos que
vamos a hacer un programa que toma un nombre de usuario y dicho nombre solo
puede estar compuesto por caracteres alfanuméricos. Podemos usar la función
<code class="docutils literal notranslate"><span class="pre">all</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> para determinar si el nombre es correcto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;bobby283&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;eddy the fish!&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>En caso de que no te acuerdes, <code class="docutils literal notranslate"><span class="pre">all</span></code> toma un predicado y devuelve <code class="docutils literal notranslate"><span class="pre">True</span></code>
solo si dicho predicado se cumple para toda la lista.</p>
<p>También podemos utilizar la función <code class="docutils literal notranslate"><span class="pre">isSpace</span></code> para simular la función
<code class="docutils literal notranslate"><span class="pre">words</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Mmm… bueno, hace lo mismo que <code class="docutils literal notranslate"><span class="pre">words</span></code> pero nos dejamos algunos elementos
que contienen un solo espacio ¿Qué podemos hacer? Ya se, vamos a filtrarlos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">any</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">.</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">$</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Data.Char</span></code> también exporta un tipo de dato parecido a <code class="docutils literal notranslate"><span class="pre">Ordering</span></code>. El tipo
<code class="docutils literal notranslate"><span class="pre">Ordering</span></code> puede tener un valor <code class="docutils literal notranslate"><span class="pre">LT</span></code>, <code class="docutils literal notranslate"><span class="pre">EQ</span></code> o <code class="docutils literal notranslate"><span class="pre">GT</span></code>. Es una especie de
enumeración. Describe una serie de posibles resultados dados al comparar dos
elementos. El tipo <code class="docutils literal notranslate"><span class="pre">GeneralCategory</span></code> también es una enumeración. Representa
una serie de categorías a las que puede pertenecer un carácter. La función
principal para obtener la categoría de un carácter es <code class="docutils literal notranslate"><span class="pre">generalCategory</span></code>.
Tiene el tipo <code class="docutils literal notranslate"><span class="pre">generalCategory</span> <span class="pre">::</span> <span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">GeneralCategory</span></code>. Existen 31
categorías diferentes así que no las vamos a mostrar, pero vamos a jugar un
poco con esta función.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39; &#39;</span>
<span class="kt">Space</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;A&#39;</span>
<span class="kt">UppercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">LowercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;.&#39;</span>
<span class="kt">OtherPunctuation</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;9&#39;</span>
<span class="kt">DecimalNumber</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">generalCategory</span> <span class="s">&quot; </span><span class="se">\t\n</span><span class="s">A9?|&quot;</span>
<span class="p">[</span><span class="kt">Space</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">UppercaseLetter</span><span class="p">,</span><span class="kt">DecimalNumber</span><span class="p">,</span><span class="kt">OtherPunctuation</span><span class="p">,</span><span class="kt">MathSymbol</span><span class="p">]</span>
</pre></div>
</div>
<p>Como <code class="docutils literal notranslate"><span class="pre">GeneralCategory</span></code> forma parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code> podemos hacer
cosas como <code class="docutils literal notranslate"><span class="pre">generalCategory</span> <span class="pre">c</span> <span class="pre">==</span> <span class="pre">Space</span></code>.</p>
<p>Para terminar, aquí tienes unas cuantas funciones que convierten caracteres:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">toUpper</span></code> convierte un carácter a mayúsculas. Lo espacios, números y todo
lo demás permanece igual.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">toLower</span></code> convierte un carácter a minúsculas.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">toTitle</span></code> es similar a <code class="docutils literal notranslate"><span class="pre">toUpper</span></code> excepto para una pocas letras.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">digitToInt</span></code> convierte un carácter a un <code class="docutils literal notranslate"><span class="pre">Int</span></code>. Para que funcione, el
carácter debe estar entre los rangos <code class="docutils literal notranslate"><span class="pre">'0'..'9'</span></code>, <code class="docutils literal notranslate"><span class="pre">'a'..'f'</span></code> y
<code class="docutils literal notranslate"><span class="pre">'A'..'F'</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;34538&quot;</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;FF85AB&quot;</span>
<span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">intToDigit</span></code> es la función inversa de <code class="docutils literal notranslate"><span class="pre">digitToInt</span></code>. Toma un <code class="docutils literal notranslate"><span class="pre">Int</span></code> que
este en el rango <code class="docutils literal notranslate"><span class="pre">0..15</span></code> y lo convierte a un carácter en minúsculas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">15</span>
<span class="sc">&#39;f&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">5</span>
<span class="sc">&#39;5&#39;</span>
</pre></div>
</div>
</li>
<li><p>La función <code class="docutils literal notranslate"><span class="pre">ord</span></code> y <code class="docutils literal notranslate"><span class="pre">chr</span></code> convierte caracteres a sus respectivas
representaciones numéricas y viceversa.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ord</span> <span class="sc">&#39;a&#39;</span>
<span class="mi">97</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chr</span> <span class="mi">97</span>
<span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">ord</span> <span class="s">&quot;abcdefgh&quot;</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">]</span>
</pre></div>
</div>
<p>La diferencia entre dos valores de <code class="docutils literal notranslate"><span class="pre">ord</span></code> de dos caracteres es igual a
la diferencia que existe entre ellos dos en la tabla Unicode.</p>
<p>El cifrado César es un método primitivo para cifrar mensajes desplazando
cada carácter un número fijo de posiciones en el alfabeto. Podemos crear
una especie de cifrado César nosotros mismo, solo que no nos vamos a ceñir
únicamente al alfabeto.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">encode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">encode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">ords</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">ord</span> <span class="n">msg</span>
        <span class="n">shifted</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="n">ords</span>
    <span class="kr">in</span>  <span class="n">map</span> <span class="n">chr</span> <span class="n">shifted</span>
</pre></div>
</div>
<p>Primero, convertimos la cadena en una lista de número. Luego, le añadimos
una cantidad constante a cada número y convertimos la lista de números
resultantes en otra cadena de texto. Si te va más la composición, podías
haber hecho lo mismo con <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">(chr</span> <span class="pre">.</span> <span class="pre">(+</span> <span class="pre">shift)</span> <span class="pre">.</span> <span class="pre">ord)</span> <span class="pre">msg</span></code>. Vamos a
probar a codificar unos mensajes.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Khhhhh|&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">4</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Liiiii}&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">1</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;bcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">5</span> <span class="s">&quot;Marry Christmas! Ho ho ho!&quot;</span>
<span class="s">&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;</span>
</pre></div>
</div>
<p>Parece que está bien cifrado. Descifrar un mensaje es básicamente volver a
poner los caracteres desplazados en su lugar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">decode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">decode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span> <span class="n">encode</span> <span class="p">(</span><span class="n">negate</span> <span class="n">shift</span><span class="p">)</span> <span class="n">msg</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Im a little teapot&quot;</span>
<span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">3</span> <span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="s">&quot;Im a little teapot&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">5</span> <span class="o">.</span> <span class="n">encode</span> <span class="mi">5</span> <span class="o">$</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This is a sentence&quot;</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="data-map">
<h2>Data.Map<a class="headerlink" href="#data-map" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las listas de asociación (también llamadas diccionarios) son listas que son
utilizadas para almacenar pares clave-valor donde el orden no importa. Por
ejemplo, podemos tener una lista de asociación para almacenar números de
teléfono, donde los números de telefono serían los valores y los nombres de la
gente serían las claves. No nos importa el orden en el que esten almacenados,
solo queremos obtener el número aducuado para cada persona.</p>
<p>La forma más obvia de representar una lista de asociación en Haskell sería
utilizar una lista de duplas. El primer componente de las duplas sería la
clave, y el segundo el valor. Aquí tienes un ejemplo de una lista de
asociación de números de telefono:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>A pesar de que esta alineación extraña, es simplemente un lista de duplas
de cadenas. La tarea más común cuando trabajamos con listas de asociación es
buscar un valor por clave. Vamos a crear una función que busque un valor dada
una clave.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Muy simple. Esta función toma una clave y una lista, filtra la lista de forma
que solo queden claves que coincidan con la clave que se le paso, obtiene el
primer elemento de la lista resultante y luego devuelve el valor asociado.
Pero ¿Qué pasa si la clave que estamos buscando no esta en la lista? Mmm… Si
la clave no está en la lista, acabamos intentando aplicar <code class="docutils literal notranslate"><span class="pre">head</span></code> en una
lista vacía, por lo que tendremos un error de ejecución. Sin embargo, debemos
evitar que nuestros programas se rompan tan facilmente, así que vamos a usar
el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Si no encontramos la clave, devolvemos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> y en
caso de que la encontremos, devolvemos <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code>, donde algo es el valor
asociado a esa clave.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>
                            <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span>
                            <span class="kr">else</span> <span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Fíjate en la declaración de tipo. Toma una clave que puede ser comparada por
igualdad, una lista de asociación y puede devolver un valor. Suena bien.</p>
<p>Esta es una función recursiva de libro que opera con listas. Caso base,
dividir una lista en cabeza y cola, llamada recursiva… Esto es un pliegue
clásico, asi que vamos a implementarlo con un pliegue.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Normalmente es mejor usar un pligue en estos casos de recursión
estándar sobre listas en lugar de una recursión explícita ya que
resulta más legible y fácil de identificar. Todo el mundo sabe que
se está realizando un pliegue cuando ve una llamada a <code class="docutils literal notranslate"><span class="pre">foldr</span></code>,
pero toma un poco más de tiempo leer una recursión explícita.</p>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;penny&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;853-2492&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;betty&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;555-2938&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;wilma&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<img alt="¡Mapa lego!" class="align-left" src="../_images/legomap.png" />
<p>¡Funciona perfectamente! Si tenemos el número de una chica obtenemos dicho
<code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">número</span></code>, en otro caso obtenemos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>.</p>
<p>Acabamos de implementar la función <code class="docutils literal notranslate"><span class="pre">lookup</span></code> del módulo <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>. Si
queremos obtener el valor correspondiente a una clave solo tenemos que
recorrer la lista hasta que la encontremos. El módulo <code class="docutils literal notranslate"><span class="pre">Data.Tree</span></code> ofrece
listas de asociación mucho más eficientes (ya que están implementadas con
árboles) y también ofrece un montón de funciones útiles. De ahora en adelante
diremos que estamos trabajando con diccionarios en lugar de listas de
asociación.</p>
<p>Debido a que <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> exporta funciones que colisionan con las de
<code class="docutils literal notranslate"><span class="pre">Prelude</span></code> y <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>, lo importaremos de forma cualificada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
</pre></div>
</div>
<p>Pon esta sentencia en un script y luego cárgalo con GHCi.</p>
<p>Vamos a continuar y ver que tiene <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> para nosotros. Aquí tienes un
resumen básico de las funciones.</p>
<blockquote>
<div><ul>
<li><p>La función <code class="docutils literal notranslate"><span class="pre">fromList</span></code> tomo una lista de asociación (en forma de lista) y
devuelve un diccionario con las mismas asociaciones.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
<p>En caso de que existan claves duplicadas en la lista de asociación, los
duplicados son descartados. Este es la declaración de tipo de <code class="docutils literal notranslate"><span class="pre">fromList</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
</pre></div>
</div>
<p>Dice que toma una lista de duplas <code class="docutils literal notranslate"><span class="pre">k</span></code> y <code class="docutils literal notranslate"><span class="pre">v</span></code> y devuelve un diccionario
que asocia las claves <code class="docutils literal notranslate"><span class="pre">k</span></code> con los valores <code class="docutils literal notranslate"><span class="pre">v</span></code>. Fíjate que cuando
creábamos listas de asociación con listas normales, las claves solo tenían
que ser igualables (su tipo pertenecía a la clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code>) pero
ahora tienen que ser ordenables. Esto es básicamente una restricción del
módulo <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>. Necesita que las claves sean ordenables para que pueda
organizarlas en un árbol.</p>
<p>Debes utilizar siempre el módulo <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> para las asociaciones
clave-valor a no ser que las claves son sean de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">empty</span></code> representa un diccionario vacío. No toma ningún parámetro,
simplemente devuelve un diccionario vacío.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert</span></code> toma una una clave, un valor y un diccionario y devuelve un
nuevo diccionario exactamente igual al anterior, solo que contiene además
la nueva clave-valor.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="p">(</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span>  <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
</pre></div>
</div>
<p>Podemos implementar nuestra propia función <code class="docutils literal notranslate"><span class="pre">fromList</span></code> usando únicamente
un diccionario vacío, <code class="docutils literal notranslate"><span class="pre">insert</span></code> y un pliegue. Mira:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">fromList&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
<span class="nf">fromList&#39;</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">v</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div>
</div>
<p>Es un pliegue bastante simple. Empezamos con un diccionario vacío y luego
vamos plegando la lista desde la derecha, insertando nuevos pares
clave-valor en el acumulador.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">null</span></code> comprueba si un diccionario está vacío.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">size</span></code> nos da el tamaño de un diccionario.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="mi">5</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">singleton</span></code> toma una clave y un valor y nos devuelve un diccionario que
solo contiene esa clave.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">9</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">lookup</span></code> funciona como la función <code class="docutils literal notranslate"><span class="pre">lookup</span></code> de <code class="docutils literal notranslate"><span class="pre">Data.List</span></code>, solo que
opera con diccionarios en lugar de listas. Devuelve <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code> si
encuentra la clave o <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> en caso contrario.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">member</span></code> es un predicado que toma una clave y un diccionario y nos dice
si dicha clave está contenida en el diccionario.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">map</span></code> y <code class="docutils literal notranslate"><span class="pre">filter</span></code> funcionan de forma similar a sus equivales de listas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">400</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">900</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">isUpper</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">toList</span></code> es la inversa de <code class="docutils literal notranslate"><span class="pre">fromList</span></code>.</p>
<blockquote>
<div><p>ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]</p>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">keys</span></code> y <code class="docutils literal notranslate"><span class="pre">elems</span></code> devuelven una lista con todas la claves o todo los
valores respectivamente. <code class="docutils literal notranslate"><span class="pre">keys</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">fst</span> <span class="pre">.</span> <span class="pre">Map.toList</span></code>
y <code class="docutils literal notranslate"><span class="pre">elems</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">snd</span> <span class="pre">.</span> <span class="pre">Map.toList</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fromListWith</span></code> es una función muy interesante. Actúa com <code class="docutils literal notranslate"><span class="pre">fromList</span></code>,
solo que no descarta ningún predicado, en su lugar, utiliza una función que
le pasemos para decidir cual de ellas debe añadirse. Digamos que una chica
puede tener varios números de teléfono y tenemos una lista de asociación
como esta:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;342-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;827-9162&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;555-2111&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>De esta forma si usamos <code class="docutils literal notranslate"><span class="pre">fromList</span></code> perderemos algunos números. Así que
podemos hacer esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="kt">String</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">number1</span> <span class="n">number2</span> <span class="ow">-&gt;</span> <span class="n">number1</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">number2</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;827-9162, 943-2929, 493-2928&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;wendy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;939-8282&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;betty&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;342-2492, 555-2938&quot;</span>
</pre></div>
</div>
<p>En caso de que se encuentre una clave duplicada, la función que pasemos se
encargará de combinar los valores de es clave. También podríamos hacer
primero todos los valores de la lista de asociación listas unitarias y
luego utilizar <code class="docutils literal notranslate"><span class="pre">++</span></code> para combinar los números.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,[</span><span class="n">v</span><span class="p">]))</span> <span class="n">xs</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="p">[</span><span class="s">&quot;827-9162&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Muy simple. Otro caso sería si estamos creando un diccionario a partir de
una lista de asociación que contiene números y que cuando se encuentra una
clave duplicada, queremos que el valor más grande sea el que se mantenga.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="n">max</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span>
</pre></div>
</div>
<p>O también podríamos haber elegido que estos valores se sumaran:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">108</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">62</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">37</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">insertWith</span></code> es un <code class="docutils literal notranslate"><span class="pre">insert</span></code> de la misma forma que <code class="docutils literal notranslate"><span class="pre">fromListWith</span></code> lo
es para <code class="docutils literal notranslate"><span class="pre">fromList</span></code>. Inserta una clave-valor en un diccionario, pero si
el diccionario ya contiene dicha clave, usa la función que le pasamos para
determinar que hacer.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insertWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">104</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>Estas son solo algunas de la funciones que contiene <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>. Puedes ver
un lista completa de las funciones que contiene en su
<a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs">documentación</a>.</p>
</div>
<div class="section" id="data-set">
<h2>Data.Set<a class="headerlink" href="#data-set" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Conjuntos lego" class="align-right" src="../_images/legosets.png" />
<p>El módulo <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> nos ofrece operaciones con conjuntos. Conjuntos como
los conjuntos en matemáticas. Los <code class="docutils literal notranslate"><span class="pre">conjuntos</span></code> son un tipo de datos mezcla
entre las lista y los diccionarios. Todos los elementos de un conjunto son
únicos. Y como internamente son implementados con árboles (como los
diccionarios de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>) están ordenados. Comprobar si existe un
elemento, insertarlo, eliminarlo, etc. es mucho más eficiente que hacerlo con
listas. Las operaciones más comunes cuando trabajamos con conjuntos son
insertar elementos, comprobar si existe un elemento en el conjunto y convertir
un conjunto en una lista.</p>
<p>Como los nombres que exporta <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> colisionan con los de <code class="docutils literal notranslate"><span class="pre">Prelude</span></code> y
<code class="docutils literal notranslate"><span class="pre">Data.List</span></code> lo importamos de forma cualificada.</p>
<p>Pon esta sentencia en un script:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">Set</span>
</pre></div>
</div>
<p>Y luego carga el script con GHCi.</p>
<p>Digamos que tenemos dos trozos de texto. Queremos saber que caracteres son
usados en ambos trozos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">text1</span> <span class="ow">=</span> <span class="s">&quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;</span>
<span class="nf">text2</span> <span class="ow">=</span> <span class="s">&quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">fromList</span></code> funciona como es de esperar. Toma una lista y la
convierte en un conjunto.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set1</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set2</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot; .?AIRadefhijlmnorstuy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !Tabcdefghilmnorstuvwy&quot;</span>
</pre></div>
</div>
<p>Como puedes ver los elementos están ordenados y cada elemento es único. Ahora
vamos a utilizar la función <code class="docutils literal notranslate"><span class="pre">intersection</span></code> para ver que elementos están en
ambos conjuntos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">intersection</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; adefhilmnorstuy&quot;</span>
</pre></div>
</div>
<p>Podemos usar la función <code class="docutils literal notranslate"><span class="pre">difference</span></code> para ver que elementos del primer
conjunto no están en el segundo y viceversa.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot;.?AIRj&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set2</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot;!Tbcgvw&quot;</span>
</pre></div>
</div>
<p>O podemos ver todas letras que fueron utilizadas en ambos textos usando
<code class="docutils literal notranslate"><span class="pre">union</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</span>
</pre></div>
</div>
<p>Las funciones  <code class="docutils literal notranslate"><span class="pre">null</span></code>, <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">member</span></code>, <code class="docutils literal notranslate"><span class="pre">empty</span></code>, <code class="docutils literal notranslate"><span class="pre">singleton</span></code>,
<code class="docutils literal notranslate"><span class="pre">insert</span></code> y <code class="docutils literal notranslate"><span class="pre">delete</span></code> funcionan como esperas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">8</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">delete</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>También se puede consultar por subconjuntos o conjuntos propios. El conjunto A
es un subconjunto de B, si B contiene todos los elementos de A. El conjunto A
es un conjunto propio de B si B contiene todos los elementos que contiene A
y ninguno más.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isProperSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>También podemos usar las funciones <code class="docutils literal notranslate"><span class="pre">map</span></code> y <code class="docutils literal notranslate"><span class="pre">filter</span></code> con ellos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Los conjuntos son normalmente utilizados para eliminar los elementos
duplicados de una lista de forma que primero hacemos un conjunto con`
<code class="docutils literal notranslate"><span class="pre">`fromList</span></code> y luego lo volvemos a convertir en una lista con <code class="docutils literal notranslate"><span class="pre">toList</span></code>.
La función <code class="docutils literal notranslate"><span class="pre">nub</span></code> de <code class="docutils literal notranslate"><span class="pre">Data.List</span></code> ya realiza esta tarea, pero si estas
eliminando duplicados de un gran lista es mucho más eficiente si insertar los
elementos en un conjunto y luego convertirlo en una lista en lugar de utilizar
<code class="docutils literal notranslate"><span class="pre">nub</span></code>.  Pero <code class="docutils literal notranslate"><span class="pre">nub</span></code> solo requiere que los elemento de la lista sean de la
clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, mientras que los elementos de los conjuntos deben ser
de la clase <code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">setNub</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">toList</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">setNub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot; ACEHIKLNRSTWY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot;HEY WATSCRKLIN&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">setNub</span></code> es mucho más rápido que <code class="docutils literal notranslate"><span class="pre">nub</span></code> para listas grandes, pero como
puedes ver, <code class="docutils literal notranslate"><span class="pre">nub</span></code> preserva el orden en los que los elementos aparecen en la
lista mientras que <code class="docutils literal notranslate"><span class="pre">setNub</span></code> no.</p>
</div>
<div class="section" id="creando-nuestros-propios-modulos">
<h2>Creando nuestros propios módulos<a class="headerlink" href="#creando-nuestros-propios-modulos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Creando módulos" class="align-right" src="../_images/making_modules.png" />
<p>Hasta ahora hemos visto unos cuantos módulos interesantes, pero ¿Cómo creamos
nuestros propios módulos? Casi todo lenguaje de programación te permite que
dividas tu código en varios ficheros y Haskell no es diferente. Cuando creamos
programas, es una buena práctica que las funciones y tipos que de alguna forma
están relacionados estén en el mismo módulo. De esta forma, podemos fácilmente
reutilizar esas funciones en otros programas importando esos módulos.</p>
<p>Vamos a ver como podemos crear nuestro propio módulo haciendo un pequeño
módulo que exporte funciones que nos permitan calcular el volumen y el área de
unos cuantos objetos geométricos. Empezaremos creando un fichero llamado
<code class="docutils literal notranslate"><span class="pre">Geometry.hs</span></code>.</p>
<p>Decimos que un módulo exporta unas funciones. Lo que significa que cuando
utilizamos un módulo, podemos ver las funciones que dicho modulo exporta.
Puede definir funciones que son llamadas internamente, pero solo podemos ver
las funciones que exporta.</p>
<p>Especificamos el nombre de un módulo al principio del módulo. Si hemos llamado
al fichero <code class="docutils literal notranslate"><span class="pre">Geometry.hs</span></code> debemos darle el nombre de <code class="docutils literal notranslate"><span class="pre">Geomtry</span></code> a nuestro
módulo. Luego, especificamos la funciones que se exportan, y luego comenzamos
a definir dichas funciones. Así que empezamos con esto.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>Como observamos, vamos a calcular el área y el volumen de las esferas, cubos y
hexaedros. Continuemos y definamos estas funciones:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">sphereVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereVolume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">sphereArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereArea</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">cubeVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeVolume</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidVolume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cubeArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeArea</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidArea</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cuboidVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidVolume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">cuboidArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidArea</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p>Geometría clásica. Aunque hay un par de cosas que destacar. Como un cubo es un
caso especial de un hexaedro, hemos definido el área y el volumen tratándolo
como un hexaedro con todos sus lados iguales. También hemos definido una
función auxiliar llamada <code class="docutils literal notranslate"><span class="pre">rectangleArea</span></code>, la cual calcula el área de un
rectángulo basándose en el tamaño de sus lados. Es muy trivial ya que se
trata de una multiplicación. Hemos utilizado esta función en las funciones
<code class="docutils literal notranslate"><span class="pre">cuboidArea</span></code> y <code class="docutils literal notranslate"><span class="pre">cuboidVolume</span></code> pero no la hemos exportado. Esto es debido a
que queremos que nuestro módulo solo muestre funciones para tratar estos tres
objetos dimensionales, hemos utilizado <code class="docutils literal notranslate"><span class="pre">rectangleArea</span></code> pero no la hemos
exportado.</p>
<p>Cuando estamos creando un módulo, normalmente exportamos solo las funciones
que actúan como una especia de interfaz de nuestro módulo de forma que la
implementación se mantenga oculta. Si alguien usa nuestro módulo <code class="docutils literal notranslate"><span class="pre">Geometry</span></code>,
no nos tenemos que preocupar por funciones las funciones que no exportamos.
Podemos decidir cambiar esas funciones por completo o eliminarlas a cambio
de una nueva versión (podríamos eliminar <code class="docutils literal notranslate"><span class="pre">rectangleArea</span></code> y utilizar <code class="docutils literal notranslate"><span class="pre">*</span></code>)
y nadie se daría cuenta ya que no las estamos exportando.</p>
<p>Para utilizar nuestro módulos simplemente usamos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry</span>
</pre></div>
</div>
<p>Aunque <code class="docutils literal notranslate"><span class="pre">Geometry.hs</span></code> debe estar en el mismo directorio que el programa que
lo está utilizando.</p>
<p>También podemos dar a los módulos una estructura jerárquica. Cada módulo puede
tener cualquier número de submódulos y ellos mismo pueden tener cualquier otro
número de submódulos. Vamos a dividir las funciones del módulo <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> en
tres submódulos de forma de cada objeto tenga su propio módulo.</p>
<p>Primero creamos un directorio llamado <code class="docutils literal notranslate"><span class="pre">Geometry</span></code>. Mantén la G en mayúsculas.
Dentro de él crearemos los ficheros <code class="docutils literal notranslate"><span class="pre">sphere.hs</span></code>, <code class="docutils literal notranslate"><span class="pre">cuboid.hs</span></code>, y
<code class="docutils literal notranslate"><span class="pre">cube.hs</span></code>. Este será el contenido de los ficheros:</p>
<p><code class="docutils literal notranslate"><span class="pre">sphere.hs</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Sphere</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cuboid.hs</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cuboid</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cube.hs</span></code></p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cube</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">volume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">area</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>
</pre></div>
</div>
<p>¡Bien! El primero es <code class="docutils literal notranslate"><span class="pre">Geometry.Sphere</span></code>. Fíjate que primero hemos creado
una carpeta llamada <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> y luego y luego hemos definido el nombre como
<code class="docutils literal notranslate"><span class="pre">Geometry.Sphere</span></code>. Hicimos los mismo con el hexaedro. Fíjate también que
en los tres módulos hemos definido funciones con los mismos nombres. Podemos
hacer esto porque están separados en módulos distintos. Queremos utilizar las
funciones de <code class="docutils literal notranslate"><span class="pre">Geometry.Cuboid</span></code> en <code class="docutils literal notranslate"><span class="pre">Geometry.Cube</span></code> pero no podemos usar
simplemente <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">Geometry.Cuboid</span></code> ya que importaríamos funciones con el
mismo nombre que en <code class="docutils literal notranslate"><span class="pre">Geometry.Cube</span></code>. Por este motivo lo cualificamos.</p>
<p>Así que si ahora estamos en un fichero que se encuentra en el mismo lugar
que la carpeta <code class="docutils literal notranslate"><span class="pre">Geometry</span></code> podemos utilizar:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry.Sphere</span>
</pre></div>
</div>
<p>Y luego podemos utilizar <code class="docutils literal notranslate"><span class="pre">area</span></code> y <code class="docutils literal notranslate"><span class="pre">volume</span></code> y nos darán el área y el
volumen de una esfera. Si queremos usar dos o más módulos de éstos, tenemos
que cualificarlos para que no hayan conflictos con los nombres. Podemos usar
algo como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Sphere</span> <span class="k">as</span> <span class="n">Sphere</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cube</span> <span class="k">as</span> <span class="n">Cube</span>
</pre></div>
</div>
<p>Ahora podemos llamar a <code class="docutils literal notranslate"><span class="pre">Sphere.area</span></code>, <code class="docutils literal notranslate"><span class="pre">Sphere.volume</span></code>, <code class="docutils literal notranslate"><span class="pre">Cuboid.area</span></code>,
etc. y cada uno calculará el área o el volumen de su respectivo objeto.</p>
<p>La próxima que te encuentres escribiendo un módulo que es muy grande y tienen
un montón de funciones, trata de encontrar que funciones tienen un propósito
común y luego intenta ponerlas en un mismo módulo. De esta forma, serás capaz
de importar dicho módulo la próxima vez que escribas un programa y requiera la
misma funcionalidad.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="clasesdetipos.html" title="Creando nuestros propios tipos y clases de tipos"
             >siguiente</a></li>
        <li class="right" >
          <a href="ordensuperior.html" title="Funciones de orden superior"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>