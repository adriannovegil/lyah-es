
<!DOCTYPE html>

<html lang="es">
  <head>
    <meta charset="utf-8" />
    <title>Creando nuestros propios tipos y clases de tipos &#8212; documentación de ¡Aprende Haskell por el bien de todos! - 0.1</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Entrada y salida" href="entradasalida.html" />
    <link rel="prev" title="Módulos" href="modulos.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="entradasalida.html" title="Entrada y salida"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="modulos.html" title="Módulos"
             accesskey="P">anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="creando-nuestros-propios-tipos-y-clases-de-tipos">
<h1>Creando nuestros propios tipos y clases de tipos<a class="headerlink" href="#creando-nuestros-propios-tipos-y-clases-de-tipos" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En capítulos anteriores vimos algunos tipos y clases de tipos de Haskell. ¡En
este capítulo vamos a ver como crearlos nosotros mismos! ¿A qué no te lo
esperabas?</p>
<div class="section" id="introduccion-a-los-tipos-de-datos-algebraicos">
<h2>Introducción a los tipos de datos algebraicos<a class="headerlink" href="#introduccion-a-los-tipos-de-datos-algebraicos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta ahora hemos jugado con muchos tipos: <code class="docutils literal notranslate"><span class="pre">Bool</span></code>, <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Char</span></code>,
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, etc. Pero ¿Cómo los creamos? Bueno, una forma es usar la palabra
clave <code class="docutils literal notranslate"><span class="pre">data</span></code> para definir un tipo. Vamos a ver como está definido el tipo
<code class="docutils literal notranslate"><span class="pre">Bool</span></code> en la librería estándar:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">data</span></code> significa que vamos a definir un nuevo tipo de dato. La parte a la
izquierda del <code class="docutils literal notranslate"><span class="pre">=</span></code> denota el tipo, que es <code class="docutils literal notranslate"><span class="pre">Bool</span></code>. La parte a la derecha
son los <strong>constructores de datos</strong>. Estos especifican los diferentes valores
que puede tener un tipo. El <code class="docutils literal notranslate"><span class="pre">|</span></code> se puede leer como una <em>o</em>. Así que lo
podemos leer como: El tipo <code class="docutils literal notranslate"><span class="pre">Bool</span></code> puede tener un valor <code class="docutils literal notranslate"><span class="pre">True</span></code> o <code class="docutils literal notranslate"><span class="pre">False</span></code>.
Tanto el nombre del tipo como el de los constructores de datos deben tener
la primera letra en mayúsculas.</p>
<p>De la misma forma podemos pensar que el tipo <code class="docutils literal notranslate"><span class="pre">Int</span></code> está definido como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">2147483648</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2147483647</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">2147483647</span>
</pre></div>
</div>
<img alt="Hombre de las cavernas" class="align-left" src="../_images/caveman.png" />
<p>El primer y el último constructor de datos son el mínimo y el máximo valor
posible del tipo <code class="docutils literal notranslate"><span class="pre">Int</span></code>. En realidad no está definido así, los tres puntos
están ahí porque hemos omitido una buena cantidad de números, así que esto
es solo para motivos ilustrativos.</p>
<p>Ahora vamos a pensar en como definiríamos una figura en Haskell. Una forma
sería usar tuplas. Un círculo podría ser <code class="docutils literal notranslate"><span class="pre">(43.1,</span> <span class="pre">55.0,</span> <span class="pre">10.4)</span></code> donde el
primer y el segundo campo son las coordenadas del centro del círculo mientras
que el tercer campo sería el radio. Suena bien, pero esto nos permitiría
también definir un vector 3D o cualquier otra cosa. Una solución mejor sería
crear nuestro propio tipo que represente una figura. Digamos que una figura
solo puede ser un círculo o un rectángulo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>
</pre></div>
</div>
<p>¿Qué es esto? Piensa un poco a que se parece. El constructor de datos`
<code class="docutils literal notranslate"><span class="pre">Circle</span></code> tiene tres campos que toman valores en coma flotante. Cuando
creamos un constructor de datos, opcionalmente podemos añadir tipos después
de él de forma que estos serán los valores que contenga. Aquí, los primeros
dos componentes son las coordenadas del centro, mientras que el tercero es
el radio. El constructor de datos <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code> tiene cuatro campos que
aceptan valores en coma flotante. Los dos primeros representan las coordenadas
de la esquina superior izquierda y los otros dos las coordenadas de la
inferior derecha.</p>
<p>Ahora, cuando hablamos de campos, en realidad estamos hablando de parámetros.
Los constructores de datos son en realidad funciones que devuelven un valor
del tipo para el que fueron definidos. Vamos a ver la declaración de tipo de
estos dos constructores de datos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Circle</span>
<span class="kt">Circle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Rectangle</span>
<span class="kt">Rectangle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
</pre></div>
</div>
<p>Bien, los constructores de datos son funciones como todo lo demás ¿Quíen lo
hubiera pensado? Vamos a hacer una función que tome una figura y devuleva su
superficie o área:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div>
</div>
<p>La primera cosa destacable aquí es la declaración de tipo. Dice que toma una
figura y devuelve un valor en coma flotante. No podemos escribir una
declaración de tipo como <code class="docutils literal notranslate"><span class="pre">Circle</span> <span class="pre">-&gt;</span> <span class="pre">Float</span></code> ya que <code class="docutils literal notranslate"><span class="pre">Circle</span></code> no es un tipo,
<code class="docutils literal notranslate"><span class="pre">Shape</span></code> si lo es. Del mismo modo no podemos declarar una función cuya
declaración de tipo sea <code class="docutils literal notranslate"><span class="pre">True</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code>. La siguiente cosa que podemos
destacar es que podemos usar el ajuste de patrones con los constructores. Ya
hemos utilizado el ajuste de patrones con constructores anteriormente (en
realidad todo el tiempo) cuando ajustamos valores como <code class="docutils literal notranslate"><span class="pre">[]</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">5</span></code>, solo que esos valores no tienen campos. Simplemente escribimos el
constructor y luego ligamos sus campos a nombres. Como estamos interesados en
el radio, realmente no nos importan los dos primeros valores que nos dicen
donde está el círculo.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">10</span>
<span class="mf">314.15927</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">100</span> <span class="mi">100</span>
<span class="mf">10000.0</span>
</pre></div>
</div>
<p>Bien ¡Funciona! Pero si intentamos mostrar por pantalla <code class="docutils literal notranslate"><span class="pre">Circle</span> <span class="pre">10</span> <span class="pre">20</span> <span class="pre">5</span></code>
en una sesión de GHCi obtendremos un error. Esto sucede porque Haskell aún no
sabe como representar nuestro tipo con una cadena. Recuerda que cuando
intentamos mostrar un valor por pantalla, primero Haskell ejecuta la función
<code class="docutils literal notranslate"><span class="pre">show</span></code> para obtener la representación en texto de un dato y luego lo muestra
en la terminal. Para hacer que nuestro tipo <code class="docutils literal notranslate"><span class="pre">Shape</span></code> forme parte de la clase
de tipo <code class="docutils literal notranslate"><span class="pre">Show</span></code> hacemos esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>No vamos a preocuparnos ahora mismo acerca de derivar. Simplemente diremos que
si añadimos <code class="docutils literal notranslate"><span class="pre">deriving</span> <span class="pre">(Show)</span></code> al final de una declaración de tipo,
automáticamente Haskell hace que ese tipo forme parte de la clase de tipos
<code class="docutils literal notranslate"><span class="pre">Show</span></code>. Así que ahora ya podemos hacer esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="mi">50</span> <span class="mi">230</span> <span class="mi">60</span> <span class="mi">90</span>
<span class="kt">Rectangle</span> <span class="mf">50.0</span> <span class="mf">230.0</span> <span class="mf">60.0</span> <span class="mf">90.0</span>
</pre></div>
</div>
<p>Los constructores de datos son funciones, así que podemos mapearlos,
aplicarlos parcialmente o cualquier otra cosa. Si queremos una lista de
círculos concéntricos con diferente radio podemos escribir esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">4.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Nuestro tipo de dato es bueno, pero podría se mejor. Vamos a crear un tipo de
dato intermedio que defina un punto en espacio bidimensional. Luego lo
usaremos para hacer nuestro tipo más evidente.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Te habrás dado cuenta de que hemos usado el mismo nombre para el tipo que para
el constructor de datos. No tiene nada de especial, es algo común usar el
mismo nombre que el del tipo si solo hay un constructor de datos. Así que
ahora <code class="docutils literal notranslate"><span class="pre">Circle</span></code> tiene dos campos, uno es el del tipo <code class="docutils literal notranslate"><span class="pre">Point</span></code> y el otro del
tipo <code class="docutils literal notranslate"><span class="pre">Float</span></code>. De esta forma es más fácil entender que es cada cosa. Lo mismo
sucede para el rectángulo. Tenemos que modificar nuestra función <code class="docutils literal notranslate"><span class="pre">surface</span></code>
para que refleje estos cambios.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div>
</div>
<p>Lo único que hemos cambiado han sido los patrones. Hemos descartado
completamente el punto en el patrón del círculo. Por otra parte, en  el patrón
del rectángulo, simplemente hemos usado un ajuste de patrones anidado para
obtener las coordenadas de los puntos. Si hubiésemos querido hacer una
referencia directamente a los puntos por cualquier motivo podríamos haber
utilizado un patrón <em>como</em>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">100</span> <span class="mi">100</span><span class="p">))</span>
<span class="mf">10000.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
<span class="mf">1809.5574</span>
</pre></div>
</div>
<p>¿Cómo sería una función que desplaza una figura? Tomaría una figura, la
cantidad que se debe desplazar en el eje <em>x</em>, la cantidad que se debe desplazar
en el eje <em>y</em> y devolvería una nueva figura con las mismas dimensiones pero
desplazada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">nudge</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="n">r</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y2</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>Bastante sencillo. Añadimos las cantidades a desplazar a los puntos que
representan la posición de las figuras.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">34</span> <span class="mi">34</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span>
<span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">39.0</span> <span class="mf">44.0</span><span class="p">)</span> <span class="mf">10.0</span>
</pre></div>
</div>
<p>Si no queremos trabajar directamente con puntos, podemos crear funciones
auxiliares que creen figuras de algún tamaño en el centro del eje de
coordenadas de modo que luego las podamos desplazar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">baseCircle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseCircle</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span>

<span class="nf">baseRect</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseRect</span> <span class="n">width</span> <span class="n">height</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">width</span> <span class="n">height</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="n">baseRect</span> <span class="mi">40</span> <span class="mi">100</span><span class="p">)</span> <span class="mi">60</span> <span class="mi">23</span>
<span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">60.0</span> <span class="mf">23.0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">100.0</span> <span class="mf">123.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Como es lógico, podemos exportar nuestros datos en los módulos. Para hacerlo,
solo tenemos que escribir el nombre del tipo juntos a las funciones
exportadas, y luego añadirles unos paréntesis que contengan los constructores
de datos que queramos que se exporten, separados por comas. Si queremos que se
exporten todos los constructores de datos para un cierto tipo podemos usar
<code class="docutils literal notranslate"><span class="pre">..</span></code>.</p>
<p>Si quisiéramos exportar las funciones y tipos que acabamos de crear en un
módulo, podríamos empezar con esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Shapes</span>
<span class="p">(</span> <span class="kt">Point</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="kt">Shape</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="nf">surface</span>
<span class="p">,</span> <span class="nf">nudge</span>
<span class="p">,</span> <span class="nf">baseCircle</span>
<span class="p">,</span> <span class="nf">baseRect</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>Haciendo <code class="docutils literal notranslate"><span class="pre">Shape</span> <span class="pre">(..)</span></code> estamos exportando todos los constructores de datos
de <code class="docutils literal notranslate"><span class="pre">Shape</span></code>, lo que significa que cualquiera que importe nuestro módulo puede
crear figuras usando los constructores <code class="docutils literal notranslate"><span class="pre">Circle</span></code> y <code class="docutils literal notranslate"><span class="pre">Rectangle</span></code>. Sería lo
mismo que escribir <code class="docutils literal notranslate"><span class="pre">Shape</span> <span class="pre">(Rectangle,</span> <span class="pre">Circle)</span></code>.</p>
<p>También podríamos optar por no exportar ningún constructor de datos para
<code class="docutils literal notranslate"><span class="pre">Shape</span></code> simplemente escribiendo <code class="docutils literal notranslate"><span class="pre">Shape</span></code> en dicha sentencia. De esta forma,
quien importe nuestro módulo solo podrá crear figuras utilizando las
funciones auxiliares <code class="docutils literal notranslate"><span class="pre">baseCircle</span></code> y <code class="docutils literal notranslate"><span class="pre">baseRect</span></code>. <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> utiliza este
método. No puedes crear un diccionario utilizando <code class="docutils literal notranslate"><span class="pre">Map.Map</span> <span class="pre">[(1,2),(3,4)]</span></code> ya
que no se exporta el constructor de datos. Sin embargo, podemos crear un
diccionario utilizando funciones auxiliares como <code class="docutils literal notranslate"><span class="pre">Map.fromList</span></code>. Recuerda,
los constructores de datos son simples funciones que toman los campos del tipo
como parámetros y devuelven un valor de un cierto tipo (como <code class="docutils literal notranslate"><span class="pre">Shape</span></code>) como
resultado. Así que cuando elegimos no exportarlos, estamos previniendo que la
gente que importa nuestro módulo pueda utilizar esas funciones, pero si alguna
otra función devuelve devuelve el tipo que estamos exportando, las podemos
utilizar para crear nuestros propios valores de ese tipo.</p>
<p>No exportar los constructores de datos de un tipo de dato lo hace más
abstracto en el sentido de que oculta su implementación. Sin embargo, los
usuarios del módulo no podrán usar el ajuste de patrones sobre ese tipo.</p>
</div>
<div class="section" id="sintaxis-de-registro">
<h2>Sintaxis de registro<a class="headerlink" href="#sintaxis-de-registro" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Tocadiscos" class="align-right" src="../_images/record.png" />
<p>Bien, se nos ha dado la tarea de crear un tipo que describa a una persona.
La información que queremos almacenar de cada persona es: nombre, apellidos,
edad, altura, número de teléfono y el sabor de su helado favorito. No se nada
acerca de ti, pero para mi es todo lo que necesito saber de una persona.
¡Vamos allá!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Vale. El primer campo es el nombre, el segundo el apellido, el tercero su
edad y seguimos contando. Vamos a crear una persona.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">guy</span>
<span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
</pre></div>
</div>
<p>Parece interesante, pero desde luego no muy legible ¿Y si queremos crear una
función que obtenga información por separado de una persona? Una función que
obtenga el nombre de una persona, otra función que obtenga el apellido, etc.
Bueno, las tendríamos que definir así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">firstName</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">firstname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>

<span class="nf">lastName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lastName</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">lastname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>

<span class="nf">age</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">age</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">age</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">age</span>

<span class="nf">height</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">height</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">height</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">height</span>

<span class="nf">phoneNumber</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">phoneNumber</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">number</span>

<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">flavor</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">flavor</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flavor</span>
</pre></div>
</div>
<p>¡Fiuuu! La verdad es que no me divertido escribiendo esto. A parte de que este
método sea un lío y un poco ABURRIDO de escribir, funciona.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">firstName</span> <span class="n">guy</span>
<span class="s">&quot;Buddy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">height</span> <span class="n">guy</span>
<span class="mf">184.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flavor</span> <span class="n">guy</span>
<span class="s">&quot;Chocolate&quot;</span>
</pre></div>
</div>
<p>Ahora es cuando piensas: debe de haber un método mejor. Pues no, lo siento
mucho.</p>
<p>Estaba de broma :P Si que lo hay. Los creadores de Haskell fueron muy
inteligentes y anticiparon este escenario. Incluyeron un método alternativo
de definir tipos de dato. Así es como podríamos conseguir la misma
funcionalidad con la sintaxis de registro.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">,</span> <span class="n">height</span> <span class="ow">::</span> <span class="kt">Float</span>
                     <span class="p">,</span> <span class="n">phoneNumber</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">flavor</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>En lugar de nombrar los campos uno tras otro separados por espacios,
utilizamos un par de llaves. Dentro, primero escribimos el nombre de un campo,
por ejemplo <code class="docutils literal notranslate"><span class="pre">firstName</span></code> y luego escribimos unos dobles puntos <code class="docutils literal notranslate"><span class="pre">::</span></code>
(también conocido como <em>Paamayim Nekudotayim</em> xD) y luego especificamos el
tipo. El tipo de dato resultante es exactamente el mismo. La principal
diferencia es que de esta forma se crean funciones que obtienen esos campos
del tipo de dato. Al usar la sintaxis de registro con este tipo de dato,
Haskell automáticamente crea estas funciones: <code class="docutils literal notranslate"><span class="pre">firstName</span></code>, <code class="docutils literal notranslate"><span class="pre">lastName</span></code>,
<code class="docutils literal notranslate"><span class="pre">age</span></code>, <code class="docutils literal notranslate"><span class="pre">height</span></code>, <code class="docutils literal notranslate"><span class="pre">phoneNumber</span></code> y <code class="docutils literal notranslate"><span class="pre">flavor</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flavor</span>
<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">firstName</span>
<span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>Hay otro beneficio cuando utilizamos la sintaxis de registro. Cuando derivamos
<code class="docutils literal notranslate"><span class="pre">Show</span></code> para un tipo, mostrará los datos de forma diferente si utilizamos la
sintaxis de registro para definir e instanciar el tipo. Supongamos que tenemos
un tipo que representa un coche. Queremos mantener un registro de la compañía
que lo hizo, el nombre del modelo y su años de producción. Mira.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
</pre></div>
</div>
<p>Si lo definimos usando la sintaxis de registro, podemos crear un coche nuevo
de esta forma:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="mi">1967</span><span class="p">}</span>
</pre></div>
</div>
<p>Cuando creamos un coche nuevo, no hace falta poner los campos en el orden
adecuado mientras que los pongamos todos. Pero si no usamos la sintaxis de
registro debemos especificarlos en su orden correcto.</p>
<p>Utiliza la sintaxis de registro cuando un constructor tenga varios campos y no
sea obvio que campo es cada uno. Si definimos el tipo de un vector 3D como
<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">Vector</span> <span class="pre">=</span> <span class="pre">Vector</span> <span class="pre">Int</span> <span class="pre">Int</span> <span class="pre">Int</span></code>, es bastante obvio que esos campos son
las componentes del vector. Sin embargo, en nuestros tipo <code class="docutils literal notranslate"><span class="pre">Person</span></code> y
<code class="docutils literal notranslate"><span class="pre">Car</span></code>, no es tan obvio y nos beneficia mucho el uso de esta sintaxis.</p>
</div>
<div class="section" id="parametros-de-tipo">
<h2>Parámetros de tipo<a class="headerlink" href="#parametros-de-tipo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un constructor de datos puede tomar algunos valores como parámetros y producir
un nuevo valor. Por ejemplo, el constructor <code class="docutils literal notranslate"><span class="pre">Car</span></code> toma tres valores y
produce un valor del tipo coche. De forma similar, un <strong>constructor de tipos</strong>
puede tomar tipos como parámetros y producir nuevos tipos. Esto puede parecer
un poco recursivo al principio, pero no es nada complicado. Si has utilizado
las plantillas de <em>C++</em> te será familiar. Para obtener una imagen clara de
como los parámetros de tipo funcionan en realidad, vamos a ver un ejemplo de
como un tipo que ya conocemos es implementado.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<img alt="Yeti" class="align-left" src="../_images/yeti.png" />
<p>La <code class="docutils literal notranslate"><span class="pre">a</span></code> es un parámetro de tipo. Debido a que hay un parámetro de tipo
involucrado en esta definición, llamamos a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> un constructor de tipos.
Dependiendo de lo que queramos que este tipo contenga cuando un valor no es
<code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, este tipo puede acabar produciendo tipos como <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>,
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Car</span></code>, <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">String</span></code>, etc. Ningún valor puede tener un tipo que sea
simplemente <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, ya que eso no es un tipo por si mismo, es un
constructor de tipos. Para que sea un tipo real que algún valor pueda tener,
tiene que tener todos los parámetros de tipo definidos.</p>
<p>Si pasamos <code class="docutils literal notranslate"><span class="pre">Char</span></code> como parámetro de tipo a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, obtendremos el tipo
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Char</span></code>. Por ejemplo, el valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">'a'</span></code> tiene el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span>
<span class="pre">Char</span></code>.</p>
<p>Puede que no lo sepas, pero utilizamos un tipo que tenía un parámetro de tipo
antes de que empezáramos a utilizar el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Ese tipo es el tipo
lista. Aunque hay un poco decoración sintáctica, el tipo lista toma un
parámetro para producir un tipo concreto. Los valores pueden tener un tipo
<code class="docutils literal notranslate"><span class="pre">[Int]</span></code>, un tipo <code class="docutils literal notranslate"><span class="pre">[Char]</span></code>, <code class="docutils literal notranslate"><span class="pre">[[String]]</span></code>, etc. pero no puede haber un
valor cuyo tipo sea simplemente <code class="docutils literal notranslate"><span class="pre">[]</span></code>.</p>
<p>Vamos a jugar un poco con el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="kt">Just</span> <span class="mf">10.0</span>
</pre></div>
</div>
<p>Los parámetros de tipo son útiles ya que nos permiten crear diferentes tipos
dependiendo del tipo que queramos almacenar en nuestros tipos de datos (valga
la redundancia). Cuando hacemos <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">Just</span> <span class="pre">&quot;Haha&quot;</span></code> el motor de inferencia de
tipos deduce que el tipo debe ser <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">[Char]</span></code>, ya que la <code class="docutils literal notranslate"><span class="pre">a</span></code> en <code class="docutils literal notranslate"><span class="pre">Just</span>
<span class="pre">a</span></code> es una cadena, luego el <code class="docutils literal notranslate"><span class="pre">a</span></code> en <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> debe ser también una cadena.</p>
<p>Como habrás visto el tipo de <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> es <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. Su tipo es
polimórfico. Si una función requiere un <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code> como parámetro le
podemos pasar  un <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> ya que no contiene ningún valor. El tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span>
<span class="pre">a</span></code> puede comportarse como un <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>, de la misma forma que <code class="docutils literal notranslate"><span class="pre">5</span></code> puede
comportarse como un <code class="docutils literal notranslate"><span class="pre">Int</span></code> o como un <code class="docutils literal notranslate"><span class="pre">Double</span></code>. De forma similar el tipo de
las listas vacías es <code class="docutils literal notranslate"><span class="pre">[a]</span></code>. Una lista vacía puede comportarse como cualquier
otra lista. Por eso podemos hacer cosas como <code class="docutils literal notranslate"><span class="pre">[1,2,3]</span> <span class="pre">++</span> <span class="pre">[]</span></code> y
<code class="docutils literal notranslate"><span class="pre">[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;]</span> <span class="pre">++</span> <span class="pre">[]</span></code>.</p>
<p>El uso de parámetros de tipo nos puede beneficiar, pero solo en los casos que
tenga sentido. Normalmente los utilizamos cuando nuestro tipo de dato
funcionará igual sin importar el tipo de dato que contenga, justo como nuestro
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. Si nuestro tipo es como una especie de caja, es un buen lugar
para usar los parámetros de tipo. Podríamos cambiar nuestro tipo <code class="docutils literal notranslate"><span class="pre">Car</span></code> de:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span>
               <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>A:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="n">a</span>
                     <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="n">b</span>
                     <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="n">c</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Pero ¿Tiene algún beneficio? La respuesta es: probablemente no, ya que al
final acabaremos escribiendo funciones que solo funcionen con el tipo <code class="docutils literal notranslate"><span class="pre">Car</span>
<span class="pre">String</span> <span class="pre">String</span> <span class="pre">Int</span></code>. Por ejemplo, dada la primera definición de <code class="docutils literal notranslate"><span class="pre">Car</span></code>,
podríamos crear una función que mostrara las propiedades de un coche con un
pequeño texto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tellCar</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stang</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="n">stang</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
</pre></div>
</div>
<p>¡Una función muy bonita! La declaración de tipo es simple y funciona
perfectamente. Ahora ¿Cómo sería si <code class="docutils literal notranslate"><span class="pre">Car</span></code> fuera en realidad <code class="docutils literal notranslate"><span class="pre">Car</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code>?</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">tellCar</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div>
</div>
<p>Tenemos que forzar a que la función tome un <code class="docutils literal notranslate"><span class="pre">Car</span></code> del tipo <code class="docutils literal notranslate"><span class="pre">(Show</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">Car</span>
<span class="pre">String</span> <span class="pre">String</span> <span class="pre">a</span></code>. Podemos ver como la definición de tipo es mucho más
complicada y el único beneficio que hemos obtenido es que podamos usar
cualquier tipo que sea una instancia de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Show</span></code> como
parámetro <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in </span><span class="se">\&quot;</span><span class="s">nineteen sixty seven</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<img alt="Suricato" class="align-right" src="../_images/meekrat.png" />
<p>A la hora de la verdad, acabaríamos utilizando <code class="docutils literal notranslate"><span class="pre">Car</span> <span class="pre">String</span> <span class="pre">String</span> <span class="pre">Int</span></code> la
mayor parte del tiempo y nos daríamos cuenta de que parametrizar el tipo
<code class="docutils literal notranslate"><span class="pre">Car</span></code> realmente no importa. Normalmente utilizamos los parámetros de tipo
cuando el tipo que está contenido dentro del tipo de dato no es realmente
importante a la hora de trabajar con éste. Una lista de cosas es una lista
de cosas y no importa que sean esas cosas, funcionará igual. Si queremos sumar
una lista de números, mas tarde podemos especificar en la propia función de
suma de que queremos específicamente una lista de números. Lo mismo pasa con
<code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> representa la opción de tener o no tener un valor.
Realmente no importa de que tipo sea ese valor.</p>
<p>Otro ejemplo de un tipo parametrizado que ya conocemos es el tipo <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></code>
de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>. <code class="docutils literal notranslate"><span class="pre">k</span></code> es el tipo para las claves del diccionario mientras que
<code class="docutils literal notranslate"><span class="pre">v</span></code> es el tipo de los valores. Este es un buen ejemplo en donde los
parámetros de tipo son útiles. Al tener los diccionarios parametrizados nos
permiten asociar cualquier tipo con cualquier otro tipo, siempre que la clave
del tipo sea de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Ord</span></code>. Si estuviéramos definiendo el tipo
diccionario podríamos añadir una restricción de clase en la definición:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Sin embargo, existe un consenso en el mundo Haskell de que <strong>nunca debemos
añadir restricciones de clase a las definiciones de tipo</strong>. ¿Por qué? Bueno,
porque no nos beneficia mucho, pero al final acabamos escribiendo más
restricciones de clase, incluso aunque no las necesitemos. Si ponemos o no
podemos la restricción de clase <code class="docutils literal notranslate"><span class="pre">Ord</span> <span class="pre">k</span></code> en la definición de tipo de <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span>
<span class="pre">v</span></code>, tendremos que poner de todas formas la restricción de clase en las
funciones que asuman que las claves son ordenables. Pero si no ponemos la
restricción en la definición de tipo, no tenemos que poner <code class="docutils literal notranslate"><span class="pre">(Ord</span> <span class="pre">k)</span> <span class="pre">=&gt;</span></code> en
la declaración de tipo de las funciones que no les importe si la clave puede
es ordenable o no. Un ejemplo de esto sería la función <code class="docutils literal notranslate"><span class="pre">toList</span></code> que
simplemente convierte un diccionario en una lista de asociación. Su
declaración de tipo es <code class="docutils literal notranslate"><span class="pre">toList</span> <span class="pre">::</span> <span class="pre">Map</span> <span class="pre">k</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">a)]</span></code>. Si <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></code>
tuviera una restricción en su declaración, el tipo de <code class="docutils literal notranslate"><span class="pre">toList</span></code> debería haber
sido <code class="docutils literal notranslate"><span class="pre">toList</span> <span class="pre">::</span> <span class="pre">(Ord</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">Map</span> <span class="pre">k</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">a)]</span></code> aunque la función no
necesite comparar ninguna clave.</p>
<p>Así que no pongas restricciones de clase en las declaraciones de tipos aunque
tenga sentido, ya que al final las vas a tener que poner de todas formas en
las declaraciones de tipo de las funciones.</p>
<p>Vamos a implementar un tipo para vectores 3D y crear algunas operaciones con
ellos. Vamos a usar un tipo parametrizado ya que, aunque normalmente contendrá
números, queremos que soporte varios tipos de ellos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">vplus</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>

<span class="nf">vectMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>

<span class="nf">scalarMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">n</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">vplus</span></code> sirve para sumar dos vectores. Los vectores son sumados simplemente
sumando sus correspondientes componentes. <code class="docutils literal notranslate"><span class="pre">scalarMult</span></code> calcula el producto
escalar de dos vectores y <code class="docutils literal notranslate"><span class="pre">vectMult</span></code> calcula el producto de un vector y un
escalar. Estas funciones pueden operar con tipos como <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">Int</span></code>,
<code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">Integer</span></code>, <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">Float</span></code> o cualquier otra cosa mientras <code class="docutils literal notranslate"><span class="pre">a</span></code> de
<code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">a</span></code> sea miembro de clase de tipos <code class="docutils literal notranslate"><span class="pre">Num</span></code>. También, si miras la
declaración de tipo de estas funciones, veras que solo pueden operar con
vectores del mismo tipo y los números involucrados (como en <code class="docutils literal notranslate"><span class="pre">vectMult</span></code>)
también deben ser del mismo tipo que el que contengan los vectores. Fíjate en
que no hemos puesto una restricción de clase <code class="docutils literal notranslate"><span class="pre">Num</span></code> en la declaración del
tipo <code class="docutils literal notranslate"><span class="pre">Vector</span></code>, ya que deberíamos haberlo repetido también en las
declaraciones de las funciones.</p>
<p>Una vez más, es muy importante distinguir entre constructores de datos y
constructores de tipo. Cuando declaramos un tipo de dato, la parte anterior al
<code class="docutils literal notranslate"><span class="pre">=</span></code> es el constructor de tipos, mientras que la parte que va después
(posiblemente separado por <code class="docutils literal notranslate"><span class="pre">|</span></code>) son los constructores de datos. Dar a una
función el tipo <code class="docutils literal notranslate"><span class="pre">Vector</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">Vector</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">t</span></code> sería incorrecto ya que
hemos usado tipos en la declaración y el constructor de tipos vector toma un
solo parámetro, mientras que el constructor de datos toma tres. Vamos a jugar
un poco con los vectores:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">7</span> <span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">9</span> <span class="mi">19</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">7</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="mi">10</span>
<span class="kt">Vector</span> <span class="mi">30</span> <span class="mi">90</span> <span class="mi">70</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mf">9.0</span> <span class="mf">2.0</span> <span class="mf">4.0</span>
<span class="mf">74.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">2</span> <span class="mi">9</span> <span class="mi">3</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Vector</span> <span class="mi">148</span> <span class="mi">666</span> <span class="mi">222</span>
</pre></div>
</div>
</div>
<div class="section" id="instancias-derivadas">
<h2>Instancias derivadas<a class="headerlink" href="#instancias-derivadas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Gob" class="align-right" src="../_images/gob.png" />
<p>En la sección <a class="reference internal" href="tipos.html#clases-de-tipo-1"><span class="std std-ref">Clases de tipos paso a paso (1ª parte)</span></a>, explicamos las bases de las clases de
tipo. Dijimos que una clase de tipos es una especie de interfaz que define un
comportamiento. Un tipo puede ser una <strong>instancia</strong> de esa clase si soporta
ese comportamiento. Ejemplo: El tipo <code class="docutils literal notranslate"><span class="pre">Int</span></code> es una instancia de la clase
<code class="docutils literal notranslate"><span class="pre">Eq</span></code>, ya que la clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code> define el comportamiento de cosas que
se pueden equiparar. Y como los enteros se pueden equiparar, <code class="docutils literal notranslate"><span class="pre">Int</span></code> es parte
de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. La utilidad real está en las funciones que actúan como
interfaz de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, que son <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">/=</span></code>. Si un tipo forma parte de la
clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, podemos usar las funciones como <code class="docutils literal notranslate"><span class="pre">==</span></code> con valores de ese tipo.
Por este motivo, expresiones como <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">==</span> <span class="pre">4</span></code> y <code class="docutils literal notranslate"><span class="pre">&quot;foo&quot;</span> <span class="pre">/=</span> <span class="pre">&quot;bar&quot;</span></code> son
correctas.</p>
<p>Mencionamos también que las clases de tipos suelen ser confundidas con las
clases de lenguajes como Java, Python, C++ y demás, cosa que más tarde
desconcierta a la gente. En estos lenguajes, las clases son como un modelo del
cual podemos crear objetos que contienen un estado y pueden hacer realizar
algunas acciones. Las clases de tipos son más bien como las interfaces. No
creamos instancias a partir de las interfaces. En su lugar, primero creamos
nuestro tipo de dato y luego pensamos como qué puede comportarse. Si puede
comportarse como algo que puede ser equiparado, hacemos que sea miembro de la
clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. Si puede ser puesto en algún orden, hacemos que sea miembro de
la clase <code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
<p>Más adelante veremos como podemos hacer manualmente que nuestros
tipos sean una instancia de una clase de tipos implementando las funciones
que esta define. Pero ahora, vamos a ver como Haskell puede automáticamente
hacer que nuestros tipos pertenezcan a una de las siguientes clases: <code class="docutils literal notranslate"><span class="pre">Eq</span></code>,
<code class="docutils literal notranslate"><span class="pre">Ord</span></code>, <code class="docutils literal notranslate"><span class="pre">Enum</span></code>, <code class="docutils literal notranslate"><span class="pre">Bounded</span></code>, <code class="docutils literal notranslate"><span class="pre">Show</span></code> y <code class="docutils literal notranslate"><span class="pre">Read</span></code>. Haskell puede derivar
el comportamiento de nuestros tipos en estos contextos si usamos la palabra
clave <code class="docutils literal notranslate"><span class="pre">deriving</span></code> cuando los definimos.</p>
<p>Considera el siguiente tipo de dato:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span>
</pre></div>
</div>
<p>Describe a una persona. Vamos a asumir que ninguna persona tiene la misma
combinación de nombre, apellido y edad. Ahora, si tenemos registradas a dos
personas ¿Tiene sentido saber si estos dos registros pertenecen a la misma
persona? Parece que sí. Podemos compararlos por igualdad y ver si son iguales
o no. Por esta razón tiene sentido que este tipo se miembro de la clase de
tipo <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. Derivamos la instancia:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando derivamos una instancia de <code class="docutils literal notranslate"><span class="pre">Eq</span></code> para un tipo y luego intentamos
comparar dos valores de ese tipo usando <code class="docutils literal notranslate"><span class="pre">==</span></code> o <code class="docutils literal notranslate"><span class="pre">/=</span></code>, Haskell comprobará
si los constructores de tipo coinciden (aunque aquí solo hay un constructor
de tipo) y luego comprobará si todos los campos de ese constructor coinciden
utilizando el operador <code class="docutils literal notranslate"><span class="pre">=</span></code> para cada par de campos. Solo tenemos que tener
en cuenta una cosa, todos los campos del tipo deben ser también miembros de la
clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. Como <code class="docutils literal notranslate"><span class="pre">String</span></code> y <code class="docutils literal notranslate"><span class="pre">Int</span></code> ya son miembros, no hay ningún
problema. Vamos a comprobar nuestra instancia <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adRock</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Horovitz&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">41</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mca</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Yauch&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">44</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mca</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Como ahora <code class="docutils literal notranslate"><span class="pre">Person</span></code> forma parte de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, podemos utilizarlo como
<code class="docutils literal notranslate"><span class="pre">a</span></code> en las funciones que tengan una restricción de clase del tipo <code class="docutils literal notranslate"><span class="pre">Eq</span> <span class="pre">a</span></code>
en su declaración, como <code class="docutils literal notranslate"><span class="pre">elem</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">beastieBoys</span> <span class="ow">=</span> <span class="p">[</span><span class="n">mca</span><span class="p">,</span> <span class="n">adRock</span><span class="p">,</span> <span class="n">mikeD</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">beastieBoys</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Las clases de tipos <code class="docutils literal notranslate"><span class="pre">Show</span></code> y <code class="docutils literal notranslate"><span class="pre">Read</span></code> son para cosas que pueden ser
convertidas a o desde cadenas, respectivamente. Como pasaba con <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, si un
constructor de tipos tiene campos, su tipo debe ser miembro de la clase`
<code class="docutils literal notranslate"><span class="pre">Show</span></code> o <code class="docutils literal notranslate"><span class="pre">Read</span></code> si queremos que también forme parte de estas clases.</p>
<p>Vamos a hacer que nuestro tipo de dato <code class="docutils literal notranslate"><span class="pre">Person</span></code> forme parte también de las
clases <code class="docutils literal notranslate"><span class="pre">Show</span></code> y <code class="docutils literal notranslate"><span class="pre">Read</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</pre></div>
</div>
<p>Ahora podemos mostrar una persona por la terminal.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;mikeD is: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">mikeD</span>
<span class="s">&quot;mikeD is: Person {firstName = </span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName = </span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span>
</pre></div>
</div>
<p>Si hubiésemos intentado mostrar en la terminal una persona antes de hacer que
el tipo <code class="docutils literal notranslate"><span class="pre">Person</span></code> formara parte de la clase <code class="docutils literal notranslate"><span class="pre">Show</span></code>, Haskell se hubiera
quejado, diciéndonos que no sabe como representar una persona con una cadena.
Pero ahora que hemos derivado la clase <code class="docutils literal notranslate"><span class="pre">Show</span></code> ya sabe como hacerlo.</p>
<p><code class="docutils literal notranslate"><span class="pre">Read</span></code> es prácticamente la clase inversa de <code class="docutils literal notranslate"><span class="pre">Show</span></code>. <code class="docutils literal notranslate"><span class="pre">Show</span></code> sirve para
convertir nuestro tipo a una cadena, <code class="docutils literal notranslate"><span class="pre">Read</span></code> sirve para convertir una cadena
a nuestro tipo. Aunque recuerda que cuando uses la función <code class="docutils literal notranslate"><span class="pre">read</span></code> hay que
utilizar una anotación de tipo explícita para decirle a Haskell que tipo
queremos como resultado. Si no ponemos el tipo que queremos como resultado
explícitamente, Haskell no sabrá que tipo queremos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
</pre></div>
</div>
<p>No hace falta utilizar una anotación de tipo explícita en caso de que usemos
el resultado de la función <code class="docutils literal notranslate"><span class="pre">read</span></code> de forma que Haskell pueda inferir el
tipo.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>También podemos leer tipos parametrizados, pero tenemos que especificar todos
los parámetros del tipo. Así que no podemos hacer
<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;Just</span> <span class="pre">'t'&quot;</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">a</span></code>  pero si podemos hacer <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">&quot;Just</span> <span class="pre">'t'&quot;</span> <span class="pre">::</span>
<span class="pre">Maybe</span> <span class="pre">Char</span></code>.</p>
<p>Podemos derivar instancias para la clase de tipos <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, la cual es para
tipos cuyos valores puedan ser ordenados. Si comparamos dos valores del mismo
tipo que fueron definidos usando diferentes constructores, el valor cuyo
constructor fuera definido primero es considerado menor que el otro. Por
ejemplo, el tipo <code class="docutils literal notranslate"><span class="pre">Bool</span></code> puede tener valores <code class="docutils literal notranslate"><span class="pre">False</span></code> o <code class="docutils literal notranslate"><span class="pre">True</span></code>. Con el
objetivo de ver como se comporta cuando es comparado, podemos pensar que está
implementado de esta forma:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Como el valor <code class="docutils literal notranslate"><span class="pre">False</span></code> está definido primero y el valor <code class="docutils literal notranslate"><span class="pre">True</span></code> está
definido después, podemos considerar que <code class="docutils literal notranslate"><span class="pre">True</span></code> es mayor que <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<blockquote>
<div><p>ghci&gt; True <cite>compare</cite> False
GT
ghci&gt; True &gt; False
True
ghci&gt; True &lt; False
False</p>
</div></blockquote>
<p>En el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>, el constructor de datos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> esta definido
antes que el constructor <code class="docutils literal notranslate"><span class="pre">Just</span></code>, así que un valor <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> es siempre más
pequeño que cualquier valor <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">algo</span></code>, incluso si ese algo es menos un
billon de trillones. Pero si comparamos dos valores <code class="docutils literal notranslate"><span class="pre">Just</span></code>, entonces se
compara lo que hay dentro de él.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;</span> <span class="kt">Just</span> <span class="mi">100</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">49999</span><span class="p">)</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">GT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">100</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">50</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>No podemos hacer algo como <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">(*3)</span> <span class="pre">&gt;</span> <span class="pre">Just</span> <span class="pre">(*2)</span></code>, ya que <code class="docutils literal notranslate"><span class="pre">(*3)</span></code> y
<code class="docutils literal notranslate"><span class="pre">(*2)</span></code> son funciones, las cuales no tienen definida una instancia de
<code class="docutils literal notranslate"><span class="pre">Ord</span></code>.</p>
<p>Podemos usar fácilmente los tipos de dato algebraicos para crear
enumeraciones, y las clases de tipos <code class="docutils literal notranslate"><span class="pre">Enum</span></code> y <code class="docutils literal notranslate"><span class="pre">Bounded</span></code> nos ayudarán a
ello. Considera el siguiente tipo de dato:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Como ningún contructor de datos tiene parámetros, podemos hacerlo miembro de
la clase de tipos <code class="docutils literal notranslate"><span class="pre">Enum</span></code>. La clase <code class="docutils literal notranslate"><span class="pre">Enum</span></code> son para cosas que tinen un
predecesor y sucesor. Tambien podemos hacerlo miembro de la clase de tipos
<code class="docutils literal notranslate"><span class="pre">Bounded</span></code>, que es para cosas que tengan un valor mínimo posible y valor
máximo posible. Ya que nos ponemos, vamos a hacer que este tipo tenga una
instancia para todas las clases de tipos derivables que hemos visto y veremos
que podemos hacer con él.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">,</span> <span class="kt">Enum</span><span class="p">)</span>
</pre></div>
</div>
<p>Como es parte de las clases de tipos <code class="docutils literal notranslate"><span class="pre">Show</span></code> y <code class="docutils literal notranslate"><span class="pre">Read</span></code>, podemos convertir
valores de est tipo a y desde cadenas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Wednesday</span>
<span class="kt">Wednesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Wednesday</span>
<span class="s">&quot;Wednesday&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Saturday&quot;</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Saturday</span>
</pre></div>
</div>
<p>Como es parte de las clases de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code> y <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, podemos comparar o
equiparar días.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Sunday</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Saturday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">&gt;</span> <span class="kt">Friday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Monday</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Wednesday</span>
<span class="kt">LT</span>
</pre></div>
</div>
<p>También forma parte de <code class="docutils literal notranslate"><span class="pre">Bounded</span></code>, así que podemos obtener el día mas bajo
o el día más alto.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Monday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Sunday</span>
</pre></div>
</div>
<p>También es una instancia de la clase <code class="docutils literal notranslate"><span class="pre">Enum</span></code>. Podemos obtener el predecesor
y el sucesor de un día e incluso podemos crear listas de rangos con ellos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="kt">Monday</span>
<span class="kt">Tuesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="kt">Saturday</span>
<span class="kt">Friday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Thursday</span> <span class="o">..</span> <span class="kt">Sunday</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">minBound</span> <span class="o">..</span> <span class="n">maxBound</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Day</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Monday</span><span class="p">,</span><span class="kt">Tuesday</span><span class="p">,</span><span class="kt">Wednesday</span><span class="p">,</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
</pre></div>
</div>
<p>Bastante impresionante.</p>
</div>
<div class="section" id="sinonimos-de-tipo">
<span id="sinonimos"></span><h2>Sinónimos de tipo<a class="headerlink" href="#sinonimos-de-tipo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Anteriormente mencionamos que los tipos <code class="docutils literal notranslate"><span class="pre">[Char]</span></code> y <code class="docutils literal notranslate"><span class="pre">String</span></code> eran
equivalentes e intercambiables. Esto está implementado con los <strong>sinónimos de
tipo</strong>. Los sinónimos de tipo no hacen nada por si solo, simplemente dan a
algún tipo un nombre diferente, de forma que obtenga algún significado para
alguien que está leyendo nuestro código o documentación. Aquí tienes como
define la librería estándar <code class="docutils literal notranslate"><span class="pre">String</span></code> como sinónimo de <code class="docutils literal notranslate"><span class="pre">[Char]</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">String</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<img alt="Gallina" class="align-left" src="../_images/chicken.png" />
<p>Acabamos de intrudir la palabra clave <code class="docutils literal notranslate"><span class="pre">type</span></code>. Esta palabra clave podría
inducir a errores a algunos, ya que en realidad no estamos haciendo haciendo
nada nuevo (lo hacemos con la palabra clave <code class="docutils literal notranslate"><span class="pre">data</span></code>). Simplemente estamos
dando un sinónimos a un tipo que ya existe.</p>
<p>Si hacemos una función que convierta una cadena a mayúscuals y la llamamos
<code class="docutils literal notranslate"><span class="pre">toUpperString</span></code> o algo parecido, podemos darle una declaración de tipo como
<code class="docutils literal notranslate"><span class="pre">toUpperString</span> <span class="pre">::</span> <span class="pre">[Char]</span> <span class="pre">-&gt;</span> <span class="pre">[Char]</span></code> o <code class="docutils literal notranslate"><span class="pre">toUpperString</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span></code>.
Ambas son esecialmente lo mismo, solo que la última es más legible.</p>
<p>Cuando estabamos hablando del módulo <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>, primero presentamos una
agenda de teléfonos representada con una lista de asociación para luego
convertirla en un diccionario. Como ya sabemos, una lista de asociación no
es más que una lista de duplas clave-valor. Vamos a volver a ver la lista que
teníamos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
<span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Vemos que el tipo de <code class="docutils literal notranslate"><span class="pre">phoneBook</span></code> es <code class="docutils literal notranslate"><span class="pre">[(String,String)]</span></code>. Esto nos dice que
es una lista de asociación que asocia cadenas con cadena, pero nada más. Vamos
a crear un sinónimo de tipo para transmitir algo más de información en la
declaración de tipo.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
</pre></div>
</div>
<p>Ahora la declaración de tipo de nuestra función <code class="docutils literal notranslate"><span class="pre">phoneBook</span></code> sería
<code class="docutils literal notranslate"><span class="pre">phoneBook</span> <span class="pre">::</span> <span class="pre">PhoneBook</span></code>. Vamos a hacer un sinónimo de tipo para las cadenas
también.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">PhoneNumber</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Name</span><span class="p">,</span><span class="kt">PhoneNumber</span><span class="p">)]</span>
</pre></div>
</div>
<p>Dar un sinónimo al tipo <code class="docutils literal notranslate"><span class="pre">String</span></code> es algo que suelen hacer los programadores
de Haskell cuando quieren transmitir algo más de información acerca del
cometido de las cadenas en sus funciones y que representan.</p>
<p>Así que ahora, cuando implementemos una función que tome el nombre y el número
de teléfono y busque si esa combinación está en nuestra agenda telefónica,
podremos darle una declaración de tipo muy descriptiva:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">inPhoneBook</span> <span class="ow">::</span> <span class="kt">Name</span> <span class="ow">-&gt;</span> <span class="kt">PhoneNumber</span> <span class="ow">-&gt;</span> <span class="kt">PhoneBook</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">inPhoneBook</span> <span class="n">name</span> <span class="n">pnumber</span> <span class="n">pbook</span> <span class="ow">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pnumber</span><span class="p">)</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">pbook</span>
</pre></div>
</div>
<p>Si decidimo no utilizar sinónimos de tipo, nuestra función tendría la
declaración de tipo <code class="docutils literal notranslate"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">[(String,String)]</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>. En
este caso, la declaración de tipo que utiliza los sinónimos de tipo es mucho
más clara y fácil de entender. Sin embargo, no debes abusar de ellos.
Utilizamos los sinónimos de tipo o bien para indicar que representa un tipo
que ya existe en nuestras funciones (y de esta forma nuestras delcaraciones
de tipo se convierten en la mejor documentación) o bien cuando algo tiene
un tipo muy largo que se repite mucho (como <code class="docutils literal notranslate"><span class="pre">[(String,String)]</span></code>) y tiene
un significado concreto para nosotros.</p>
<p>Los sinónimos de tipo también pueden ser parametrizados. Si queremos un tipo
que represente las listas de asociación pero también queremos que sea lo
suficientemente general como para utilizar cualquier tipo de clave y valor,
podemos utilizar esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">AssocList</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span>
</pre></div>
</div>
<p>Con esto, una función que tomara un valor por clave en una lista de
asociación puede tener el tipo <code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">AssocList</span> <span class="pre">k</span> <span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">v</span></code>.
<code class="docutils literal notranslate"><span class="pre">AssocList</span></code> es un constructor de tipos que toma dos tipos y produce un tipo
concreto, como <code class="docutils literal notranslate"><span class="pre">AssocList</span> <span class="pre">Int</span> <span class="pre">String</span></code> por ejemplo.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Cuando hablamos de tipos concretos nos referimos a tipos
completamente aplicados, como <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">Int</span> <span class="pre">String</span></code>. A veces, los
chicos y yo decimos que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> es un tipo, pero no queremos
referirnos a eso, ya que cualquier idiota sabe que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> es un
constructor de tipos. Cuando aplico un tipo extra a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, como
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">String</span></code>, entonces tengo un tipo concreto. Ya sabes, los
valores solo pueden tener tipos que sean tipos concretos.
Concluyendo, vive rápido, quiere mucho y no dejes que nadie te
tome el pelo.</p>
</div>
<p>De la misma forma que podemos aplicar parcialmente funciones para obtener
nuevas funciones, podemos aplicar parcialmente los parámetros de tipo y
obtener nuevos constructores de tipo. De la misma forma que llamamos a la
funciones con parámetros de menos para obtener nuevas funciones, podemos
especificar un constructor de tipos con parámetros de menos y obtener un
constructor de tipos parcialmente aplicado. Si queremos un tipo que represente
un diccionario (de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>) que asocie enteros con cualquier otra cosa,
podemos utilizar esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntMap</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span> <span class="n">v</span>
</pre></div>
</div>
<p>O bien esto otro:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntMap</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>De cualquier forma, el constructor de tipos <code class="docutils literal notranslate"><span class="pre">IntMap</span></code> tomará un parámetro
y ese será el tipo con el que se asociarán los enteros.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si vas a intentar implementar esto, seguramente imporatarás de forma
cualificada el módulo <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code>. Cuando realizas una importación
cualificada, los constructores de tipo también deben estar
precedidos con el nombre del módulo. Así que tienes que escribir
algo como <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">IntMap</span> <span class="pre">=</span> <span class="pre">Map.Map</span> <span class="pre">Int</span></code>.</p>
</div>
<p>Asegurate de que realmente entiendes la diferencia entre constructores de
tipos y constructores de datos. Solo porque hayamos creado un sinónimo llamado
<code class="docutils literal notranslate"><span class="pre">IntMap</span></code> o <code class="docutils literal notranslate"><span class="pre">AssocList</span></code> no significa que podamos hacer cosas como
<code class="docutils literal notranslate"><span class="pre">AssocList</span> <span class="pre">[(1,2),(4,5),(7,9)]</span></code>. Lo único que significa es que podemos
referirnos a ese tipo usando nombres diferentes. Podemos hacer
<code class="docutils literal notranslate"><span class="pre">[(1,2),(3,5),(8,9)]</span> <span class="pre">::</span> <span class="pre">AssocList</span> <span class="pre">Int</span> <span class="pre">Int</span></code>, lo cual hará que los número de
adentro asuman el tipo <code class="docutils literal notranslate"><span class="pre">Int</span></code>, pero podemos seguir usando esta lista como
si fuera una lista que albergara duplas de enteros. Lo sinónimos de tipo
(y los tipos en general) solo pueden ser utlizados en la porción de Haskell
dedicada a los tipos. Estaremos en esta porción de Haskell cuando estemos
definiendo tipos nuevos (tanto en las declaraciones <code class="docutils literal notranslate"><span class="pre">data</span></code> como en las de
<code class="docutils literal notranslate"><span class="pre">type</span></code>) o cuando nos situemos después de un <code class="docutils literal notranslate"><span class="pre">::</span></code>. <code class="docutils literal notranslate"><span class="pre">::</span></code> se utiliza
solo para las declaraciones o anotaciones de tipo.</p>
<p>Otro tipo de dato interesante que toma dos tipos como parámetro es el tipo
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>. Así es como se define más o menos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Tiene dos constructores de datos. Si se utiliza <code class="docutils literal notranslate"><span class="pre">Left</span></code>, entonces contiene
datos del tipo <code class="docutils literal notranslate"><span class="pre">a</span></code> y si se utiliza <code class="docutils literal notranslate"><span class="pre">Right</span></code> contiene datos del tipo <code class="docutils literal notranslate"><span class="pre">b</span></code>.
Podemos utilizar este tipo para encapsular un valor de un tipo u otro y así
obtener un valor del tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>. Normalmente utilizaremos un
ajuste de patrones con ambos, <code class="docutils literal notranslate"><span class="pre">Left</span></code> y <code class="docutils literal notranslate"><span class="pre">Right</span></code>, y nos diferenciaremos
según sea uno u otro.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Right</span> <span class="mi">20</span>
<span class="kt">Right</span> <span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Right</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">Right</span> <span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Left</span> <span class="kt">True</span>
<span class="kt">Left</span> <span class="kt">True</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">Bool</span> <span class="n">b</span>
</pre></div>
</div>
<p>Hasta ahora hemos visto que <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> es utilizado para representar
resultados de cálculos que podrían haber fallado o no. Pero a veces,
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> no es suficientemente bueno ya que <code class="docutils literal notranslate"><span class="pre">Nothing</span></code> únicamente nos
informa de que algo ha fallado. Esto esta bien para funciones que solo pueden
fallar de una forma o si no nos interesa saber porque y como han fallado.
Una búqueda en un <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> solo falla cuando la clave que estamos buscando
no se encuentra en el diccionario, así que sabemos exacmente que ha pasado.
Sin embargo, cuando estamos interesados en el cómo o el porqué a fallado algo,
solemos utilizar como resultado el tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>, donde <code class="docutils literal notranslate"><span class="pre">a</span></code> es alguna
especie de tipo que pueda decirnos algo sobre un posible fallo, y <code class="docutils literal notranslate"><span class="pre">b</span></code> es
el tipo de un cálculo satisfactorio. Por lo tanto, los errores usan el
constructor de datos <code class="docutils literal notranslate"><span class="pre">Left</span></code> mientras que los resultado usan <code class="docutils literal notranslate"><span class="pre">Right</span></code>.</p>
<p>Un ejemplo: un instituto posee taquillas para que sus estudiantes tengan un
lugar donde guardar sus posters de <em>Guns’n’Roses</em>. Cada taquilla tiene una
combinación. Cuando un estudiante quiere una taquilla nueva, le dice al
supervisor de las taquillas que número de taquilla quiere y él le da un
código para esa taquilla. Sin embargo, si alguien ya está usando la taquilla,
no le puede decir el código y tienen que elegir una taquilla diferente.
Utilizaremos un diccionario de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> para representar las taquillas.
Asociará el número de la taquilla con duplas que contengan si la taquilla está
en uso o no y el código de la taquilla.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>

<span class="kr">data</span> <span class="kt">LockerState</span> <span class="ow">=</span> <span class="kt">Taken</span> <span class="o">|</span> <span class="kt">Free</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Code</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">type</span> <span class="kt">LockerMap</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">LockerState</span><span class="p">,</span> <span class="kt">Code</span><span class="p">)</span>
</pre></div>
</div>
<p>Bastante simple. Hemo creado un nuevo tipo de dato para representar si una
taquilla está libre o no, y hemos creado un sinónimo para representar el
código de una taquilla. También creado otro sinónimo para el tipo que asocia
los los números de las taquillas con las duplas de estado y código. Ahora,
vamos a hacer una función que busque un número de taquilla en el diccionario.
Vamos a usar el tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span> <span class="pre">Code</span></code> para representar el resultado,
ya que nuestra búsqueda puede fallar de dos formas: la taquilla ya ha sido
tomada, en cuyo caso decimos quien la posee o si el no hay ninguna taquilla
con ese número. Si la búqueda falla, vamos a utilizar una cadena para obtener
el porqué.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lockerLookup</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LockerMap</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Code</span>
<span class="nf">lockerLookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker number &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; doesn&#39;t exist!&quot;</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">state</span> <span class="o">/=</span> <span class="kt">Taken</span>
                                <span class="kr">then</span> <span class="kt">Right</span> <span class="n">code</span>
                                <span class="kr">else</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; is already taken!&quot;</span>
</pre></div>
</div>
<p>Hacemos una búsqueda normal en un diccionario. Si obtenemos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>,
devolvemos un valor con el tipo <code class="docutils literal notranslate"><span class="pre">Left</span> <span class="pre">String</span></code> que diga que esa taquilla no
existe. Si la encontramos, hacemos una comprobación adicional para ver si la
taquilla está libre. Si no lo está, devolvemos un <code class="docutils literal notranslate"><span class="pre">Left</span></code> diciendo que la
taquilla a sido tomada. Si lo está, devolvemos un valor del tipo <code class="docutils literal notranslate"><span class="pre">Right</span>
<span class="pre">Code</span></code>, el cual daremos al estudiante. En realidad es un <code class="docutils literal notranslate"><span class="pre">Right</span> <span class="pre">String</span></code>,
aunque hemos creado un sinónimo para añadir un poco más de información en
la declaración de tipo. Aquí tienes un diccionario de ejemplo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">lockers</span> <span class="ow">::</span> <span class="kt">LockerMap</span>
<span class="nf">lockers</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
    <span class="p">[(</span><span class="mi">100</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;ZD39I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">101</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;JAH3I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">103</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;IQSA9&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">105</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;QOTSA&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">109</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;893JJ&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">110</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;99292&quot;</span><span class="p">))</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Vamos a buscar el código de unas cuantas taquillas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">101</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;JAH3I&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">100</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 100 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">102</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker number 102 doesn&#39;t exist!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">110</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 110 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">105</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;QOTSA&quot;</span>
</pre></div>
</div>
<p>Podríamos haber utlizado el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code> para representar el resultado
pero entonces no sabríamos el motivo por el cual no podemos obtener el código.
Ahora, tenemos información acerca del fallo en nuestro tipo del resultado.</p>
</div>
<div class="section" id="estructuras-de-datos-recursivas">
<span id="estrucrec"></span><h2>Estructuras de datos recursivas<a class="headerlink" href="#estructuras-de-datos-recursivas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Hombre cool" class="align-left" src="../_images/thefonz.png" />
<p>Como ya hemos visto, un costructor de un tipo de dato algebraico puede tener
(o no tener) varios campos y cada uno de estos debe ser un tipo concreto.
Teniendo esto en cuenta, podemos crear tipos cuyos campos de constructor sean
el propio tipo. De esta forma, podemos crear estructuras de datos recursivas,
en el que un valor de un cierto tipo contenga valores de ese mismo tipo, el
cual seguirá conteniendo valores del mismo tipo y así sucesivamente.</p>
<p>Piensa en la lista <code class="docutils literal notranslate"><span class="pre">[5]</span></code>. Es lo mismo que <code class="docutils literal notranslate"><span class="pre">5:[]</span></code>. A la izquierda del <code class="docutils literal notranslate"><span class="pre">:</span></code>
hay un valore, y a la derecha hay una lista. En este caso, una lista vacía.
¿Qué pasaría con la lista <code class="docutils literal notranslate"><span class="pre">[4,5]</span></code>? Bueno, es lo mismo que <code class="docutils literal notranslate"><span class="pre">4:(5:[])</span></code>. Si
miramos el primer <code class="docutils literal notranslate"><span class="pre">:</span></code>, vemos que también tiene un elemento a su izquierda y
una lista a su derecha <code class="docutils literal notranslate"><span class="pre">(5:[])</span></code>.  Lo mismo sucede para la lista
<code class="docutils literal notranslate"><span class="pre">3:(4:(5:6:[]))</span></code>, que también podría escribirse como <code class="docutils literal notranslate"><span class="pre">3:4:5:6:[]</span></code> (ya que
<code class="docutils literal notranslate"><span class="pre">:</span></code> es asociativo por la derecha) o <code class="docutils literal notranslate"><span class="pre">[3,4,5,6]</span></code>.</p>
<p>Podemos decir que una lista es o bien una lista vacia o bien un elemento
unido con un <code class="docutils literal notranslate"><span class="pre">:</span></code> a otra lista (que puede ser una lista vacía o no).</p>
<p>¡Vamos a usar los tipod de datos algebraicos para implementar nuestra propia
lista!</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Se lee de la misma forma que se leía nuestra definición de lista en un
párrafo anterior. Es o bien una lista vacía o bien una combinación de un
elemento y otra lista. Si estás confundido con esto, quizás te sea más fácil
entenderlo con la sintaxis de registro:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="p">{</span> <span class="n">listHead</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span> <span class="n">listTail</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Puede que también estes confundido con el constructor <code class="docutils literal notranslate"><span class="pre">Cons</span></code>. <code class="docutils literal notranslate"><span class="pre">Cons</span></code> es
otra forma de decir <code class="docutils literal notranslate"><span class="pre">:</span></code>. En realidad, en las listas, <code class="docutils literal notranslate"><span class="pre">:</span></code> es un constructor
que toma un valor y otra lista y devuleve una lista. En otras palabras, tiene
dos campos. Uno es del tipo <code class="docutils literal notranslate"><span class="pre">a</span></code> y otro es del tipo <code class="docutils literal notranslate"><span class="pre">[a]</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Empty</span>
<span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span>
<span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="kt">Cons</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
</pre></div>
</div>
<p>Si hubiésemos llamado a nuestro constructor de forma infija podrías ver mejor
como es simplemente <code class="docutils literal notranslate"><span class="pre">:</span></code>. <code class="docutils literal notranslate"><span class="pre">Empty</span></code> es como <code class="docutils literal notranslate"><span class="pre">[]</span></code> y <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">`Cons`</span> <span class="pre">(5</span> <span class="pre">`Cons`</span>
<span class="pre">Empty)</span></code> es como <code class="docutils literal notranslate"><span class="pre">4:(5:[])</span></code>.</p>
<p>Podemos definir funciones que automáticamente sean infijas si las nombramos
únicamente con caracteres especiales. Podemos hacer lo mismo con los
constructores, ya que son simplemente funciones que devuelve un tipo de dato
concreto. Mira esto:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span> <span class="kt">:-:</span>
<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="n">a</span> <span class="kt">:-:</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Antes de nada, vemos que hay una nueva construcción sintáctica, una
declaración infija. Cuando definimos funciones como operadores, podemos usar
esta cosntrucción para darles un determinado comportamiento (aunque no estamos
obligados a hacerlo). De esta forma definimos el orden de precedencia de un
operador y si asociativo por la izquierda o por la derecha. Por ejemplo, <code class="docutils literal notranslate"><span class="pre">*</span></code>
es <code class="docutils literal notranslate"><span class="pre">infixl</span> <span class="pre">7</span> <span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">+</span></code> es <code class="docutils literal notranslate"><span class="pre">infixl</span> <span class="pre">6</span> <span class="pre">+</span></code>. Esto siginifica que ambos son
asociativos por la izquierda de forma que <code class="docutils literal notranslate"><span class="pre">(4</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">2)</span></code> es <code class="docutils literal notranslate"><span class="pre">(4</span> <span class="pre">*</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">2)</span></code>
pero <code class="docutils literal notranslate"><span class="pre">*</span></code> tiene un orden de precedencia mayor que <code class="docutils literal notranslate"><span class="pre">+</span></code>, por lo que
<code class="docutils literal notranslate"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">3</span></code> es equivalente a <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">3</span></code>.</p>
<p>De qualquier modo, al final acabamos escribiendo <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">:-:</span> <span class="pre">(List</span> <span class="pre">a)</span></code> en lugar
de `` Cons a (List a)``. Ahora podemos escribir las listas así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="kt">:-:</span> <span class="n">a</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">100</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)))</span>
</pre></div>
</div>
<p>Haskell serguirá mostrando el cosntructor como una función prefija cuando
derivemos <code class="docutils literal notranslate"><span class="pre">Show</span></code>, por este motivo aparecen los poréntesis alrededor del
constructor (recuerda que <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">3</span></code> es igual que <code class="docutils literal notranslate"><span class="pre">(+)</span> <span class="pre">4</span> <span class="pre">3</span></code>).</p>
<p>Vamos a crear una función que una dos de nuestras listas. Así es como está
definida la función <code class="docutils literal notranslate"><span class="pre">++</span></code> para listas normales:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">++</span>
<span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">[]</span>     <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que copiamos esta definición y la aplicamos a nuestras listas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">.++</span>
<span class="p">(</span><span class="o">.++</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>
<span class="kt">Empty</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span> <span class="kt">:-:</span> <span class="n">xs</span><span class="p">)</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:-:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">.++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Y así es como funciona:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">6</span> <span class="kt">:-:</span> <span class="mi">7</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">.++</span> <span class="n">b</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">6</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">7</span> <span class="kt">Empty</span><span class="p">))))</span>
</pre></div>
</div>
<p>Bien. Si te apetece puedes implementar todas las funciones que operan con
listas con nuestro tipo de listas.</p>
<p>Fíjate que hemos utilizado un ajuste de patrón <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:-:</span> <span class="pre">xs)</span></code>. Esto función
ya que el ajuste de patrones en realidad funciona ajustando constructores.
Podemos ajustar un patrón <code class="docutils literal notranslate"><span class="pre">:-:</span></code> porque es un constructor de nuesto tipo de
la misma forma que <code class="docutils literal notranslate"><span class="pre">:</span></code> es un constructor de las listas estándar. Lo mismo
sucede para <code class="docutils literal notranslate"><span class="pre">[]</span></code>. Ya que el ajuste de patrones funciona (solo) con
constructores de datos, podemos ajustar patrones como los constructores
prefijos normales, constructores infijos o cosas como <code class="docutils literal notranslate"><span class="pre">8</span></code> o <code class="docutils literal notranslate"><span class="pre">'a'</span></code>, que
al fin y al cabo son constructores de tipos númericos y caracteres.</p>
<img alt="Árbol binario" class="align-left" src="../_images/binarytree.png" />
<p>Vamos a implementar un árbol binario de búsqueda. Si no estás familiarizado
con los árboles binarios de búsqueda de otros lenguajes como <em>C</em>, aquí tienes
una expliación de lo que son: un elemento apunta a otros dos elementeos, uno
esta a la izquierda y otro a la derecha. El elemento a la izquierda es más
pequeño y el segundo es más grande. Cada uno de estos dos elementos puede
apuntar a otros dos elementos (o a uno o a ninguno). En efecto, cada elemento
tienen sus propios sub-árboles. Lo bueno de los árboles binarios de búsqueda
es que sabemos que todos los elementos que están en el sub-árbol de la
iquierda de, 5, por ejemplo, son menores que 5. Lo elementos que están en el
sub-árbol de la derecha son mayores. Así que si estamos buscando el elemento
8 en nuestro árbol, emepezamos comparándolo con 5, como vemos que es menor que
5, nos vamos al sub-árbol de la derecha. Ahora estaríamos en 7, como es menor
que 8 continuaríamos hacia la derecha. De esta formá encontraríamos el
elemento en tres pasos. Si estuvieramos usando una lista (o un árbol no
balanceado), nos hubiera costado unos 7 pasos encontrar el 8.</p>
<p>Los conjuntos y diccionario de <code class="docutils literal notranslate"><span class="pre">Data.Set</span></code> y <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> están
implementandos utilizando árboles, solo que en lugar de árboles binarios
de búsqueda, utilizan árboles binarios de búsqueda balanceados, de forma que
estén siempre balanceados. Ahora implementaremos simplemente árboles binarios
de búsqueda normales.</p>
<p>Vamos a decir que: un árbol es o bien un árbol vacío o bien un elemento
que contiene un elemento y otros dos árboles. Tiene pinta de que va a encajar
perfectamente con los tipos de datos algebraicos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">EmptyTree</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Vale. En lugar de construir manualmente un árbol, vamos a crear una función
que tome un elemento y un árbol e inserte dicho elemento en su posición
adecuada dentro del árbol. Hacemos esto comparando el elemento que queremos
insertar con la raíz del árbol y si es menor, vamos a la izquierda y si no
a la derecha. Hacemos lo mismo para coda nodo siguiente hasta que alcanzemos
un árbol vacío. Cuando lo hagamos simplemente insertamos el elmento en
lugar del árbol vacío.</p>
<p>En lenguajes como <em>C</em>, realizamos esta tarea modificando los punteros y
valores del árbol. En Haskell, no podemos modificar nuestro árboles, así que
tenemos que crear un nuevo sub-árbol cada vez que decidamos si vamos a la
derecha o a la izquierda y al final la función de inserción devolver un
árbol complentamente nuevo, ya que Haskell no tiene el concepto de puntero.
Así pues la declaración de tipo de nuestra función será alfgo como <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Tree</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">&gt;</span> <span class="pre">Tree</span> <span class="pre">a</span></code>. Toma un elemento y un árbol y devuelve un nuevo árbol que
posee en su interior dicho elemento. Puede parecer ineficienciente pero la
evaluación perezosa de Hasekell ya se encarga de ello.</p>
<p>Aqui tienes dos funciones. Una de ellas es una función auxiliar para crear un
árbol unitario (que solo contiene un elemento) y la otra es una función que
inserta elementos en un árbol.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span>

<span class="nf">treeInsert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="n">singleton</span> <span class="n">x</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">left</span><span class="p">)</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>La función <code class="docutils literal notranslate"><span class="pre">singleton</span></code> es forma rápida de crear un árbol que contenga un
elemento y dos sub-árboles vacios. En la función de inserción, tenemos como
primer patrón el caso base. Si hemos alcanzado un sub-árbol vacio, esto
significa que estamos donde queríamos y en lugar de un árbol vacío, queremos
un árbol unitario que contenga el elemento a insertar. Si no estamos
insertando el elemento en un árbol vacío tenemos que comprobar varias cosas.
Primero, si el elemento que vamos a insertar es el mismo que la raíz del
sub-árbol, simplemente devolvemos el árbol como estaba. Si es menor,
devolvemos un árbol que tenga la misma raíz, el mimso sub-árbol derecho pero
en lugar de su sub-árbol izquierdo, ponemos el árbol que va a contener dicho
elemento. Lo mismo ocurre (pero en sentido contrario) para los valores que
son mayores que el elemento raíz.</p>
<p>A continuación vamos a crear una función que compruebe si un elemento pertence
a un árbol. Primero vamos a definir el caso base. Si estamos buscando un
elemento en un árbol vacío, obviamente el elemento no está ahí. Vale, fíjate
que esto es básicamente lo mismo que el caso base de la búsqueda en listas: si
estamos buscando un elemento en una lista vacía, obviamente el elemento no
está ahí. De todos modos, si no estamos buscando el elemento en un árbol
vacío, entonces tenemos que hacer varias comprobaciones. Si el elemento que
estamos buscando es el elemento raíz ¡Genial! ¿Y si no lo es? Bueno, tenemos
la ventaja de que sabemos que todos los elementos menores que la raíz están
en el sub-árbol izquierdo. Así que si el elemento que estamos buscando es
menor que la raiz, comprobamos si el elemento está en el sub-árbol izquierdo.
Si es mayor, comprobamos el sub-árbol derecho.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">treeElem</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">left</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">right</span>
</pre></div>
</div>
<p>¡Vamos a divertirnos con nuestro árboles! En lugar de contruir manualmente un
árbol (aunque podríamos), usaremos un pliegue para construir un árbol a partir
de una lista. Recuerda, casi cualquier cosa que recorra una lista elemento a
elemento y devuelve alguna especie de valor puede ser implementado con un
pliegue. Empezaremos con un árbol vacío y luego recorreremos la lista desde
la derecha e iremos insertando elementos a nuestro árbol acumulador.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nums</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">numsTree</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="n">nums</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">numsTree</span>
<span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">7</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span>
</pre></div>
</div>
<p>En este <code class="docutils literal notranslate"><span class="pre">foldr</span></code>, <code class="docutils literal notranslate"><span class="pre">treeInsert</span></code> es la función de pliegue (toma un árbol y
un elemento de la lista y produce un nuevo árbol) y <code class="docutils literal notranslate"><span class="pre">EmptyTree</span></code> es el
valor inicial. Por supuesto, <code class="docutils literal notranslate"><span class="pre">nums</span></code> es la lista que estamos plegando.</p>
<p>No es muy legible el árbol que se muestra por la consola, pero si lo
intentamos, podemos descifrar su estructura. Vemos que el nodo raíz es 5 y
luego tiene dos sub-árboles, uno que tiene como elemento raíz a 3, y otro a 7.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">8</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>Vamos que comprobar la pertencia de un elemento a un árbol funciona
perfectamente. Genial.</p>
<p>Como puede ver los tipos de datos algebraicos en Hasekll son un concepto muy
intersante a la vez que pontentes. Podemos utilizarlos desde para representar
valores booleanos hasta enumeraciónes de los días de la semana, e incluso
árboles binarios de búsquedas.</p>
</div>
<div class="section" id="clases-de-tipos-paso-a-paso-2a-parte">
<h2>Clases de tipos paso a paso (2ª parte)<a class="headerlink" href="#clases-de-tipos-paso-a-paso-2a-parte" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Semáforo" class="align-right" src="../_images/trafficlight.png" />
<p>Hasta ahora hemos aprendido a utilizar algunas clases de tipos estándar de
Haskell y hemos visto que tipos son miembros de ellas. También hemos aprendido
a crear automáticamente instancias de nuestros tipos para las clases de tipos
estándar, pidiéndole a Haskell que las derive por nostros. En esta sección
vamos a ver como podemos crear nuestras propias clases de tipo y a como crear
instancias de tipos para ellas a mano.</p>
<p>Un pequeño recordatorio acerca de las clases de tipos: las clases de tipos
son como las interfaces. Una clase de tipos define un comportamiento (como
comparar por igualdad, comparar por orden, una enumeración, etc.) y luego
ciertos tipos pueden comportarse de forma a la instancia de esa clase de
tipos. El comportamiento de una clase de tipos se consigue definiendo
funciones o simplemente definiendo tipos que luego implementaremos. Así que
cuando digamos que un tipo es una instancia de un clase de tipos, estamos
diciendo que podemos usar las funciones de esa clase de tipos con ese tipo.</p>
<p>Las clases de tipos no tienen nada que ver con las clases de <em>Java</em> o
<em>Pyhton</em>. Esto suele confundir a mucha gente, así que me gustaría que
olvidaras ahora mismo todo lo que sabes sobre las clases en los lenguajes
imperativos.</p>
<p>Por ejemplo, la clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code> es para cosas que pueden ser
equiparadas. Define las funciones <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">/=</span></code>. Si tenemos un tipo
(digamos, <code class="docutils literal notranslate"><span class="pre">Car</span></code>) y el comparar dos coches con la función <code class="docutils literal notranslate"><span class="pre">==</span></code> tiene
sentido, entonces tiene sentido que <code class="docutils literal notranslate"><span class="pre">Car</span></code> sea una instancia de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
<p>Así es como está defina la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code> en <code class="docutils literal notranslate"><span class="pre">Prelude</span></code>:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>¡Alto, alto, atlo! ¡Hay mucha sintaxis y palabras raras ahí! No te preocupes,
estará todo claro en un segundo. Lo primero de todo, cuando escribimos
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></code> significa que estamos definiendo una clase de tipos nueva
y que se va a llamar <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. La <code class="docutils literal notranslate"><span class="pre">a</span></code> es la variable de tipo y significa que
<code class="docutils literal notranslate"><span class="pre">a</span></code> representará el tipo que dentro de poco hagamos instancia de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.
No tiene porque llamarse <code class="docutils literal notranslate"><span class="pre">a</span></code>, de hecho no tiene ni que ser de una sola
letra, solo debe ser una palabra en minúsculas. Luego definimos varias
funciones. No es obligatorio implementar los cuerpos de las funciones, solo
debemos especificar las declaraciones de tipo de las funciones.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Hay gente que entederá esto mejor si escribimos algo como
<code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">equiparable</span> <span class="pre">where</span></code> y luego definimos el tipo de las
funciones como <code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">equiparable</span> <span class="pre">-&gt;</span> <span class="pre">equiparable</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>.</p>
</div>
<p>De todos modos, hemos implementado el cuerpo de las funciones que define
<code class="docutils literal notranslate"><span class="pre">Eq</span></code>, solo que las hemos implementado en terminos de recursión mutua.
Decimos que dos instancias de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code> son iguales si no son desiguales
y son desiguales y no son iguales. En realidad no teníamos porque haberlo
echo, pero pronto veremos de que forma nos ayuda.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Si tenemos un <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></code> y definimos una declaración
de tipo dentro de la clase como <code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">-a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>, luego,
cuando examinemos el tipo de esa función obtendremos
<code class="docutils literal notranslate"><span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>.</p>
</div>
<p>Así que ya tenemos una clase ¿Qué podemos hacer con ella? Bueno, no mucho.
Pero una vez empezemos a declarar instancias para esa clase, empezaremos a
obtener algun funcionalidad útil. Mira este tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span>
</pre></div>
</div>
<p>Define los estados de un semáforo. Fijate que no hemos derivado ninguna
instancia, ya que vamos a escribirlas a mano, aunque podríamos haberlas
derivado para las clases <code class="docutils literal notranslate"><span class="pre">Eq</span></code> y <code class="docutils literal notranslate"><span class="pre">Show</span></code>. Aquí tienes como creamos la
instancia para la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Green</span> <span class="o">==</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Yellow</span> <span class="o">==</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Lo hicimos utilizando la palabra clave <code class="docutils literal notranslate"><span class="pre">instance</span></code>. Así que <code class="docutils literal notranslate"><span class="pre">class</span></code> es
para definir nuevas clases de tipos y <code class="docutils literal notranslate"><span class="pre">instance</span></code> para hacer que nuestros
tipos tengan una instancia para cierta clase de tipos. Cuando estabamos
definiendo <code class="docutils literal notranslate"><span class="pre">Eq</span></code> escribimos <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></code> y dijimos que <code class="docutils literal notranslate"><span class="pre">a</span></code>
representaría el tipo que hiciéramos instancia después. Lo podemos ver
claramente ahora, ya que cuando estamos escribiendo una instancia, escribrimos
<code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">TrafficLight</span> <span class="pre">where</span></code>. Hemo remplazado la <code class="docutils literal notranslate"><span class="pre">a</span></code> por el tipo
actual.</p>
<p>Como <code class="docutils literal notranslate"><span class="pre">==</span></code> fue definido en la definición de clase en términos de <code class="docutils literal notranslate"><span class="pre">/=</span></code> y
viceversa, solo tenemos que sobreescribir una de ellas en la delcaración de
instancia. A esto se le llama la definición completa mínima de una clase de
tipos, o dicho de otra forma, el mínimo número de funciones que tenemos que
implementar para que nuestro tipo pertenezca a una determinada clase de tipos.
Para rellenar la definición completa mínima de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, tenemos que
sobreescribir o bien <code class="docutils literal notranslate"><span class="pre">==</span></code> o <code class="docutils literal notranslate"><span class="pre">/=</span></code>. Si <code class="docutils literal notranslate"><span class="pre">Eq</span></code> hubiese sido definido como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Tendríamos que haber implementado ambas funciones a la hora de crear una
instancia, ya que Hasekell sabría como están relacionadas esas funciones.
De esta forma, la definición completa mínima serían ambas, <code class="docutils literal notranslate"><span class="pre">==</span></code> y <code class="docutils literal notranslate"><span class="pre">/=</span></code>.</p>
<p>Como has visto hemos implementado <code class="docutils literal notranslate"><span class="pre">==</span></code> usando ajuste de patrones. Como hay
muchos más casos donde dos semáforos no están en el mismo estado,
especificamos para cuales son iguales y luego utilizamos un patrón que se
ajuste a cualquier caso que no sea ninguno de los anteriores para decir que no
son iguales.</p>
<p>Vamos a crear también una instancia para <code class="docutils literal notranslate"><span class="pre">Show</span></code>. Para satisfacer la
definición completa mínima de <code class="docutils literal notranslate"><span class="pre">Show</span></code>, solo tenemos que implementar la
función <code class="docutils literal notranslate"><span class="pre">show</span></code>, la cual toma un valor y lo convierte a una cadena.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="s">&quot;Red light&quot;</span>
    <span class="n">show</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="s">&quot;Yellow light&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green light&quot;</span>
</pre></div>
</div>
<p>Una vez más hemos utilizado el ajuste de patrones para conseguir nuestros
objetivos. Vamos a verlo en acción:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Yellow</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span> <span class="n">light</span><span class="p">,</span><span class="kt">Yellow</span> <span class="n">light</span><span class="p">,</span><span class="kt">Green</span> <span class="n">light</span><span class="p">]</span>
</pre></div>
</div>
<p>Perfecto. Podríamos haber derivado <code class="docutils literal notranslate"><span class="pre">Eq</span></code> y hubiera tenido el mismo efecto.
Sin embargo, derivar <code class="docutils literal notranslate"><span class="pre">Show</span></code> hubiera representando directamente los
constructores como cadenas. Pero si queremos que las luces aparezcan
como <code class="docutils literal notranslate"><span class="pre">&quot;Red</span> <span class="pre">light&quot;</span></code> tenemos que crear esta instancia a mano.</p>
<p>También podemos crear clases de tipos que sean subclases de otras clases de
tipos. La declaración de la clase <code class="docutils literal notranslate"><span class="pre">Num</span></code> es un poco larga, pero aquí tienes
el principio:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Como ya hemos mencionado anteriormente, hay un montón de sitios donde podemos
poner restriciones de clases. Esto es lo mismo que escribir <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Num</span> <span class="pre">a</span>
<span class="pre">where</span></code>, solo que decimos que nuestro tipo <code class="docutils literal notranslate"><span class="pre">a</span></code> debe ser una instancia de
<code class="docutils literal notranslate"><span class="pre">Eq</span></code>. Basicamente decimos que hay que crear la instancia <code class="docutils literal notranslate"><span class="pre">Eq</span></code> de un tipo
antes de que éste forme parte forme parte de la clase <code class="docutils literal notranslate"><span class="pre">Num</span></code>. Antes de que un
tipo se pueda considerar un número, tiene sentido que podamos determinar si
los valores de un tipo puede sen equiparados o no. Esto es todo lo que hay que
saber de las subclases ya que simplemente son restriscciones de clase dentro
de la definición de una clase. Cuando definamos funciones en la declaración
de una clase o en la definición de una instancia, podemos asumir que <code class="docutils literal notranslate"><span class="pre">a</span></code> es
parte de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code> así que podemos usar <code class="docutils literal notranslate"><span class="pre">==</span></code> con los valores de ese
tipo.</p>
<p>¿Pero cómo son creadas las instancias del tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> o de las listas? Lo
que hace diferente a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> de, digamos, <code class="docutils literal notranslate"><span class="pre">TrafficLight</span></code> es que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
no es por si mismo un tipo concreto, es un constructor de tipos que toma un
parámetro (como <code class="docutils literal notranslate"><span class="pre">Char</span></code> o cualquier otra cosa) para producir un tipo
concreto. Vamos a echar un vistazo a la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code> de nuevo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>A partir de la declaración de tipo, podemos observar que <code class="docutils literal notranslate"><span class="pre">a</span></code> es utilizado
como un tipo concreto ya que todos los tipos que aparecer en una función deben
deben ser concretos (Recuerda, no puedes tener una función con el tipo
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span></code> pero si una función <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">a</span></code> o <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span>
<span class="pre">String</span></code>). Por este motivo no podemos hacer cosas como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Ya que como hemos visto, <code class="docutils literal notranslate"><span class="pre">a</span></code> debe ser un tipo concreto pero <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> no lo
es. Es un constructor de tipos que toma un parámetro y produce un tipo
concreto. Sería algo pesado tener que escribir <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">Int)`</span>
<span class="pre">where</span></code>, <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">Char)</span> <span class="pre">where</span></code>, etc. para cada tipo. Así que
podemos escribirlo así:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Esto es como decir que queremos hacer una instancia de <code class="docutils literal notranslate"><span class="pre">Eq</span></code> para todos los
tipos <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">algo</span></code>. De hecho, podríamos haber escrito <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">algo</span></code>, pero
preferimos elegir nombres con una sola letra para ser fieles al estilo de
Haskell. Aquí, <code class="docutils literal notranslate"><span class="pre">(Maybe</span> <span class="pre">m)</span></code> hace el papel de <code class="docutils literal notranslate"><span class="pre">a</span></code> en <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></code>.
Mientras que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> no es un tipo concreto, <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">m</span></code> sí. Al utilizar un
parámetro tipo (<code class="docutils literal notranslate"><span class="pre">m</span></code>, que está en minúsculas), decimos que queremos todos los
tipos que sean de la forma <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">m</span></code>, donde <code class="docutils literal notranslate"><span class="pre">m</span></code> es cualquier tipo que
forme parte de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
<p>Sin embargo, hay un problema con esto ¿Puedes averiguarlo? Utilizamos <code class="docutils literal notranslate"><span class="pre">==</span></code>
sobre los contenidos de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> pero nadie nos asegura de que lo que
contiene <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> forme parte de la clase <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. Por este motivo tenemos que
modificar nuestra declaración de instancia:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Hemos añadido una restricción de clase. Con esta instancia estamos diciendo:
Queremos que todos los tipos con la forma <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">m</span></code> sean miembros de la
clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, pero solo aquellos tipos donde <code class="docutils literal notranslate"><span class="pre">m</span></code> (lo que está
contenido dentro de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>) sean miembros también de <code class="docutils literal notranslate"><span class="pre">Eq</span></code>. En realidad
así sería como Haskell derivaría esta instancia.</p>
<p>La mayoría de las veces, las restricciones de clase en las <em>declaraciones de
clases</em> son utilizadas para crear una clases de tipos que sean subclases de
otras clases de tipos mientras que las restricciones de clase en las
<em>declaraciones de instancias</em> son utilizadas para expresar los requisitos de
algún tipo. Por ejemplo, ahora hemos expresado que el contenido de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>
debe formar parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Eq</span></code>.</p>
<p>Cuando creas una instancia, si ves que un tipo es utilizado como un tipo
concreto en la declaración de tipos (como <code class="docutils literal notranslate"><span class="pre">a</span></code> en <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>), debes
añadir los parámetros de tipos correspondientes y rodearlo con paréntesis de
forma que acabes teniendo un tipo concreto.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Ten en cuenta que el tipo para el cual estás trantando de hacer una
instancia remplazará el parámetro de la declaración de clase. La
<code class="docutils literal notranslate"><span class="pre">a</span></code> de <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></code> será remplazada con un tipo real
cuando crees una instancia, así que trata mentalmente de poner el
tipo en la declaración de tipo de las funiones.
<code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code> no tiene mucho sentido, pero
<code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">Boo</span></code> sí. Pero esto es
simplemente una forma de ver las cosas, ya que <code class="docutils literal notranslate"><span class="pre">==</span></code> simpre tendrá
el tipo <code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>, sin importar las
instancias que hagamos.</p>
</div>
<p>Oh, una cosa más. Si quieres ver las instancias que existen de una clase de
tipos, simplemente haz <code class="docutils literal notranslate"><span class="pre">:info</span> <span class="pre">YourTypeClass</span></code> en GHCi. Así que si utilizamos
<code class="docutils literal notranslate"><span class="pre">:info</span> <span class="pre">Num</span></code> nos mostrará que funciones están definidas en la clase de tipos
y nos mostrará también una lista con los tipos que forman parte de esta clase.
<code class="docutils literal notranslate"><span class="pre">:info</span></code> también funciona con tipos y constructores de tipo. Si hacemos
<code class="docutils literal notranslate"><span class="pre">:info</span> <span class="pre">Maybe</span></code> veremos todas las clases de tipos de las que éste forma parte.
<code class="docutils literal notranslate"><span class="pre">:info</span></code> también te muestra el tipo de una función. Bastante útil.</p>
</div>
<div class="section" id="la-clase-de-tipos-yes-no">
<h2>La clase de tipos Yes-No<a class="headerlink" href="#la-clase-de-tipos-yes-no" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Sí y no" class="align-left" src="../_images/yesno.png" />
<p>En JavaScript y otros lenguajes débilmente tipados, puedes poner casi
cualquier cosa dentro de una expresión. Por ejemplo, puedes hacer todo lo
siguiente: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(0)</span> <span class="pre">alert(&quot;YEAH!&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></code>, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(&quot;&quot;)</span> <span class="pre">alert</span>
<span class="pre">(&quot;YEAH!&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></code>, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(false)</span> <span class="pre">alert(&quot;YEAH&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!)</span></code>,
etc. Y todos estos mostrarán un mensaje diciendo <code class="docutils literal notranslate"><span class="pre">NO!</span></code>. Si hacemos
<code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(&quot;WHAT&quot;)</span> <span class="pre">alert</span> <span class="pre">(&quot;YEAH&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></code> mostrará <code class="docutils literal notranslate"><span class="pre">&quot;YEAH!&quot;</span></code> ya que
en JavaScript las cadenas no vacías son consideradas valores verdaderos.</p>
<p>Aunque el uso estricto de <code class="docutils literal notranslate"><span class="pre">Bool</span></code> para la semántica de booleanos funciona
mejor en Haskell, vamos a intentar implementar este comportamiento de
JavaScript ¡Solo para divertirnos! Empecemos con la declaración de clase.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">YesNo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Muy simple. La clase de tipos <code class="docutils literal notranslate"><span class="pre">YesNo</span></code> define una función. Esta función toma
un valor de un tipo cualquiera que puede expresar algún valor de verdad y nos
dice si es verdadero o no. Fíjate en la forma que usamos <code class="docutils literal notranslate"><span class="pre">a</span></code> en la función,
<code class="docutils literal notranslate"><span class="pre">a</span></code> tiene que ser un tipo concreto.</p>
<p>Lo siguiente es definir algunas instancias. Para los números, asumimos que
(como en JavaScript) cualquier número que no sea 0 es verdadero y 0 es falso.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>La listas vacías (y por extensión las cadenas) son valores falsos, mientras
que las listas no vacías tienen un valor verdadero.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Fíjate como hemos puesto un parámetro de tipo dentro para hacer de la lista un
tipo concreto, aunque no suponemos nada acerca de lo que contiene la lista.
Qué más… Mmmm… ¡Ya se! <code class="docutils literal notranslate"><span class="pre">Bool</span></code> también puede contener valores verdaderos
y falos y es bastante obvio cual es cual.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
<p>¿Eh? ¿Qué es <code class="docutils literal notranslate"><span class="pre">id</span></code>? Simplemente es una función de la librería estándar que
toma un parámetro y devuelve lo mismo, lo cual es lo mismo que tendríamos que
escribir aquí.</p>
<p>Vamos a hacer también una instancia para <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">yesno</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>No necesitamos una restricción de clase ya que no suponemos nada acerca de los
contenidos de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. Simplemente decimos que es verdadero si es un valor
<code class="docutils literal notranslate"><span class="pre">Just</span></code> y falso si es <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Seguimos teniendo que escribir
<code class="docutils literal notranslate"><span class="pre">(Maybe</span> <span class="pre">a)</span></code> en lugar de solo <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> ya que, si lo piensas un poco, una
función <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code> no puede existir (ya que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> no es un tipo
concreto), mientras que <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code> es correcto. Aun así, sigue siendo
genial ya que ahora, cualquier tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">algo</span></code> es parte de la clase`
<code class="docutils literal notranslate"><span class="pre">YesNo</span></code> y no importa lo que sea <code class="docutils literal notranslate"><span class="pre">algo</span></code>.</p>
<p>Antes definimos un tipo <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code> para representar la búsqueda binaria.
Podemos decir que un árbol vacío tiene un valor falso mientras cualquier otra
cosa tiene un valor verdadero.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>¿Puede ser el estado de un semáforo un valor verdadero o falso? Claro. Si
está rojo, paras. Si está verde, continuas. ¿Si está ámbar? Ehh… normalmente
suelo acelerar ya que vivo por y para la adrenalina.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Genial, ahora tenemos unas cuantas instancias, vamos a jugar con ellas:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">hci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="n">length</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;haha&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="kt">Just</span> <span class="mi">0</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">EmptyTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">yesno</span>
<span class="nf">yesno</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Bien ¡Funciona! Vamos a hacer una función que imite el comportamiento de una
sentencia <code class="docutils literal notranslate"><span class="pre">if</span></code>, pero que funcione con valores <code class="docutils literal notranslate"><span class="pre">YesNo</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">yesnoIf</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">yesnoIf</span> <span class="n">yesnoVal</span> <span class="n">yesResult</span> <span class="n">noResult</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">yesno</span> <span class="n">yesnoVal</span> <span class="kr">then</span> <span class="n">yesResult</span> <span class="kr">else</span> <span class="n">noResult</span>
</pre></div>
</div>
<p>Bastante simple. Toma un valor con un grado de verdad y otros dos valores más.
Si el primer valor es verdadero, devuelve el primer valor de los otros dos,
de otro modo, devuelve el segundo.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">[]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">True</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">500</span><span class="p">)</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">Nothing</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="la-clase-de-tipos-funtor">
<span id="funtores"></span><h2>La clase de tipos funtor<a class="headerlink" href="#la-clase-de-tipos-funtor" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta ahora, nos hemos encontrado con un montón de clases de tipos de la
librería estándar. Hemos jugado con <code class="docutils literal notranslate"><span class="pre">Ord</span></code>, la cual es para cosas que pueden
ser ordenadas. Hemos visto <code class="docutils literal notranslate"><span class="pre">Eq</span></code>, que es para cosas que pueden ser
equiparadas. Vimos también <code class="docutils literal notranslate"><span class="pre">Show</span></code>, la cual sirve como interfaz para los
tipos cuyos valores pueden ser representados como cadenas. Nuestro buen amigo
<code class="docutils literal notranslate"><span class="pre">Read</span></code> estará aquí siempre que necesitemos convertir una cadena a un valor
de algún tipo. Y ahora, vamos a echar un vistazo a la clase de tipos
<code class="docutils literal notranslate"><span class="pre">Functor</span></code>, la cual es básicamente para cosas que se pueden mapear.
Seguramente ahora mismo estés pensando en listas, ya que mapear una lista es
algún muy común en Haskell. Y estás en lo cierto, el tipo lista es miembro de
la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code>.</p>
<p>¿Qué mejor forma de conocer la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code> que ver como está
implementada? Vamos a echar una ojeada.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<img alt="Functor" class="align-right" src="../_images/functor.png" />
<p>De acuerdo. Hemos visto que define una función, <code class="docutils literal notranslate"><span class="pre">fmap</span></code>, y no proporciona
ninguna implementación por defecto para ella. El tipo de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es
interesante. En las definiciones de clases de tipos que hemos visto hasta
ahora, la variable de tipo que ha tenido un papel importante en la clase de
tipos ha sido un tipo concreto, como <code class="docutils literal notranslate"><span class="pre">a</span></code> en <code class="docutils literal notranslate"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Bool</span></code>. Pero ahora, <code class="docutils literal notranslate"><span class="pre">f</span></code> no es un tipo concreto (un tipo que puede tener
un valor, como <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">Bool</span></code> o <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">String</span></code>), sino un constructor de
tipos que toma un tipo como parámetro. Un ejemplo rápido para recordar:
<code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code> es un tipo concreto, pero <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> es un constructor de tipos
que toma un tipo como parámetro. De cualquier modo, hemo visto que <code class="docutils literal notranslate"><span class="pre">fmap</span></code>
toma una función de un tipo a otro y un funtor aplicado a un tipo y devuelve
otro funtor aplicado con el otro tipo.</p>
<p>Si esto te suena un poco confuso, no te preocupes. Lo verás todo más claro
ahora cuando mostremos un cuantos ejemplos. Mmm… esta declaración de tipo
me recuerda a algo. Si no sabes cual es el tipo de <code class="docutils literal notranslate"><span class="pre">map</span></code>, es este: <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">::</span>
<span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></code>.</p>
<p>¡Interesante! Toma una función de un tipo a otro y una lista de un tipo y
devuelve una lista del otro tipo. Amigos, creo que acabamos de descubir un
funtor. De hecho, <code class="docutils literal notranslate"><span class="pre">map</span></code> es <code class="docutils literal notranslate"><span class="pre">fmap</span></code> pero solo funciona con listas. Aquí
tienes como las listas tienen una instancia para la clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="n">map</span>
</pre></div>
</div>
<p>¡Eso es! Fíjate que no hemos escrito <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">[a]</span> <span class="pre">where</span></code>, ya que
a partir de <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></code> vemos que <code class="docutils literal notranslate"><span class="pre">f</span></code> tiene que ser
un constructor de tipos que toma un parámetro. <code class="docutils literal notranslate"><span class="pre">[a]</span></code> ya es un tipo concreto
(un lista con cualquier tipo dentro), mientras que <code class="docutils literal notranslate"><span class="pre">[]</span></code> es un constructor
de tipos que toma un parámetro y produce cosas como <code class="docutils literal notranslate"><span class="pre">[Int]</span></code>, <code class="docutils literal notranslate"><span class="pre">[String]</span></code> o
incluso <code class="docutils literal notranslate"><span class="pre">[[String]]</span></code>.</p>
<p>Como para las listas, <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es simplemente <code class="docutils literal notranslate"><span class="pre">map</span></code>, obtenemos el mismo
resultado cuando las usamos con listas.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>¿Qué pasa cuando realizamos <code class="docutils literal notranslate"><span class="pre">map</span></code> o <code class="docutils literal notranslate"><span class="pre">fmap</span></code> sobre listas vacías? Bien,
desde luego obenemos una lista vacía. Simplemente convierte una lista vacía
con el tipo <code class="docutils literal notranslate"><span class="pre">[a]</span></code> a una lista vacía con el tipo <code class="docutils literal notranslate"><span class="pre">[b]</span></code>.</p>
<p>Los tipos que pueden actuar como una caja pueden ser funtores. Puede pensar
en una lista como una caja que tiene un número ilimitado de pequeños
compartimientos y puden estar todos vacíos, o pueden estár algunos llenos.
Asi que, ¿Qué más tiene la propiedad de comportarse como una caja? Por
ejemplo, el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">a</span></code>. De algún modo, es como una caja que puede o bien
no contener nada, en cuyo caso su valor será <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, o puede contener
algo, como <code class="docutils literal notranslate"><span class="pre">&quot;HAHA&quot;</span></code>, en cuyo caso su valor ser`á <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;HAHA&quot;</span></code>. Aquí
tienes como <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> es un funtor:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>De nuevo, fíjate que hemos escrito <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">Maybe</span> <span class="pre">where</span></code> en lugar
de <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Maybe</span> <span class="pre">m)</span> <span class="pre">where</span></code>, como hicimos cuando utilizamos la
clase <code class="docutils literal notranslate"><span class="pre">YesNo</span></code> junto con <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>. <code class="docutils literal notranslate"><span class="pre">Functor</span></code> quiere un constructor de
tipos que tome un tipo y no un tipo concreto. Si mentalemente remplazas las
<code class="docutils literal notranslate"><span class="pre">f</span></code> con <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>, <code class="docutils literal notranslate"><span class="pre">fmap</span></code> actua como <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></code>
para este tipo en particular, lo cual se ve bien. Pero si remplazas <code class="docutils literal notranslate"><span class="pre">f</span></code> con
<code class="docutils literal notranslate"><span class="pre">(Maybe</span> <span class="pre">m)</span></code>, entonces parecerá que actua como <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">b</span></code>, lo cual no tiene ningún maldito sentido ya que <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> toma un
solo parámetro.</p>
<p>De cualquier forma, la implementación de <code class="docutils literal notranslate"><span class="pre">fmap</span></code> es muy simple. Si es un
valor vacío o <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>, entonces simplemente devolvemos <code class="docutils literal notranslate"><span class="pre">Nothing</span></code>. Si
mapeamos una caja vacía obtenemos una caja vacía. Tiene sentido. De la misma
forma que si mapeamos una lista vacía obtenemos un lista vacía. Si no es un
valor vacío, sino más bien un único valor envuelto por <code class="docutils literal notranslate"><span class="pre">Just</span></code>, entonces
aplicamos la función al contenido de <code class="docutils literal notranslate"><span class="pre">Just</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;Something serious.&quot;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="s">&quot;Something serious. HEY GUYS IM INSIDE THE JUST&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">200</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">400</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>Otra cosa que puede ser mapeada y por tanto puede tener una instancia de
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> es nuestro tipo <code class="docutils literal notranslate"><span class="pre">Tree</span> <span class="pre">a</span></code>. También puede ser visto como una caja
(contiene varios o ningún valor) y el constructor de tipos <code class="docutils literal notranslate"><span class="pre">Tree</span></code> toma
exactamente un parámetro de tipo. Si vemos la función <code class="docutils literal notranslate"><span class="pre">fmap</span></code> como si fuera
una función hecha exclusivamente para <code class="docutils literal notranslate"><span class="pre">Tree</span></code>, su declaración de tipo sería
como <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Tree</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Tree</span> <span class="pre">b</span></code>. Vamos a utilizar la recursión con éste.
Mapear un árbol vacío poducirá un árbol vacío. Mapear un árbol no vacío
producirá un árbol en el que la función será aplicada al elemento raíz
y sus sub-árboles derechos e izquierdos serán los mismos sub-árboles, solo
que serán mapeado con la función.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">EmptyTree</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">leftsub</span> <span class="n">rightsub</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">leftsub</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">rightsub</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">EmptyTree</span>
<span class="kt">EmptyTree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">12</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">20</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))))</span> <span class="kt">EmptyTree</span>
</pre></div>
</div>
<p>¡Bien! ¿Qué pasa con <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>? ¿Puede ser un funtor? La clase de tipos
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> quiere constructores de tipos que tomen un solo parámetro de tipo
pero <code class="docutils literal notranslate"><span class="pre">Either</span></code> toma dos. Mmm… ¡Ya se! aplicaremos parcialmente <code class="docutils literal notranslate"><span class="pre">Either</span></code>
suministrando un solo parámetro de forma que solo tenga un parámetro libre.
Aquí tienes como el tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> es un funtor en las librerías estándar.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
</pre></div>
</div>
<p>Bueno, bueno ¿Qué hemos hecho aquí? Pudes ver como hemos creado una instancia
para <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> en lugar de para solo <code class="docutils literal notranslate"><span class="pre">Either</span></code>. Esto es así porque`
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code> es un constructor de tipos que toma un parámetro, mientras que
<code class="docutils literal notranslate"><span class="pre">Either</span></code> toma dos. Si <code class="docutils literal notranslate"><span class="pre">fmap</span></code> fuese específicamente para <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span></code>
entonces su declaración de tipo sería <code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">c</span></code>
ya que es lo mismo que <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(Either</span> <span class="pre">a)</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">(Either</span> <span class="pre">a)</span> <span class="pre">c</span></code>. En la
implementación, mapeamos en el caso del constructor de tipos <code class="docutils literal notranslate"><span class="pre">Right</span></code>, pero
no lo hacemos para el caso de <code class="docutils literal notranslate"><span class="pre">Left</span></code>. ¿Por qué? Bueno, si volvemos atrás
para ver como se define el tipo <code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></code>, varíamos algo como:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>Bueno, si quisieramos mapear una función sobre ambos, <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code> deberían
tener el mimso tipo. Quiero decir, si quisieramos mapear una función que
toma una cadena y devuelve otra cadena y <code class="docutils literal notranslate"><span class="pre">b</span></code> fuese una cadena pero <code class="docutils literal notranslate"><span class="pre">a</span></code>
fuese un número, ésto no funcionaria. También, viendo <code class="docutils literal notranslate"><span class="pre">fmap</span></code> si operara solo
con valores de <code class="docutils literal notranslate"><span class="pre">Either</span></code>, veríamos que el primer parámetro tiene que
permanecer igual mientras que el segundo puede variar y el primer parámetro
está asociado al constructor de datos <code class="docutils literal notranslate"><span class="pre">Left</span></code>.</p>
<p>Esto también encaja con nuestra analogía de las cajas si pensamos en <code class="docutils literal notranslate"><span class="pre">Left</span></code>
como una especie de caja vacía con un mensaje de error escrito en un lado
diciendonos porque la caja está vacía.</p>
<p>Los diccionarios de <code class="docutils literal notranslate"><span class="pre">Data.Map</span></code> también son funtores ya que pueden contener
(o no) valores. En el caso de <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></code>, <code class="docutils literal notranslate"><span class="pre">fmap</span></code> mapearía una función
<code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">v'</span></code> sobre un diccionario <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></code> y devolvería un diccionario con
el tipo <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v'</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Fíjate que <code class="docutils literal notranslate"><span class="pre">'</span></code> no tiene ningún significado especial en los tipos
de la misma forma que no tienen ningún significado especial a la
hora de nombrar valores. Se suele utilizar para referirse a cosas
que son similares, solo que un poco cambiadas.</p>
</div>
<p>¡Trata de imaginarte como se crea la instancia de <code class="docutils literal notranslate"><span class="pre">Map</span> <span class="pre">k</span></code> para <code class="docutils literal notranslate"><span class="pre">Functor</span></code>
tú mismo!</p>
<p>Con la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code> hemos visto como las clases de tipos puden
representar conceptos de orden superior interesantes. También hemos tenido un
poco de práctica aplicando parcialmente tipos y creando instancias. En uno de
los siguientes capítulos veremos algunas de las leyes que se aplican
a los funtores.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Los funtores deben obedecer algunas leyes de forma que tengan unas
propiedades de las que podamos depender para no tener que pensar
mucho luego. Si usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(+1)</span></code> sobre un la lista <code class="docutils literal notranslate"><span class="pre">[1,2,3,4]</span></code>
esperemamos obtener <code class="docutils literal notranslate"><span class="pre">[2,3,4,5]</span></code> y no su inversa, <code class="docutils literal notranslate"><span class="pre">[5,4,3,2]</span></code>. Si
usamos <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">(\a</span> <span class="pre">-&gt;</span> <span class="pre">a)</span></code> (la función identidad, que simplemente
devuelve su parámetro) sobre un lista, esperamos obtener la misma
lista como resultado. Por ejemplo, si le damos una instancia erronea
a nuestro tipo <code class="docutils literal notranslate"><span class="pre">Tree</span></code>, al usar <code class="docutils literal notranslate"><span class="pre">fmap</span></code> en un árbol donde el
sub-árbol izquierdo de un nodo solo contenga elementos menores que
el nodo y el sub-árbol derecho solo contenga elementos mayores que
el nodo podría producir un árbol donde no se cumpliera esto. Veremos
la leyes de los funtores con más detalle en un próximo capítulo.</p>
</div>
</div>
<div class="section" id="familias-y-artes-marciales">
<h2>Familias y artes marciales<a class="headerlink" href="#familias-y-artes-marciales" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Typefoo" class="align-right" src="../_images/typefoo.png" />
<p>Los constructores de tipos toman otros tipos como parámetros y terminan
produciendo tipos concretos. Esto me recuerda a las funciones, las cuales
toman valores como parámetros y producen valores. Hemos visto que los
constructores de tipos pueden ser parcialmente aplicados (<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span></code> es
un constructor de tipos que toma un tipo y devuelve un tipo concreto, como
<code class="docutils literal notranslate"><span class="pre">Either</span> <span class="pre">String</span> <span class="pre">Int</span></code>), al igual que la funciones. Muy interesante. En esta
sección, definiremos formalmente como los tipos son aplicados a los
constructores de tipos, de la misma definiremos formalmente como los valores
son aplicados a las funciones utilizando declaraciones de tipo. <strong>No
necesitas leer esta sección para continuar con tu búsqueda de la sabiduría
sobre Haskell</strong> y no consigues entenderlo, no te preocupes. Sin embargo,
si lo haces conseguiras un conocimiento profundo del sistema de tipos.</p>
<p>Así que, valores como <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;YEAH&quot;</span></code> o <code class="docutils literal notranslate"><span class="pre">takeWhile</span></code> (las funciones
también son valores ya que podemos usarlas como parámetros) tienen sus
correspondientes tipos. Los tipos son una pequeña etiqueta que llevan los
valores de forma que nos permitan razonar sobre estos. Pero los tipos tienen
sus propias pequeñas etiquetas, llamadas <strong>familias</strong>. Una familia es más o
menos el tipo de un tipo. Puede sonar un poco enrevesado y confuso, pero
en realidad es un concepto muy intersante.</p>
<p>¿Qué son las familias y para que son útiles? Bueno, vamos a examinar la
familia de un tipo utilizando el comando <code class="docutils literal notranslate"><span class="pre">:k</span></code> en GHCi.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Int</span>
<span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>¿Una estrella? Intrigante… ¿Qué significa? Una <code class="docutils literal notranslate"><span class="pre">*</span></code> significa que el tipo
es un tipo concreto. Un tipo concreto es un tipo que no toma ningún parámetro
de tipo y valores solo pueden tener tipos que sean tipos concretos. Si tuviera
que leer <code class="docutils literal notranslate"><span class="pre">*</span></code> en voz alta (hasta ahora no he tenido que hacerlo), diría
<em>estrella</em> o simplemente <em>tipo</em>.</p>
<p>Vale, ahora vamos a ver cual es la familia de <code class="docutils literal notranslate"><span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span>
<span class="kt">Maybe</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>El constructor de tipos <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> toma un tipo concreto (como <code class="docutils literal notranslate"><span class="pre">Int</span></code>) y luego
devuelve un tipo concreto como <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>. Y esto es lo que la familia nos
está diciendo. De la misma forma que <code class="docutils literal notranslate"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></code> representa una función que
toma un <code class="docutils literal notranslate"><span class="pre">Int</span></code> y devuelve un <code class="docutils literal notranslate"><span class="pre">Int</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> representa un constructor de
tipos que toma un tipo concreto y devuelve otro tipo concreto. Vamos a aplicar
el parámetro de tipo a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y ver cual es su familia.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Maybe</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>¡Justo como esperaba! Hemo pasado un parámetro de tipo a <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> y hemos
obtenido un tipo concreto (esto es lo que significa <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>). Un símil
(aunque no equivalente, los tipos y las familias son dos cosas distintas)
sería si hicieramos <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">isUpper</span></code> y <code class="docutils literal notranslate"><span class="pre">:t</span> <span class="pre">isUpper</span> <span class="pre">'A'</span></code>. <code class="docutils literal notranslate"><span class="pre">isUpper</span></code> tiene el
tipo <code class="docutils literal notranslate"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code> y <code class="docutils literal notranslate"><span class="pre">isUpper</span> <span class="pre">'A'</span></code> tiene el tipo <code class="docutils literal notranslate"><span class="pre">Bool</span></code> ya que su valor
es básicamente <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Utilizamos <code class="docutils literal notranslate"><span class="pre">:k</span></code> con un tipo para obtener su familia, de la misma forma que
utilizamos <code class="docutils literal notranslate"><span class="pre">:t</span></code> con un valor para obtener su tipo. Como ya hemos dicho, los
tipos son las etiquetas de los valores y las familias son las etiquetas de los
tipos y hay similitudes entre ambos.</p>
<p>Vamos a ver otra familia.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span>
<span class="kt">Either</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>¡Aha! Esto nos dice que <code class="docutils literal notranslate"><span class="pre">Either</span></code> toma dos tipos concretos como parámetros
de tipo y produce un tipo concreto. También se parece a una declaracion de
tipo de una función que toma dos valores y devuelve algo. Los construcotores
de tipos están currificados (como las funciones), así que podemos aplicarlos
parcialmente.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>Cuando quisimos que <code class="docutils literal notranslate"><span class="pre">Either</span></code> formara parte de la clase de tipos <code class="docutils literal notranslate"><span class="pre">Functor</span></code>,
tuvimos que aplicarlo parcialmente ya que <code class="docutils literal notranslate"><span class="pre">Functor</span></code> quiere tipos que tomen
un solo parámetro`,` mientras que <code class="docutils literal notranslate"><span class="pre">Either</span></code> toma dos. En otras palabras,
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> quiere tipos de la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> y por eso tuvimos que
aplicar parcialmente <code class="docutils literal notranslate"><span class="pre">Either</span></code> para obtener una familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> en lugar
de su familia original <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Si vemos la definición de <code class="docutils literal notranslate"><span class="pre">Functor</span></code>
otra vez</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>veremos que la variable de tipo <code class="docutils literal notranslate"><span class="pre">f</span></code> es utiliza como un tipo que que toma un
tipo y produce un tipo concreto. Sabemos que produce un tipo concreto porque
es utilizada como el tipo de un valor en una función. Podemos deducir que los
tipos que quieren amigables con <code class="docutils literal notranslate"><span class="pre">Functor</span></code> debe ser de la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>.</p>
<p>Ahora vamos a practicar un poco de artes marciales. Echa un vistazo a la clase
de tipos que voy a utilizar:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Tofu</span> <span class="n">t</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="ow">::</span> <span class="n">j</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="n">j</span>
</pre></div>
</div>
<p>Parece complicado ¿Cómo podríamos crear un tipo que tuviera una instancia para
esta clase de tipos extraña? Bueno, vamos a ver que familia tiene que tener.
Como <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">a</span></code> es utilizado como el tipo del valor que la función <code class="docutils literal notranslate"><span class="pre">tofu</span></code> toma
como parámetro, <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">a</span></code> debe tener la familia <code class="docutils literal notranslate"><span class="pre">*</span></code>. Asumimos <code class="docutils literal notranslate"><span class="pre">*</span></code> para <code class="docutils literal notranslate"><span class="pre">a</span></code>
de forma que podemos inferir que <code class="docutils literal notranslate"><span class="pre">j</span></code> pertenece a la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>.
Vemos que <code class="docutils literal notranslate"><span class="pre">t</span></code> también tiene que producir un tipo concreto y toma dos tipos.
Sabiendo que <code class="docutils literal notranslate"><span class="pre">a</span></code> es de la familia <code class="docutils literal notranslate"><span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">j</span></code> de <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>, podemos
inferir que <code class="docutils literal notranslate"><span class="pre">t</span></code> es de la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Así que toma un
tipo concreto (<code class="docutils literal notranslate"><span class="pre">a</span></code>), un constructor de tipos (<code class="docutils literal notranslate"><span class="pre">j</span></code>)  que toma un tipo
concreto y devuelve un tipo concreto. Wau.</p>
<p>Vale, vamos a crear un tipo con una familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Aquí
tienes una posible solución.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Frank</span> <span class="n">a</span> <span class="n">b</span>  <span class="ow">=</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">::</span> <span class="n">b</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>¿Cómo sabemos que este tipo pertenece a la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>?
Bueno, los campos de un TDA (tipos de datos algebraicos, <em>ADT</em> en inglés)
sirven para contener valores, así que obviamente pertenecen a la familia
<code class="docutils literal notranslate"><span class="pre">*</span></code>. Asumimos <code class="docutils literal notranslate"><span class="pre">*</span></code> para <code class="docutils literal notranslate"><span class="pre">a</span></code>, lo que significa que <code class="docutils literal notranslate"><span class="pre">b</span></code> toma un parámetro
de tipo y por lo tanto pertenece a la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Ahora que sabemos
las familia de <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">b</span></code> ya que son parámetros de <code class="docutils literal notranslate"><span class="pre">Frank</span></code>, vemos que
<code class="docutils literal notranslate"><span class="pre">Frank</span></code> pertenece a la familia <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. El primer <code class="docutils literal notranslate"><span class="pre">*</span></code>
representa <code class="docutils literal notranslate"><span class="pre">a</span></code> y <code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span></code> representa <code class="docutils literal notranslate"><span class="pre">b</span></code>. Vamos a crear algunos
valores de <code class="docutils literal notranslate"><span class="pre">Frank</span></code> y comprobar sus tipos.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">Maybe</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Tree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>Mmm… Como <code class="docutils literal notranslate"><span class="pre">frankField</span></code> tiene el tipo en forma de <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">b</span></code>, sus valores
deben tener tipos de forma similar. Puede ser como <code class="docutils literal notranslate"><span class="pre">Just</span> <span class="pre">&quot;HAHA&quot;</span></code>, el cual
tiene el tipo <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">[Char]</span></code> o puede ser como <code class="docutils literal notranslate"><span class="pre">['Y','E','S']</span></code> que tiene
el tipo <code class="docutils literal notranslate"><span class="pre">[Char]</span></code> (si usaramos nuestro tipo de listas que creamos
anteriormente, sería <code class="docutils literal notranslate"><span class="pre">List</span> <span class="pre">Char</span></code>). Y vemos que los tipos de los valores de
<code class="docutils literal notranslate"><span class="pre">Frank</span></code> se corresponden con la familia de <code class="docutils literal notranslate"><span class="pre">Frank</span></code>. <code class="docutils literal notranslate"><span class="pre">[Char]</span></code> pertenece a
la familia <code class="docutils literal notranslate"><span class="pre">*</span></code> y <code class="docutils literal notranslate"><span class="pre">Maybe</span></code> pertenece a <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Como para poder tener
valores un tipo tiene que ser un tipo concreto y por lo tanto debe ser
completamente aplicado, cada valor de <code class="docutils literal notranslate"><span class="pre">Frank</span> <span class="pre">bla</span> <span class="pre">blaaa</span></code> pertenece a la
familia <code class="docutils literal notranslate"><span class="pre">*</span></code>.</p>
<p>Crear la instancia de <code class="docutils literal notranslate"><span class="pre">Frank</span></code> para <code class="docutils literal notranslate"><span class="pre">Tofu</span></code> es bastante simple. Hemos visto
que <code class="docutils literal notranslate"><span class="pre">tofu</span></code> toma un <code class="docutils literal notranslate"><span class="pre">j</span> <span class="pre">a</span></code> (que por ejemplo podría ser <code class="docutils literal notranslate"><span class="pre">Maybe</span> <span class="pre">Int</span></code>) y
devuelve un <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">j</span> <span class="pre">a</span></code>. Así que si remplazamos <code class="docutils literal notranslate"><span class="pre">j</span></code> por <code class="docutils literal notranslate"><span class="pre">Frank</span></code>, el tipo del
resultado sería <code class="docutils literal notranslate"><span class="pre">Frank</span> <span class="pre">Int</span> <span class="pre">Maybe</span></code>.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Tofu</span> <span class="kt">Frank</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Frank</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Maybe</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">[]</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>No es muy útil, pero hemos calentado. Vamos a continuar haciedo artes
marciales. Tenemos este tipo:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Barry</span> <span class="n">t</span> <span class="n">k</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span> <span class="n">yabba</span> <span class="ow">::</span> <span class="n">p</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">::</span> <span class="n">t</span> <span class="n">k</span> <span class="p">}</span>
</pre></div>
</div>
<p>Y ahora queremos crear una instancia para la clase <code class="docutils literal notranslate"><span class="pre">Functor</span></code>. <code class="docutils literal notranslate"><span class="pre">Functor</span></code>
requiere tipos cuya familia sea <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> pero <code class="docutils literal notranslate"><span class="pre">Barry</span></code> no parece que
pertenezca a esa familia. ¿Cúal es la familia de <code class="docutils literal notranslate"><span class="pre">Barry</span></code>? Bueno, vemos que
toma tres parámetros de tipo, así que va ser algo como <code class="docutils literal notranslate"><span class="pre">algo</span> <span class="pre">-&gt;</span> <span class="pre">algo</span> <span class="pre">-&gt;</span> <span class="pre">algo</span>
<span class="pre">-&gt;</span> <span class="pre">*</span></code>. Esta claro que <code class="docutils literal notranslate"><span class="pre">p</span></code> es un tipo concreto y por lo tanto pertenece a la
familia <code class="docutils literal notranslate"><span class="pre">*</span></code>. Para <code class="docutils literal notranslate"><span class="pre">k</span></code> asumimos <code class="docutils literal notranslate"><span class="pre">*</span></code> y por extensión, <code class="docutils literal notranslate"><span class="pre">t</span></code> pertenece a
<code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Ahora solo tenemos que remplazar estas familia por los <em>algos</em> que
hemos utilizado y veremos que el tipo pertenece a la familia <code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*`</span>
<span class="pre">`-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Vamos a comprobarlo con GHCi.</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Barry</span>
<span class="kt">Barry</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>Ah, teníamos razón. Ahora, para hacer que este tipo forme parte de la clase
<code class="docutils literal notranslate"><span class="pre">Functor</span></code> tenemos que aplicar parcialmente los dos primeros parámetros de
tipo de forma que nos quedemos con <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code>. Esto significa que comenzaremos
con nuestra declaración de instancia así: <code class="docutils literal notranslate"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Barry</span> <span class="pre">a</span> <span class="pre">b)</span>
<span class="pre">where</span></code>. Si vemos <code class="docutils literal notranslate"><span class="pre">fmap</span></code> como si estuviese hecho exclusivamente para`
<code class="docutils literal notranslate"><span class="pre">Barry</span></code>, tendría un tipo <code class="docutils literal notranslate"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span> <span class="pre">b</span></code>,
ya que simplemente hemos remplazado la <code class="docutils literal notranslate"><span class="pre">f</span></code> de <code class="docutils literal notranslate"><span class="pre">Functor</span></code> por <code class="docutils literal notranslate"><span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span></code>.
El tercer parámetro de tipo de <code class="docutils literal notranslate"><span class="pre">Barry</span></code> tendría que cambiar y de esta forma
tendríamos:</p>
<div class="highlight-haskell notranslate"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Barry</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">}</span>
</pre></div>
</div>
<p>¡Ahí lo tienes! Simplemente hemos aplicado <code class="docutils literal notranslate"><span class="pre">f</span></code> sobre el primer campo.</p>
<p>En esta sección, hemos dado un buen vistazo a como funcionan los parámetros de
tipos y como se formalizan con la familias, de la misma forma que formalizamos
los parámetros de las funciones con las declaraciones de tipo. Hemos visto que
hay similitudes entre las funciones y los constructores de tipos. De todas
formas, son cosas totalmente distintas. Cuando trabajamos con Haskell,
normalmente no debes preocuparte por la familias ni inferir mentalmente las
familias como hemos hecho aquí. Lo normal es que tengas que aplicar
parcialmente tu tipo a <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></code> o <code class="docutils literal notranslate"><span class="pre">*</span></code> cuando creamos una instancia para
alguna clase de la librería estándar, pero está bien saber como funciona
realmente. Es interesante saber que los tipos tienen sus propios pequeños
tipos también. De nuevo, no tienes porque entender todo lo que acabamos de
hacer aquí, pero si entiendes como funcionan las familias, tienes más
posibilidades de entender correctamente el sistema de tipos de Haskell.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="entradasalida.html" title="Entrada y salida"
             >siguiente</a></li>
        <li class="right" >
          <a href="modulos.html" title="Módulos"
             >anterior</a> |</li>
        <li class="nav-item nav-item-0"><a href="../chapters.html">Índice</a> &#187;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>