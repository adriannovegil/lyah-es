
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Creando nuestros propios tipos y clases de tipos &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Entrada y salida" href="EntradaSalida.html" />
    <link rel="prev" title="Módulos" href="Modulos.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="EntradaSalida.html" title="Entrada y salida"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="Modulos.html" title="Módulos"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="creando-nuestros-propios-tipos-y-clases-de-tipos">
<h1>Creando nuestros propios tipos y clases de tipos<a class="headerlink" href="#creando-nuestros-propios-tipos-y-clases-de-tipos" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En capítulos anteriores vimos algunos tipos y clases de tipos de Haskell. ¡En
este capítulo vamos a ver como crearlos nosotros mismos! ¿A qué no te lo
esperabas?</p>
<div class="section" id="introduccion-a-los-tipos-de-datos-algebraicos">
<h2>Introducción a los tipos de datos algebraicos<a class="headerlink" href="#introduccion-a-los-tipos-de-datos-algebraicos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta ahora hemos jugado con muchos tipos: <tt class="docutils literal"><span class="pre">Bool</span></tt>, <tt class="docutils literal"><span class="pre">Int</span></tt>, <tt class="docutils literal"><span class="pre">Char</span></tt>,
<tt class="docutils literal"><span class="pre">Maybe</span></tt>, etc. Pero ¿Cómo los creamos? Bueno, una forma es usar la palabra
clave <tt class="docutils literal"><span class="pre">data</span></tt> para definir un tipo. Vamos a ver como está definido el tipo
<tt class="docutils literal"><span class="pre">Bool</span></tt> en la librería estándar:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">data</span></tt> significa que vamos a definir un nuevo tipo de dato. La parte a la
izquierda del <tt class="docutils literal"><span class="pre">=</span></tt> denota el tipo, que es <tt class="docutils literal"><span class="pre">Bool</span></tt>. La parte a la derecha
son los <strong>constructores de datos</strong>. Estos especifican los diferentes valores
que puede tener un tipo. El <tt class="docutils literal"><span class="pre">|</span></tt> se puede leer como una <em>o</em>. Así que lo
podemos leer como: El tipo <tt class="docutils literal"><span class="pre">Bool</span></tt> puede tener un valor <tt class="xref docutils literal"><span class="pre">True</span></tt> o <tt class="xref docutils literal"><span class="pre">False</span></tt>.
Tanto el nombre del tipo como el de los constructores de datos deben tener
la primera letra en mayúsculas.</p>
<p>De la misma forma podemos pensar que el tipo <tt class="docutils literal"><span class="pre">Int</span></tt> está definido como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">2147483648</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2147483647</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">2147483647</span>
</pre></div>
</div>
<img alt="Hombre de las cavernas" class="align-left" src="../_images/caveman.png" />
<p>El primer y el último constructor de datos son el mínimo y el máximo valor
posible del tipo <tt class="docutils literal"><span class="pre">Int</span></tt>. En realidad no está definido así, los tres puntos
están ahí porque hemos omitido una buena cantidad de números, así que esto
es solo para motivos ilustrativos.</p>
<p>Ahora vamos a pensar en como definiríamos una figura en Haskell. Una forma
sería usar tuplas. Un círculo podría ser <tt class="docutils literal"><span class="pre">(43.1,</span> <span class="pre">55.0,</span> <span class="pre">10.4)</span></tt> donde el
primer y el segundo campo son las coordenadas del centro del círculo mientras
que el tercer campo sería el radio. Suena bien, pero esto nos permitiría
también definir un vector 3D o cualquier otra cosa. Una solución mejor sería
crear nuestro propio tipo que represente una figura. Digamos que una figura
solo puede ser un círculo o un rectángulo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>
</pre></div>
</div>
<p>¿Qué es esto? Piensa un poco a que se parece. El constructor de datos`
<tt class="docutils literal"><span class="pre">Circle</span></tt> tiene tres campos que toman valores en coma flotante. Cuando
creamos un constructor de datos, opcionalmente podemos añadir tipos después
de él de forma que estos serán los valores que contenga. Aquí, los primeros
dos componentes son las coordenadas del centro, mientras que el tercero es
el radio. El constructor de datos <tt class="docutils literal"><span class="pre">Rectangle</span></tt> tiene cuatro campos que
aceptan valores en coma flotante. Los dos primeros representan las coordenadas
de la esquina superior izquierda y los otros dos las coordenadas de la
inferior derecha.</p>
<p>Ahora, cuando hablamos de campos, en realidad estamos hablando de parámetros.
Los constructores de datos son en realidad funciones que devuelven un valor
del tipo para el que fueron definidos. Vamos a ver la declaración de tipo de
estos dos constructores de datos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Circle</span>
<span class="kt">Circle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Rectangle</span>
<span class="kt">Rectangle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
</pre></div>
</div>
<p>Bien, los constructores de datos son funciones como todo lo demás ¿Quíen lo
hubiera pensado? Vamos a hacer una función que tome una figura y devuleva su
superficie o área:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div>
</div>
<p>La primera cosa destacable aquí es la declaración de tipo. Dice que toma una
figura y devuelve un valor en coma flotante. No podemos escribir una
declaración de tipo como <tt class="docutils literal"><span class="pre">Circle</span> <span class="pre">-&gt;</span> <span class="pre">Float</span></tt> ya que <tt class="docutils literal"><span class="pre">Circle</span></tt> no es un tipo,
<tt class="docutils literal"><span class="pre">Shape</span></tt> si lo es. Del mismo modo no podemos declarar una función cuya
declaración de tipo sea <tt class="docutils literal"><span class="pre">True</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></tt>. La siguiente cosa que podemos
destacar es que podemos usar el ajuste de patrones con los constructores. Ya
hemos utilizado el ajuste de patrones con constructores anteriormente (en
realidad todo el tiempo) cuando ajustamos valores como <tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="xref docutils literal"><span class="pre">False</span></tt>,
<tt class="docutils literal"><span class="pre">5</span></tt>, solo que esos valores no tienen campos. Simplemente escribimos el
constructor y luego ligamos sus campos a nombres. Como estamos interesados en
el radio, realmente no nos importan los dos primeros valores que nos dicen
donde está el círculo.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">10</span>
<span class="mf">314.15927</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">100</span> <span class="mi">100</span>
<span class="mf">10000.0</span>
</pre></div>
</div>
<p>Bien ¡Funciona! Pero si intentamos mostrar por pantalla <tt class="docutils literal"><span class="pre">Circle</span> <span class="pre">10</span> <span class="pre">20</span> <span class="pre">5</span></tt>
en una sesión de GHCi obtendremos un error. Esto sucede porque Haskell aún no
sabe como representar nuestro tipo con una cadena. Recuerda que cuando
intentamos mostrar un valor por pantalla, primero Haskell ejecuta la función
<tt class="docutils literal"><span class="pre">show</span></tt> para obtener la representación en texto de un dato y luego lo muestra
en la terminal. Para hacer que nuestro tipo <tt class="docutils literal"><span class="pre">Shape</span></tt> forme parte de la clase
de tipo <tt class="docutils literal"><span class="pre">Show</span></tt> hacemos esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>No vamos a preocuparnos ahora mismo acerca de derivar. Simplemente diremos que
si añadimos <tt class="docutils literal"><span class="pre">deriving</span> <span class="pre">(Show)</span></tt> al final de una declaración de tipo,
automáticamente Haskell hace que ese tipo forme parte de la clase de tipos
<tt class="docutils literal"><span class="pre">Show</span></tt>. Así que ahora ya podemos hacer esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="mi">50</span> <span class="mi">230</span> <span class="mi">60</span> <span class="mi">90</span>
<span class="kt">Rectangle</span> <span class="mf">50.0</span> <span class="mf">230.0</span> <span class="mf">60.0</span> <span class="mf">90.0</span>
</pre></div>
</div>
<p>Los constructores de datos son funciones, así que podemos mapearlos,
aplicarlos parcialmente o cualquier otra cosa. Si queremos una lista de
círculos concéntricos con diferente radio podemos escribir esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">4.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">]</span>
</pre></div>
</div>
<p>Nuestro tipo de dato es bueno, pero podría se mejor. Vamos a crear un tipo de
dato intermedio que defina un punto en espacio bidimensional. Luego lo
usaremos para hacer nuestro tipo más evidente.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Te habrás dado cuenta de que hemos usado el mismo nombre para el tipo que para
el constructor de datos. No tiene nada de especial, es algo común usar el
mismo nombre que el del tipo si solo hay un constructor de datos. Así que
ahora <tt class="docutils literal"><span class="pre">Circle</span></tt> tiene dos campos, uno es el del tipo <tt class="docutils literal"><span class="pre">Point</span></tt> y el otro del
tipo <tt class="docutils literal"><span class="pre">Float</span></tt>. De esta forma es más fácil entender que es cada cosa. Lo mismo
sucede para el rectángulo. Tenemos que modificar nuestra función <tt class="docutils literal"><span class="pre">surface</span></tt>
para que refleje estos cambios.</p>
<blockquote>
surface :: Shape -&gt; Float
surface (Circle _ r) = pi * r ^ 2
surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)</blockquote>
<p>Lo único que hemos cambiado han sido los patrones. Hemos descartado
completamente el punto en el patrón del círculo. Por otra parte, en  el patrón
del rectángulo, simplemente hemos usado un ajuste de patrones anidado para
obtener las coordenadas de los puntos. Si hubiésemos querido hacer una
referencia directamente a los puntos por cualquier motivo podríamos haber
utilizado un patrón <em>como</em>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">100</span> <span class="mi">100</span><span class="p">))</span>
<span class="mf">10000.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
<span class="mf">1809.5574</span>
</pre></div>
</div>
<p>¿Cómo sería una función que desplaza una figura? Tomaría una figura, la
cantidad que se debe desplazar en el eje <em>x</em>, la cantidad que se debe desplazar
en el eje <em>y</em> y devolvería una nueva figura con las mismas dimensiones pero
desplazada.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">nudge</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="n">r</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y2</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<p>Bastante sencillo. Añadimos las cantidades a desplazar a los puntos que
representan la posición de las figuras.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">34</span> <span class="mi">34</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span>
<span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">39.0</span> <span class="mf">44.0</span><span class="p">)</span> <span class="mf">10.0</span>
</pre></div>
</div>
<p>Si no queremos trabajar directamente con puntos, podemos crear funciones
auxiliares que creen figuras de algún tamaño en el centro del eje de
coordenadas de modo que luego las podamos desplazar.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">baseCircle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseCircle</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span>

<span class="nf">baseRect</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseRect</span> <span class="n">width</span> <span class="n">height</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">width</span> <span class="n">height</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="n">baseRect</span> <span class="mi">40</span> <span class="mi">100</span><span class="p">)</span> <span class="mi">60</span> <span class="mi">23</span>
<span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">60.0</span> <span class="mf">23.0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">100.0</span> <span class="mf">123.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Como es lógico, podemos exportar nuestros datos en los módulos. Para hacerlo,
solo tenemos que escribir el nombre del tipo juntos a las funciones
exportadas, y luego añadirles unos paréntesis que contengan los constructores
de datos que queramos que se exporten, separados por comas. Si queremos que se
exporten todos los constructores de datos para un cierto tipo podemos usar
<tt class="docutils literal"><span class="pre">..</span></tt>.</p>
<p>Si quisiéramos exportar las funciones y tipos que acabamos de crear en un
módulo, podríamos empezar con esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Shapes</span>
<span class="p">(</span> <span class="kt">Point</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="kt">Shape</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="nf">surface</span>
<span class="p">,</span> <span class="nf">nudge</span>
<span class="p">,</span> <span class="nf">baseCircle</span>
<span class="p">,</span> <span class="nf">baseRect</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>Haciendo <tt class="docutils literal"><span class="pre">Shape</span> <span class="pre">(..)</span></tt> estamos exportando todos los constructores de datos
de <tt class="docutils literal"><span class="pre">Shape</span></tt>, lo que significa que cualquiera que importe nuestro módulo puede
crear figuras usando los constructores <tt class="docutils literal"><span class="pre">Circle</span></tt> y <tt class="docutils literal"><span class="pre">Rectangle</span></tt>. Sería lo
mismo que escribir <tt class="docutils literal"><span class="pre">Shape</span> <span class="pre">(Rectangle,</span> <span class="pre">Circle)</span></tt>.</p>
<p>También podríamos optar por no exportar ningún constructor de datos para
<tt class="docutils literal"><span class="pre">Shape</span></tt> simplemente escribiendo <tt class="docutils literal"><span class="pre">Shape</span></tt> en dicha sentencia. De esta forma,
aquel que importe nuestro módulo solo podrá crear figuras utilizando las
funciones auxiliares <tt class="docutils literal"><span class="pre">baseCircle</span></tt> y <tt class="docutils literal"><span class="pre">baseRect</span></tt>. <tt class="docutils literal"><span class="pre">Data.Map</span></tt> utiliza este
método. No puedes crear un diccionario utilizando <tt class="docutils literal"><span class="pre">Map.Map</span> <span class="pre">[(1,2),(3,4)]</span></tt> ya
que no se exporta el constructor de datos. Sin embargo, podemos crear un
diccionario utilizando funciones auxiliares como <tt class="docutils literal"><span class="pre">Map.fromList</span></tt>. Recuerda,
los constructores de datos son simples funciones que toman los campos del tipo
como parámetros y devuelven un valor de un cierto tipo (como <tt class="docutils literal"><span class="pre">Shape</span></tt>) como
resultado. Así que cuando elegimos no exportarlos, estamos previniendo que la
gente que importa nuestro módulo pueda utilizar esas funciones, pero si alguna
otra función devuelve devuelve el tipo que estamos exportando, las podemos
utilizar para crear nuestros propios valores de ese tipo.</p>
<p>No exportar los constructores de datos de un tipo de dato lo hace más
abstracto en el sentido de que oculta su implementación. Sin embargo, los
usuarios del módulo no podrán usar el ajuste de patrones sobre ese tipo.</p>
</div>
<div class="section" id="sintaxis-de-registro">
<h2>Sintaxis de registro<a class="headerlink" href="#sintaxis-de-registro" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Tocadiscos" class="align-right" src="../_images/record.png" />
<p>Bien, se nos ha dado la tarea de crear un tipo que describa a una persona.
La información que queremos almacenar de cada persona es: nombre, apellidos,
edad, altura, número de teléfono y el sabor de su helado favorito. No se nada
acerca de ti, pero para mi es todo lo que necesito saber de una persona.
¡Vamos allá!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Vale. El primer campo es el nombre, el segundo el apellido, el tercero su
edad y seguimos contando. Vamos a crear una persona.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">guy</span>
<span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
</pre></div>
</div>
<p>Parece interesante, pero desde luego no muy legible ¿Y si queremos crear una
función que obtenga información por separado de una persona? Una función que
obtenga el nombre de una persona, otra función que obtenga el apellido, etc.
Bueno, las tendríamos que definir así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">firstName</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">firstname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>

<span class="nf">lastName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lastName</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">lastname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>

<span class="nf">age</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">age</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">age</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">age</span>

<span class="nf">height</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">height</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">height</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">height</span>

<span class="nf">phoneNumber</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">phoneNumber</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">number</span>

<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">flavor</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">flavor</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flavor</span>
</pre></div>
</div>
<p>¡Fiuuu! La verdad es que no me divertido escribiendo esto. A parte de que este
método sea un lío y un poco ABURRIDO de escribir, funciona.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">firstName</span> <span class="n">guy</span>
<span class="s">&quot;Buddy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">height</span> <span class="n">guy</span>
<span class="mf">184.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flavor</span> <span class="n">guy</span>
<span class="s">&quot;Chocolate&quot;</span>
</pre></div>
</div>
<p>Ahora es cuando piensas: debe de haber un método mejor. Pues no, lo siento
mucho.</p>
<p>Estaba de broma :P Si que lo hay. Los creadores de Haskell fueron muy
inteligentes y anticiparon este escenario. Incluyeron un método alternativo
de definir tipos de dato. Así es como podríamos conseguir la misma
funcionalidad con la sintaxis de registro.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">,</span> <span class="n">height</span> <span class="ow">::</span> <span class="kt">Float</span>
                     <span class="p">,</span> <span class="n">phoneNumber</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">flavor</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>En lugar de nombrar los campos uno tras otro separados por espacios,
utilizamos un par de llaves. Dentro, primero escribimos el nombre de un campo,
por ejemplo <tt class="docutils literal"><span class="pre">firstName</span></tt> y luego escribimos unos dobles puntos <tt class="docutils literal"><span class="pre">::</span></tt>
(también conocido como <em>Paamayim Nekudotayim</em> xD) y luego especificamos el
tipo. El tipo de dato resultante es exactamente el mismo. La principal
diferencia es que de esta forma se crean funciones que obtienen esos campos
del tipo de dato. Al usar la sintaxis de registro con este tipo de dato,
Haskell automáticamente crea estas funciones: <tt class="docutils literal"><span class="pre">firstName</span></tt>, <tt class="docutils literal"><span class="pre">lastName</span></tt>,
<tt class="docutils literal"><span class="pre">age</span></tt>, <tt class="docutils literal"><span class="pre">height</span></tt>, <tt class="docutils literal"><span class="pre">phoneNumber</span></tt> y <tt class="docutils literal"><span class="pre">flavor</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flavor</span>
<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">firstName</span>
<span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>Hay otro beneficio cuando utilizamos la sintaxis de registro. Cuando derivamos
<tt class="docutils literal"><span class="pre">Show</span></tt> para un tipo, mostrará los datos de forma diferente si utilizamos la
sintaxis de registro para definir e instanciar el tipo. Supongamos que tenemos
un tipo que representa un coche. Queremos mantener un registro de la compañía
que lo hizo, el nombre del modelo y su años de producción. Mira.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
</pre></div>
</div>
<p>Si lo definimos usando la sintaxis de registro, podemos crear un coche nuevo
de esta forma:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="mi">1967</span><span class="p">}</span>
</pre></div>
</div>
<p>Cuando creamos un coche nuevo, no hace falta poner los campos en el orden
adecuado mientras que los pongamos todos. Pero si no usamos la sintaxis de
registro debemos especificarlos en su orden correcto.</p>
<p>Utiliza la sintaxis de registro cuando un constructor tenga varios campos y no
sea obvio que campo es cada uno. Si definimos el tipo de un vector 3D como
<tt class="docutils literal"><span class="pre">data</span> <span class="pre">Vector</span> <span class="pre">=</span> <span class="pre">Vector</span> <span class="pre">Int</span> <span class="pre">Int</span> <span class="pre">Int</span></tt>, es bastante obvio que esos campos son
las componentes del vector. Sin embargo, en nuestros tipo <tt class="docutils literal"><span class="pre">Person</span></tt> y
<tt class="docutils literal"><span class="pre">Car</span></tt>, no es tan obvio y nos beneficia mucho el uso de esta sintaxis.</p>
</div>
<div class="section" id="parametros-de-tipo">
<h2>Parámetros de tipo<a class="headerlink" href="#parametros-de-tipo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Un constructor de datos puede tomar algunos valores como parámetros y producir
un nuevo valor. Por ejemplo, el constructor <tt class="docutils literal"><span class="pre">Car</span></tt> toma tres valores y
produce un valor del tipo coche. De forma similar, un <strong>constructor de tipos</strong>
puede tomar tipos como parámetros y producir nuevos tipos. Esto puede parecer
un poco recursivo al principio, pero no es nada complicado. Si has utilizado
las plantillas de <em>C++</em> te será familiar. Para obtener una imagen clara de
como los parámetros de tipo funcionan en realidad, vamos a ver un ejemplo de
como un tipo que ya conocemos es implementado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div>
</div>
<img alt="Yeti" class="align-left" src="../_images/yeti.png" />
<p>La <tt class="docutils literal"><span class="pre">a</span></tt> es un parámetro de tipo. Debido a que hay un parámetro de tipo
involucrado en esta definición, llamamos a <tt class="docutils literal"><span class="pre">Maybe</span></tt> un constructor de tipos.
Dependiendo de lo que queramos que este tipo contenga cuando un valor no es
<tt class="docutils literal"><span class="pre">Nothing</span></tt>, este tipo puede acabar produciendo tipos como <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt>,
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Car</span></tt>, <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></tt>, etc. Ningún valor puede tener un tipo que sea
simplemente <tt class="docutils literal"><span class="pre">Maybe</span></tt>, ya que eso no es un tipo por si mismo, es un
constructor de tipos. Para que sea un tipo real que algún valor pueda tener,
tiene que tener todos los parámetros de tipo definidos.</p>
<p>Si pasamos <tt class="docutils literal"><span class="pre">Char</span></tt> como parámetro de tipo a <tt class="docutils literal"><span class="pre">Maybe</span></tt>, obtendremos el tipo
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Char</span></tt>. Por ejemplo, el valor <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">'a'</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">Maybe</span>
<span class="pre">Char</span></tt>.</p>
<p>Puede que no lo sepas, pero utilizamos un tipo que tenía un parámetro de tipo
antes de que empezáramos a utilizar el tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Ese tipo es el tipo
lista. Aunque hay un poco decoración sintáctica, el tipo lista toma un
parámetro para producir un tipo concreto. Los valores pueden tener un tipo
<tt class="docutils literal"><span class="pre">[Int]</span></tt>, un tipo <tt class="docutils literal"><span class="pre">[Char]</span></tt>, <tt class="docutils literal"><span class="pre">[[String]]</span></tt>, etc. pero no puede haber un
valor cuyo tipo sea simplemente <tt class="docutils literal"><span class="pre">[]</span></tt>.</p>
<p>Vamos a jugar un poco con el tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="kt">Just</span> <span class="mf">10.0</span>
</pre></div>
</div>
<p>Los parámetros de tipo son útiles ya que nos permiten crear diferentes tipos
dependiendo del tipo que queramos almacenar en nuestros tipos de datos (valga
la redundancia). Cuando hacemos <tt class="docutils literal"><span class="pre">:t</span> <span class="pre">Just</span> <span class="pre">&quot;Haha&quot;</span></tt> el motor de inferencia de
tipos deduce que el tipo debe ser <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">[Char]</span></tt>, ya que la <tt class="docutils literal"><span class="pre">a</span></tt> en <tt class="docutils literal"><span class="pre">Just</span>
<span class="pre">a</span></tt> es una cadena, luego el <tt class="docutils literal"><span class="pre">a</span></tt> en <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> debe ser también una cadena.</p>
<p>Como habrás visto el tipo de <tt class="docutils literal"><span class="pre">Nothing</span></tt> es <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. Su tipo es
polimórfico. Si una función requiere un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt> como parámetro le
podemos pasar  un <tt class="docutils literal"><span class="pre">Nothing</span></tt> ya que no contiene ningún valor. El tipo <tt class="docutils literal"><span class="pre">Maybe</span>
<span class="pre">a</span></tt> puede comportarse como un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt>, de la misma forma que <tt class="docutils literal"><span class="pre">5</span></tt> puede
comportarse como un <tt class="docutils literal"><span class="pre">Int</span></tt> o como un <tt class="docutils literal"><span class="pre">Double</span></tt>. De forma similar el tipo de
las listas vacías es <tt class="docutils literal"><span class="pre">[a]</span></tt>. Una lista vacía puede comportarse como cualquier
otra lista. Por eso podemos hacer cosas como <tt class="docutils literal"><span class="pre">[1,2,3]</span> <span class="pre">++</span> <span class="pre">[]</span></tt> y
<tt class="docutils literal"><span class="pre">[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;]</span> <span class="pre">++</span> <span class="pre">[]</span></tt>.</p>
<p>El uso de parámetros de tipo nos puede beneficiar, pero solo en los casos que
tenga sentido. Normalmente los utilizamos cuando nuestro tipo de dato
funcionará igual sin importar el tipo de dato que contenga, justo como nuestro
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. Si nuestro tipo es como una especie de caja, es un buen lugar
para usar los parámetros de tipo. Podríamos cambiar nuestro tipo <tt class="docutils literal"><span class="pre">Car</span></tt> de:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span>
               <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>A:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Car</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="n">a</span>
                     <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="n">b</span>
                     <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="n">c</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Pero ¿Tiene algún beneficio? La respuesta es: probablemente no, ya que al
final acabaremos escribiendo funciones que solo funcionen con el tipo <tt class="docutils literal"><span class="pre">Car</span>
<span class="pre">String</span> <span class="pre">String</span> <span class="pre">Int</span></tt>. Por ejemplo, dada la primera definición de <tt class="docutils literal"><span class="pre">Car</span></tt>,
podríamos crear una función que mostrara las propiedades de un coche con un
pequeño texto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">tellCar</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stang</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="n">stang</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
</pre></div>
</div>
<p>¡Una función muy bonita! La declaración de tipo es simple y funciona
perfectamente. Ahora ¿Cómo sería si <tt class="docutils literal"><span class="pre">Car</span></tt> fuera en realidad <tt class="docutils literal"><span class="pre">Car</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></tt>?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">tellCar</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div>
</div>
<p>Tenemos que forzar a que la función tome un <tt class="docutils literal"><span class="pre">Car</span></tt> del tipo <tt class="docutils literal"><span class="pre">(Show</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">Car</span>
<span class="pre">String</span> <span class="pre">String</span> <span class="pre">a</span></tt>. Podemos ver como la definición de tipo es mucho más
complicada y el único beneficio que hemos obtenido es que podamos usar
cualquier tipo que sea una instancia de la clase de tipos <tt class="docutils literal"><span class="pre">Show</span></tt> como
parámetro <tt class="docutils literal"><span class="pre">c</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in </span><span class="se">\&quot;</span><span class="s">nineteen sixty seven</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<img alt="Suricato" class="align-right" src="../_images/meekrat.png" />
<p>A la hora de la verdad, acabaríamos utilizando <tt class="docutils literal"><span class="pre">Car</span> <span class="pre">String</span> <span class="pre">String</span> <span class="pre">Int</span></tt> la
mayor parte del tiempo y nos daríamos cuenta de que parametrizar el tipo
<tt class="docutils literal"><span class="pre">Car</span></tt> realmente no importa. Normalmente utilizamos los parámetros de tipo
cuando el tipo que está contenido dentro del tipo de dato no es realmente
importante a la hora de trabajar con éste. Una lista de cosas es una lista
de cosas y no importa que sean esas cosas, funcionará igual. Si queremos sumar
una lista de números, mas tarde podemos especificar en la propia función de
suma de que queremos específicamente una lista de números. Lo mismo pasa con
<tt class="docutils literal"><span class="pre">Maybe</span></tt>. <tt class="docutils literal"><span class="pre">Maybe</span></tt> representa la opción de tener o no tener un valor.
Realmente no importa de que tipo sea ese valor.</p>
<p>Otro ejemplo de un tipo parametrizado que ya conocemos es el tipo <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></tt>
de <tt class="docutils literal"><span class="pre">Data.Map</span></tt>. <tt class="docutils literal"><span class="pre">k</span></tt> es el tipo para las claves del diccionario mientras que
<tt class="docutils literal"><span class="pre">v</span></tt> es el tipo de los valores. Este es un buen ejemplo en donde los
parámetros de tipo son útiles. Al tener los diccionarios parametrizados nos
permiten asociar cualquier tipo con cualquier otro tipo, siempre que la clave
del tipo sea de la clase de tipos <tt class="docutils literal"><span class="pre">Ord</span></tt>. Si estuviéramos definiendo el tipo
diccionario podríamos añadir una restricción de clase en la definición:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
<p>Sin embargo, existe un consenso en el mundo Haskell de que <strong>nunca debemos
añadir restricciones de clase a las definiciones de tipo</strong>. ¿Por qué? Bueno,
porque no nos beneficia mucho, pero al final acabamos escribiendo más
restricciones de clase, incluso aunque no las necesitemos. Si ponemos o no
podemos la restricción de clase <tt class="docutils literal"><span class="pre">Ord</span> <span class="pre">k</span></tt> en la definición de tipo de <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span>
<span class="pre">v</span></tt>, tendremos que poner de todas formas la restricción de clase en las
funciones que asuman que las claves son ordenables. Pero si no ponemos la
restricción en la definición de tipo, no tenemos que poner <tt class="docutils literal"><span class="pre">(Ord</span> <span class="pre">k)</span> <span class="pre">=&gt;</span></tt> en
la declaración de tipo de las funciones que no les importe si la clave puede
es ordenable o no. Un ejemplo de esto sería la función <tt class="docutils literal"><span class="pre">toList</span></tt> que
simplemente convierte un diccionario en una lista de asociación. Su
declaración de tipo es <tt class="docutils literal"><span class="pre">toList</span> <span class="pre">::</span> <span class="pre">Map</span> <span class="pre">k</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">a)]</span></tt>. Si <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></tt>
tuviera una restricción en su declaración, el tipo de <tt class="docutils literal"><span class="pre">toList</span></tt> debería haber
sido <tt class="docutils literal"><span class="pre">toList</span> <span class="pre">::</span> <span class="pre">(Ord</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">Map</span> <span class="pre">k</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[(k,</span> <span class="pre">a)]</span></tt> aunque la función no
necesite comparar ninguna clave.</p>
<p>Así que no pongas restricciones de clase en las declaraciones de tipos aunque
tenga sentido, ya que al final las vas a tener que poner de todas formas en
las declaraciones de tipo de las funciones.</p>
<p>Vamos a implementar un tipo para vectores 3D y crear algunas operaciones con
ellos. Vamos a usar un tipo parametrizado ya que, aunque normalmente contendrá
números, queremos que soporte varios tipos de ellos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">vplus</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>

<span class="nf">vectMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>

<span class="nf">scalarMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">n</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">vplus</span></tt> sirve para sumar dos vectores. Los vectores son sumados simplemente
sumando sus correspondientes componentes. <tt class="docutils literal"><span class="pre">scalarMult</span></tt> calcula el producto
escalar de dos vectores y <tt class="docutils literal"><span class="pre">vectMult</span></tt> calcula el producto de un vector y un
escalar. Estas funciones pueden operar con tipos como <tt class="docutils literal"><span class="pre">Vector</span> <span class="pre">Int</span></tt>,
<tt class="docutils literal"><span class="pre">Vector</span> <span class="pre">Integer</span></tt>, <tt class="docutils literal"><span class="pre">Vector</span> <span class="pre">Float</span></tt> o cualquier otra cosa mientras <tt class="docutils literal"><span class="pre">a</span></tt> de
<tt class="docutils literal"><span class="pre">Vector</span> <span class="pre">a</span></tt> sea miembro de clase de tipos <tt class="docutils literal"><span class="pre">Num</span></tt>. También, si miras la
declaración de tipo de estas funciones, veras que solo pueden operar con
vectores del mismo tipo y los números involucrados (como en <tt class="docutils literal"><span class="pre">vectMult</span></tt>)
también deben ser del mismo tipo que el que contengan los vectores. Fíjate en
que no hemos puesto una restricción de clase <tt class="docutils literal"><span class="pre">Num</span></tt> en la declaración del
tipo <tt class="docutils literal"><span class="pre">Vector</span></tt>, ya que deberíamos haberlo repetido también en las
declaraciones de las funciones.</p>
<p>Una vez más, es muy importante distinguir entre constructores de datos y
constructores de tipo. Cuando declaramos un tipo de dato, la parte anterior al
<tt class="docutils literal"><span class="pre">=</span></tt> es el constructor de tipo, mientras que la parte que va después
(posiblemente separado por <tt class="docutils literal"><span class="pre">|</span></tt>) son los constructores de datos. Dar a una
función el tipo <tt class="docutils literal"><span class="pre">Vector</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">Vector</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">t</span></tt> sería incorrecto ya que
hemos usado tipos en la declaración y el constructor de tipo vector toma un
solo parámetro, mientras que el constructor de datos toma tres. Vamos a jugar
un poco con los vectores:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">7</span> <span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">9</span> <span class="mi">19</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">7</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="mi">10</span>
<span class="kt">Vector</span> <span class="mi">30</span> <span class="mi">90</span> <span class="mi">70</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mf">9.0</span> <span class="mf">2.0</span> <span class="mf">4.0</span>
<span class="mf">74.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">2</span> <span class="mi">9</span> <span class="mi">3</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Vector</span> <span class="mi">148</span> <span class="mi">666</span> <span class="mi">222</span>
</pre></div>
</div>
</div>
<div class="section" id="instancias-derivadas">
<h2>Instancias derivadas<a class="headerlink" href="#instancias-derivadas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Gob" class="align-right" src="../_images/gob.png" />
<p>En la sección <a class="reference internal" href="Tipos.html#clases-de-tipo-1"><em>Clases de tipos paso a paso (1ª parte)</em></a>, explicamos las bases de las clases de
tipo. Dijimos que una clase de tipos es una especie de interfaz que define un
comportamiento. Un tipo puede ser una <strong>instancia</strong> de esa clase si soporta
ese comportamiento. Ejemplo: El tipo <tt class="docutils literal"><span class="pre">Int</span></tt> es una instancia de la clase
<tt class="docutils literal"><span class="pre">Eq</span></tt>, ya que la clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt> define el comportamiento de cosas que
se pueden equiparar. Y como los enteros se pueden equiparar, <tt class="docutils literal"><span class="pre">Int</span></tt> es parte
de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt>. La utilidad real está en las funciones que actúan como
interfaz de <tt class="docutils literal"><span class="pre">Eq</span></tt>, que son <tt class="docutils literal"><span class="pre">==</span></tt> y <tt class="docutils literal"><span class="pre">/=</span></tt>. Si un tipo forma parte de la
clase <tt class="docutils literal"><span class="pre">Eq</span></tt>, podemos usar las funciones como <tt class="docutils literal"><span class="pre">==</span></tt> con valores de ese tipo.
Por este motivo, expresiones como <tt class="docutils literal"><span class="pre">4</span> <span class="pre">==</span> <span class="pre">4</span></tt> y <tt class="docutils literal"><span class="pre">&quot;foo&quot;</span> <span class="pre">/=</span> <span class="pre">&quot;bar&quot;</span></tt> son
correctas.</p>
<p>Mencionamos también que las clases de tipos suelen ser confundidas con las
clases de lenguajes como Java, Python, C++ y demás, cosa que más tarde
desconcierta a la gente. En estos lenguajes, las clases son como un modelo del
cual podemos crear objetos que contienen un estado y pueden hacer realizar
algunas acciones. Las clases de tipos son más bien como las interfaces. No
creamos instancias a partir de las interfaces. En su lugar, primero creamos
nuestro tipo de dato y luego pensamos como qué puede comportarse. Si puede
comportarse como algo que puede ser equiparado, hacemos que sea miembro de la
clase <tt class="docutils literal"><span class="pre">Eq</span></tt>. Si puede ser puesto en algún orden, hacemos que sea miembro de
la clase <tt class="docutils literal"><span class="pre">Ord</span></tt>.</p>
<p>Más adelante veremos como podemos hacer manualmente que nuestros
tipos sean una instancia de una clase de tipos implementando las funciones
que esta define. Pero ahora, vamos a ver como Haskell puede automáticamente
hacer que nuestros tipos pertenezcan a una de las siguientes clases: <tt class="docutils literal"><span class="pre">Eq</span></tt>,
<tt class="docutils literal"><span class="pre">Ord</span></tt>, <tt class="docutils literal"><span class="pre">Enum</span></tt>, <tt class="docutils literal"><span class="pre">Bounded</span></tt>, <tt class="docutils literal"><span class="pre">Show</span></tt> y <tt class="docutils literal"><span class="pre">Read</span></tt>. Haskell puede derivar
el comportamiento de nuestros tipos en estos contextos si usamos la palabra
clave <tt class="docutils literal"><span class="pre">deriving</span></tt> cuando los definimos.</p>
<p>Considera el siguiente tipo de dato:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span>
</pre></div>
</div>
<p>Describe a una persona. Vamos a asumir que ninguna persona tiene la misma
combinación de nombre, apellido y edad. Ahora, si tenemos registradas a dos
personas ¿Tiene sentido saber si estos dos registros pertenecen a la misma
persona? Parece que sí. Podemos compararlos por igualdad y ver si son iguales
o no. Por esta razón tiene sentido que este tipo se miembro de la clase de
tipo <tt class="docutils literal"><span class="pre">Eq</span></tt>. Derivamos la instancia:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando derivamos una instancia de <tt class="docutils literal"><span class="pre">Eq</span></tt> para un tipo y luego intentamos
comparar dos valores de ese tipo usando <tt class="docutils literal"><span class="pre">==</span></tt> o <tt class="docutils literal"><span class="pre">/=</span></tt>, Haskell comprobará
si los constructores de tipo coinciden (aunque aquí solo hay un constructor
de tipo) y luego comprobará si todos los campos de ese constructor coinciden
utilizando el operador <tt class="docutils literal"><span class="pre">=</span></tt> para cada par de campos. Solo tenemos que tener
en cuenta una cosa, todos los campos del tipo deben ser también miembros de la
clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt>. Como <tt class="docutils literal"><span class="pre">String</span></tt> y <tt class="docutils literal"><span class="pre">Int</span></tt> ya son miembros, no hay ningún
problema. Vamos a comprobar nuestra instancia <tt class="docutils literal"><span class="pre">Eq</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adRock</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Horovitz&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">41</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mca</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Yauch&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">44</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mca</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Como ahora <tt class="docutils literal"><span class="pre">Person</span></tt> forma parte de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt>, podemos utilizarlo como
<tt class="docutils literal"><span class="pre">a</span></tt> en las funciones que tengan una restricción de clase del tipo <tt class="docutils literal"><span class="pre">Eq</span> <span class="pre">a</span></tt>
en su declaración, como <tt class="docutils literal"><span class="pre">elem</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">beastieBoys</span> <span class="ow">=</span> <span class="p">[</span><span class="n">mca</span><span class="p">,</span> <span class="n">adRock</span><span class="p">,</span> <span class="n">mikeD</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">beastieBoys</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>Las clases de tipos <tt class="docutils literal"><span class="pre">Show</span></tt> y <tt class="docutils literal"><span class="pre">Read</span></tt> son para cosas que pueden ser
convertidas a o desde cadenas, respectivamente. Como pasaba con <tt class="docutils literal"><span class="pre">Eq</span></tt>, si un
constructor de tipo tiene campos, su tipo debe ser miembro de la clase`
<tt class="docutils literal"><span class="pre">Show</span></tt> o <tt class="docutils literal"><span class="pre">Read</span></tt> si queremos que también forme parte de estas clases.</p>
<p>Vamos a hacer que nuestro tipo de dato <tt class="docutils literal"><span class="pre">Person</span></tt> forme parte también de las
clases <tt class="docutils literal"><span class="pre">Show</span></tt> y <tt class="docutils literal"><span class="pre">Read</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</pre></div>
</div>
<p>Ahora podemos mostrar una persona por la terminal.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;mikeD is: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">mikeD</span>
<span class="s">&quot;mikeD is: Person {firstName = </span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName = </span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span>
</pre></div>
</div>
<p>Si hubiésemos intentado mostrar en la terminal una persona antes de hacer que
el tipo <tt class="docutils literal"><span class="pre">Person</span></tt> formara parte de la clase <tt class="docutils literal"><span class="pre">Show</span></tt>, Haskell se hubiera
quejado, diciéndonos que no sabe como representar una persona con una cadena.
Pero ahora que hemos derivado la clase <tt class="docutils literal"><span class="pre">Show</span></tt> ya sabe como hacerlo.</p>
<p><tt class="docutils literal"><span class="pre">Read</span></tt> es prácticamente la clase inversa de <tt class="docutils literal"><span class="pre">Show</span></tt>. <tt class="docutils literal"><span class="pre">Show</span></tt> sirve para
convertir nuestro tipo a una cadena, <tt class="docutils literal"><span class="pre">Read</span></tt> sirve para convertir una cadena
a nuestro tipo. Aunque recuerda que cuando uses la función <tt class="docutils literal"><span class="pre">read</span></tt> hay que
utilizar una anotación de tipo explícita para decirle a Haskell que tipo
queremos como resultado. Si no ponemos el tipo que queremos como resultado
explícitamente, Haskell no sabrá que tipo queremos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
</pre></div>
</div>
<p>No hace falta utilizar una anotación de tipo explícita en caso de que usemos
el resultado de la función <tt class="docutils literal"><span class="pre">read</span></tt> de forma que Haskell pueda inferir el
tipo.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>También podemos leer tipos parametrizados, pero tenemos que especificar todos
los parámetros del tipo. Así que no podemos hacer
<tt class="docutils literal"><span class="pre">read</span> <span class="pre">&quot;Just</span> <span class="pre">'t'&quot;</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">a</span></tt>  pero si podemos hacer <tt class="docutils literal"><span class="pre">read</span> <span class="pre">&quot;Just</span> <span class="pre">'t'&quot;</span> <span class="pre">::</span>
<span class="pre">Maybe</span> <span class="pre">Char</span></tt>.</p>
<p>Podemos derivar instancias para la clase de tipos <tt class="docutils literal"><span class="pre">Ord</span></tt>, la cual es para
tipos cuyos valores puedan ser ordenados. Si comparamos dos valores del mismo
tipo que fueron definidos usando diferentes constructores, el valor cuyo
constructor fuera definido primero es considerado menor que el otro. Por
ejemplo, el tipo <tt class="docutils literal"><span class="pre">Bool</span></tt> puede tener valores <tt class="xref docutils literal"><span class="pre">False</span></tt> o <tt class="xref docutils literal"><span class="pre">True</span></tt>. Con el
objetivo de ver como se comporta cuando es comparado, podemos pensar que está
implementado de esta forma:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Como el valor <tt class="xref docutils literal"><span class="pre">False</span></tt> está definido primero y el valor <tt class="xref docutils literal"><span class="pre">True</span></tt> está
definido después, podemos considerar que <tt class="xref docutils literal"><span class="pre">True</span></tt> es mayor que <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
<blockquote>
ghci&gt; True <cite>compare</cite> False
GT
ghci&gt; True &gt; False
True
ghci&gt; True &lt; False
False</blockquote>
<p>En el tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>, el constructor de datos <tt class="docutils literal"><span class="pre">Nothing</span></tt> esta definido
antes que el constructor <tt class="docutils literal"><span class="pre">Just</span></tt>, así que un valor <tt class="docutils literal"><span class="pre">Nothing</span></tt> es siempre más
pequeño que cualquier valor <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">algo</span></tt>, incluso si ese algo es menos un
billon de trillones. Pero si comparamos dos valores <tt class="docutils literal"><span class="pre">Just</span></tt>, entonces se
compara lo que hay dentro de él.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;</span> <span class="kt">Just</span> <span class="mi">100</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">49999</span><span class="p">)</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">GT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">100</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">50</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>No podemos hacer algo como <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(*3)</span> <span class="pre">&gt;</span> <span class="pre">Just</span> <span class="pre">(*2)</span></tt>, ya que <tt class="docutils literal"><span class="pre">(*3)</span></tt> y
<tt class="docutils literal"><span class="pre">(*2)</span></tt> son funciones, las cuales no tienen definida una instancia de
<tt class="docutils literal"><span class="pre">Ord</span></tt>.</p>
<p>Podemos usar fácilmente los tipos de dato algebraicos para crear
enumeraciones, y las clases de tipos <tt class="docutils literal"><span class="pre">Enum</span></tt> y <tt class="docutils literal"><span class="pre">Bounded</span></tt> nos ayudarán a
ello. Considera el siguiente tipo de dato:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div>
</div>
<p>Como ningún contructor de datos tiene parámetros, podemos hacerlo miembro de
la clase de tipos <tt class="docutils literal"><span class="pre">Enum</span></tt>. La clase <tt class="docutils literal"><span class="pre">Enum</span></tt> son para cosas que tinen un
predecesor y sucesor. Tambien podemos hacerlo miembro de la clase de tipos
<tt class="docutils literal"><span class="pre">Bounded</span></tt>, que es para cosas que tengan un valor mínimo posible y valor
máximo posible. Ya que nos ponemos, vamos a hacer que este tipo tenga una
instancia para todas las clases de tipos derivables que hemos visto y veremos
que podemos hacer con él.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">,</span> <span class="kt">Enum</span><span class="p">)</span>
</pre></div>
</div>
<p>Como es parte de las clases de tipos <tt class="docutils literal"><span class="pre">Show</span></tt> y <tt class="docutils literal"><span class="pre">Read</span></tt>, podemos convertir
valores de est tipo a y desde cadenas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Wednesday</span>
<span class="kt">Wednesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Wednesday</span>
<span class="s">&quot;Wednesday&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Saturday&quot;</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Saturday</span>
</pre></div>
</div>
<p>Como es parte de las clases de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt> y <tt class="docutils literal"><span class="pre">Ord</span></tt>, podemos comparar o
equiparar días.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Sunday</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Saturday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">&gt;</span> <span class="kt">Friday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Monday</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Wednesday</span>
<span class="kt">LT</span>
</pre></div>
</div>
<p>También forma parte de <tt class="docutils literal"><span class="pre">Bounded</span></tt>, así que podemos obtener el día mas bajo
o el día más alto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Monday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Sunday</span>
</pre></div>
</div>
<p>También es una instancia de la clase <tt class="docutils literal"><span class="pre">Enum</span></tt>. Podemos obtener el predecesor
y el sucesor de un día e incluso podemos crear listas de rangos con ellos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="kt">Monday</span>
<span class="kt">Tuesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="kt">Saturday</span>
<span class="kt">Friday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Thursday</span> <span class="o">..</span> <span class="kt">Sunday</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">minBound</span> <span class="o">..</span> <span class="n">maxBound</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Day</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Monday</span><span class="p">,</span><span class="kt">Tuesday</span><span class="p">,</span><span class="kt">Wednesday</span><span class="p">,</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
</pre></div>
</div>
<p>Bastante impresionante.</p>
</div>
<div class="section" id="sinonimos-de-tipo">
<span id="sinonimos"></span><h2>Sinónimos de tipo<a class="headerlink" href="#sinonimos-de-tipo" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Anteriormente mencionamos que los tipos <tt class="docutils literal"><span class="pre">[Char]</span></tt> y <tt class="docutils literal"><span class="pre">String</span></tt> eran
equivalentes e intercambiables. Esto está implementado con los <strong>sinónimos de
tipo</strong>. Los sinónimos de tipo no hacen nada por si solo, simplemente dan a
algún tipo un nombre diferente, de forma que obtenga algún significado para
alguien que está leyendo nuestro código o documentación. Aquí tienes como
define la librería estándar <tt class="docutils literal"><span class="pre">String</span></tt> como sinónimo de <tt class="docutils literal"><span class="pre">[Char]</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">String</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div>
</div>
<img alt="Gallina" class="align-left" src="../_images/chicken.png" />
<p>Acabamos de intrudir la palabra clave <tt class="docutils literal"><span class="pre">type</span></tt>. Esta palabra clave podría
inducir a errores a algunos, ya que en realidad no estamos haciendo haciendo
nada nuevo (lo hacemos con la palabra clave <tt class="docutils literal"><span class="pre">data</span></tt>). Simplemente estamos
dando un sinónimos a un tipo que ya existe.</p>
<p>Si hacemos una función que convierta una cadena a mayúscuals y la llamamos
<tt class="docutils literal"><span class="pre">toUpperString</span></tt> o algo parecido, podemos darle una declaración de tipo como
<tt class="docutils literal"><span class="pre">toUpperString</span> <span class="pre">::</span> <span class="pre">[Char]</span> <span class="pre">-&gt;</span> <span class="pre">[Char]</span></tt> o <tt class="docutils literal"><span class="pre">toUpperString</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span></tt>.
Ambas son esecialmente lo mismo, solo que la última es más legible.</p>
<p>Cuando estabamos hablando del módulo <tt class="docutils literal"><span class="pre">Data.Map</span></tt>, primero presentamos una
agenda de teléfonos representada con una lista de asociación para luego
convertirla en un diccionario. Como ya sabemos, una lista de asociación no
es más que una lista de duplas clave-valor. Vamos a volver a ver la lista que
teníamos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">phoneBook</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
<span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Vemos que el tipo de <tt class="docutils literal"><span class="pre">phoneBook</span></tt> es <tt class="docutils literal"><span class="pre">[(String,String)]</span></tt>. Esto nos dice que
es una lista de asociación que asocia cadenas con cadena, pero nada más. Vamos
a crear un sinónimo de tipo para transmitir algo más de información en la
declaración de tipo.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
</pre></div>
</div>
<p>Ahora la declaración de tipo de nuestra función <tt class="docutils literal"><span class="pre">phoneBook</span></tt> sería
<tt class="docutils literal"><span class="pre">phoneBook</span> <span class="pre">::</span> <span class="pre">PhoneBook</span></tt>. Vamos a hacer un sinónimo de tipo para las cadenas
también.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">PhoneNumber</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Name</span><span class="p">,</span><span class="kt">PhoneNumber</span><span class="p">)]</span>
</pre></div>
</div>
<p>Dar un sinónimo al tipo <tt class="docutils literal"><span class="pre">String</span></tt> es algo que suelen hacer los programadores
de Haskell cuando quieren transmitir algo más de información acerca del
cometido de las cadenas en sus funciones y que representan.</p>
<p>Así que ahora, cuando implementemos una función que tome el nombre y el número
de teléfono y busque si esa combinación está en nuestra agenda telefónica,
podremos darle una declaración de tipo muy descriptiva:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">inPhoneBook</span> <span class="ow">::</span> <span class="kt">Name</span> <span class="ow">-&gt;</span> <span class="kt">PhoneNumber</span> <span class="ow">-&gt;</span> <span class="kt">PhoneBook</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">inPhoneBook</span> <span class="n">name</span> <span class="n">pnumber</span> <span class="n">pbook</span> <span class="ow">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pnumber</span><span class="p">)</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">pbook</span>
</pre></div>
</div>
<p>Si decidimo no utilizar sinónimos de tipo, nuestra función tendría la
declaración de tipo <tt class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">[(String,String)]</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>. En
este caso, la declaración de tipo que utiliza los sinónimos de tipo es mucho
más clara y fácil de entender. Sin embargo, no debes abusar de ellos.
Utilizamos los sinónimos de tipo o bien para indicar que representa un tipo
que ya existe en nuestras funciones (y de esta forma nuestras delcaraciones
de tipo se convierten en la mejor documentación) o bien cuando algo tiene
un tipo muy largo que se repite mucho (como <tt class="docutils literal"><span class="pre">[(String,String)]</span></tt>) y tiene
un significado concreto para nosotros.</p>
<p>Los sinónimos de tipo también pueden ser parametrizados. Si queremos un tipo
que represente las listas de asociación pero también queremos que sea lo
suficientemente general como para utilizar cualquier tipo de clave y valor,
podemos utilizar esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">AssocList</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span>
</pre></div>
</div>
<p>Con esto, una función que tomara un valor por clave en una lista de
asociación puede tener el tipo <tt class="docutils literal"><span class="pre">(Eq</span> <span class="pre">k)</span> <span class="pre">=&gt;</span> <span class="pre">k</span> <span class="pre">-&gt;</span> <span class="pre">AssocList</span> <span class="pre">k</span> <span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">v</span></tt>.
<tt class="docutils literal"><span class="pre">AssocList</span></tt> es un constructor de tipo que toma dos tipos y produce un tipo
concreto, como <tt class="docutils literal"><span class="pre">AssocList</span> <span class="pre">Int</span> <span class="pre">String</span></tt> por ejemplo.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Cuando hablamos de tipos concretos nos referimos a tipos
completamente aplicados, como <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">Int</span> <span class="pre">String</span></tt>. A veces, los
chicos y yo decimos que <tt class="docutils literal"><span class="pre">Maybe</span></tt> es un tipo, pero no queremos
referirnos a eso, ya que cualquier idiota sabe que <tt class="docutils literal"><span class="pre">Maybe</span></tt> es un
constructor de tipo. Cuando aplico un tipo extra a <tt class="docutils literal"><span class="pre">Maybe</span></tt>, como
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></tt>, entonces tengo un tipo concreto. Ya sabes, los
valores solo pueden tener tipos que sean tipos concretos.
Concluyendo, vive rápido, quiere mucho y no dejes que nadie te
tome el pelo.</p>
</div>
<p>De la misma forma que podemos aplicar parcialmente funciones para obtener
nuevas funciones, podemos aplicar parcialmente los parámetros de tipo y
obtener nuevos constructores de tipo. De la misma forma que llamamos a la
funciones con parámetros de menos para obtener nuevas funciones, podemos
especificar un constructor de tipo con parámetros de menos y obtener un
constructor de tipo parcialmente aplicado. Si queremos un tipo que represente
un diccionario (de <tt class="docutils literal"><span class="pre">Data.Map</span></tt>) que asocie enteros con cualquier otra cosa,
podemos utilizar esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">IntMap</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span> <span class="n">v</span>
</pre></div>
</div>
<p>O bien esto otro:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">IntMap</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>De cualquier forma, el constructor de tipo <tt class="docutils literal"><span class="pre">IntMap</span></tt> tomará un parámetro
y ese será el tipo con el que se asociarán los enteros.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si vas a intentar implementar esto, seguramente imporatarás de forma
cualificada el módulo <tt class="docutils literal"><span class="pre">Data.Map</span></tt>. Cuando realizas una importación
cualificada, los constructores de tipo también deben estar
precedidos con el nombre del módulo. Así que tienes que escribir
algo como <tt class="docutils literal"><span class="pre">type</span> <span class="pre">IntMap</span> <span class="pre">=</span> <span class="pre">Map.Map</span> <span class="pre">Int</span></tt>.</p>
</div>
<p>Asegurate de que realmente entiendes la diferencia entre constructores de
tipos y constructores de datos. Solo porque hayamos creado un sinónimo llamado
<tt class="docutils literal"><span class="pre">IntMap</span></tt> o <tt class="docutils literal"><span class="pre">AssocList</span></tt> no significa que podamos hacer cosas como
<tt class="docutils literal"><span class="pre">AssocList</span> <span class="pre">[(1,2),(4,5),(7,9)]</span></tt>. Lo único que significa es que podemos
referirnos a ese tipo usando nombres diferentes. Podemos hacer
<tt class="docutils literal"><span class="pre">[(1,2),(3,5),(8,9)]</span> <span class="pre">::</span> <span class="pre">AssocList</span> <span class="pre">Int</span> <span class="pre">Int</span></tt>, lo cual hará que los número de
adentro asuman el tipo <tt class="docutils literal"><span class="pre">Int</span></tt>, pero podemos seguir usando esta lista como
si fuera una lista que albergara duplas de enteros. Lo sinónimos de tipo
(y los tipos en general) solo pueden ser utlizados en la porción de Haskell
dedicada a los tipos. Estaremos en esta porción de Haskell cuando estemos
definiendo tipos nuevos (tanto en las declaraciones <tt class="docutils literal"><span class="pre">data</span></tt> como en las de
<tt class="docutils literal"><span class="pre">type</span></tt>) o cuando nos situemos después de un <tt class="docutils literal"><span class="pre">::</span></tt>. <tt class="docutils literal"><span class="pre">::</span></tt> se utiliza
solo para las declaraciones o anotaciones de tipo.</p>
<p>Otro tipo de dato interesante que toma dos tipos como parámetro es el tipo
<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>. Así es como se define más o menos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Tiene dos constructores de datos. Si se utiliza <tt class="docutils literal"><span class="pre">Left</span></tt>, entonces contiene
datos del tipo <tt class="docutils literal"><span class="pre">a</span></tt> y si se utiliza <tt class="docutils literal"><span class="pre">Right</span></tt> contiene datos del tipo <tt class="docutils literal"><span class="pre">b</span></tt>.
Podemos utilizar este tipo para encapsular un valor de un tipo u otro y así
obtener un valor del tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>. Normalmente utilizaremos un
ajuste de patrones con ambos, <tt class="docutils literal"><span class="pre">Left</span></tt> y <tt class="docutils literal"><span class="pre">Right</span></tt>, y nos diferenciaremos
según sea uno u otro.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Right</span> <span class="mi">20</span>
<span class="kt">Right</span> <span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Right</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">Right</span> <span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="n">a</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Left</span> <span class="kt">True</span>
<span class="kt">Left</span> <span class="kt">True</span> <span class="ow">::</span> <span class="kt">Either</span> <span class="kt">Bool</span> <span class="n">b</span>
</pre></div>
</div>
<p>Hasta ahora hemos visto que <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> es utilizado para representar
resultados de cálculos que podrían haber fallado o no. Pero a veces,
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> no es suficientemente bueno ya que <tt class="docutils literal"><span class="pre">Nothing</span></tt> únicamente nos
informa de que algo ha fallado. Esto esta bien para funciones que solo pueden
fallar de una forma o si no nos interesa saber porque y como han fallado.
Una búqueda en un <tt class="docutils literal"><span class="pre">Data.Map</span></tt> solo falla cuando la clave que estamos buscando
no se encuentra en el diccionario, así que sabemos exacmente que ha pasado.
Sin embargo, cuando estamos interesados en el cómo o el porqué a fallado algo,
solemos utilizar como resultado el tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>, donde <tt class="docutils literal"><span class="pre">a</span></tt> es alguna
especie de tipo que pueda decirnos algo sobre un posible fallo, y <tt class="docutils literal"><span class="pre">b</span></tt> es
el tipo de un cálculo satisfactorio. Por lo tanto, los errores usan el
constructor de datos <tt class="docutils literal"><span class="pre">Left</span></tt> mientras que los resultado usan <tt class="docutils literal"><span class="pre">Right</span></tt>.</p>
<p>Un ejemplo: un instituto posee taquillas para que sus estudiantes tengan un
lugar donde guardar sus posters de <em>Guns&#8217;n&#8217;Roses</em>. Cada taquilla tiene una
combinación. Cuando un estudiante quiere una taquilla nueva, le dice al
supervisor de las taquillas que número de taquilla quiere y él le da un
código para esa taquilla. Sin embargo, si alguien ya está usando la taquilla,
no le puede decir el código y tienen que elegir una taquilla diferente.
Utilizaremos un diccionario de <tt class="docutils literal"><span class="pre">Data.Map</span></tt> para representar las taquillas.
Asociará el número de la taquilla con duplas que contengan si la taquilla está
en uso o no y el código de la taquilla.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>

<span class="kr">data</span> <span class="kt">LockerState</span> <span class="ow">=</span> <span class="kt">Taken</span> <span class="o">|</span> <span class="kt">Free</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Code</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">type</span> <span class="kt">LockerMap</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">LockerState</span><span class="p">,</span> <span class="kt">Code</span><span class="p">)</span>
</pre></div>
</div>
<p>Bastante simple. Hemo creado un nuevo tipo de dato para representar si una
taquilla está libre o no, y hemos creado un sinónimo para representar el
código de una taquilla. También creado otro sinónimo para el tipo que asocia
los los números de las taquillas con las duplas de estado y código. Ahora,
vamos a hacer una función que busque un número de taquilla en el diccionario.
Vamos a usar el tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">String</span> <span class="pre">Code</span></tt> para representar el resultado,
ya que nuestra búsqueda puede fallar de dos formas: la taquilla ya ha sido
tomada, en cuyo caso decimos quien la posee o si el no hay ninguna taquilla
con ese número. Si la búqueda falla, vamos a utilizar una cadena para obtener
el porqué.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">lockerLookup</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LockerMap</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Code</span>
<span class="nf">lockerLookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker number &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; doesn&#39;t exist!&quot;</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">state</span> <span class="o">/=</span> <span class="kt">Taken</span>
                                <span class="kr">then</span> <span class="kt">Right</span> <span class="n">code</span>
                                <span class="kr">else</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; is already taken!&quot;</span>
</pre></div>
</div>
<p>Hacemos una búsqueda normal en un diccionario. Si obtenemos <tt class="docutils literal"><span class="pre">Nothing</span></tt>,
devolvemos un valor con el tipo <tt class="docutils literal"><span class="pre">Left</span> <span class="pre">String</span></tt> que diga que esa taquilla no
existe. Si la encontramos, hacemos una comprobación adicional para ver si la
taquilla está libre. Si no lo está, devolvemos un <tt class="docutils literal"><span class="pre">Left</span></tt> diciendo que la
taquilla a sido tomada. Si lo está, devolvemos un valor del tipo <tt class="docutils literal"><span class="pre">Right</span>
<span class="pre">Code</span></tt>, el cual daremos al estudiante. En realidad es un <tt class="docutils literal"><span class="pre">Right</span> <span class="pre">String</span></tt>,
aunque hemos creado un sinónimo para añadir un poco más de información en
la declaración de tipo. Aquí tienes un diccionario de ejemplo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">lockers</span> <span class="ow">::</span> <span class="kt">LockerMap</span>
<span class="nf">lockers</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
    <span class="p">[(</span><span class="mi">100</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;ZD39I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">101</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;JAH3I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">103</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;IQSA9&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">105</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;QOTSA&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">109</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;893JJ&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">110</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;99292&quot;</span><span class="p">))</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Vamos a buscar el código de unas cuantas taquillas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">101</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;JAH3I&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">100</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 100 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">102</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker number 102 doesn&#39;t exist!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">110</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 110 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">105</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;QOTSA&quot;</span>
</pre></div>
</div>
<p>Podríamos haber utlizado el tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> para representar el resultado
pero entonces no sabríamos el motivo por el cual no podemos obtener el código.
Ahora, tenemos información acerca del fallo en nuestro tipo del resultado.</p>
</div>
<div class="section" id="estructuras-de-datos-recursivas">
<h2>Estructuras de datos recursivas<a class="headerlink" href="#estructuras-de-datos-recursivas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Hombre cool" class="align-left" src="../_images/thefonz.png" />
<p>Como ya hemos visto, un costructor de un tipo de dato algebraico puede tener
(o no tener) varios campos y cada uno de estos debe ser un tipo concreto.
Teniendo esto en cuenta, podemos crear tipos cuyos campos de constructor sean
el propio tipo. De esta forma, podemos crear estructuras de datos recursivas,
en el que un valor de un cierto tipo contenga valores de ese mismo tipo, el
cual seguirá conteniendo valores del mismo tipo y así sucesivamente.</p>
<p>Piensa en la lista <tt class="docutils literal"><span class="pre">[5]</span></tt>. Es lo mismo que <tt class="docutils literal"><span class="pre">5:[]</span></tt>. A la izquierda del <tt class="docutils literal"><span class="pre">:</span></tt>
hay un valore, y a la derecha hay una lista. En este caso, una lista vacía.
¿Qué pasaría con la lista <tt class="docutils literal"><span class="pre">[4,5]</span></tt>? Bueno, es lo mismo que <tt class="docutils literal"><span class="pre">4:(5:[])</span></tt>. Si
miramos el primer <tt class="docutils literal"><span class="pre">:</span></tt>, vemos que también tiene un elemento a su izquierda y
una lista a su derecha <tt class="docutils literal"><span class="pre">(5:[])</span></tt>.  Lo mismo sucede para la lista
<tt class="docutils literal"><span class="pre">3:(4:(5:6:[]))</span></tt>, que también podría escribirse como <tt class="docutils literal"><span class="pre">3:4:5:6:[]</span></tt> (ya que
<tt class="docutils literal"><span class="pre">:</span></tt> es asociativo por la derecha) o <tt class="docutils literal"><span class="pre">[3,4,5,6]</span></tt>.</p>
<p>Podemos decir que una lista es o bien una lista vacia o bien un elemento
unido con un <tt class="docutils literal"><span class="pre">:</span></tt> a otra lista (que puede ser una lista vacía o no).</p>
<p>¡Vamos a usar los tipod de datos algebraicos para implementar nuestra propia
lista!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Se lee de la misma forma que se leía nuestra definición de lista en un
párrafo anterior. Es o bien una lista vacía o bien una combinación de un
elemento y otra lista. Si estás confundido con esto, quizás te sea más fácil
entenderlo con la sintaxis de registro:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="p">{</span> <span class="n">listHead</span> <span class="ow">::</span> <span class="n">a</span><span class="p">,</span> <span class="n">listTail</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Puede que también estes confundido con el constructor <tt class="docutils literal"><span class="pre">Cons</span></tt>. <tt class="docutils literal"><span class="pre">Cons</span></tt> es
otra forma de decir <tt class="docutils literal"><span class="pre">:</span></tt>. En realidad, en las listas, <tt class="docutils literal"><span class="pre">:</span></tt> es un constructor
que toma un valor y otra lista y devuleve una lista. En otras palabras, tiene
dos campos. Uno es del tipo <tt class="docutils literal"><span class="pre">a</span></tt> y otro es del tipo <tt class="docutils literal"><span class="pre">[a]</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Empty</span>
<span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span>
<span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="kt">Cons</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
</pre></div>
</div>
<p>Si hubiésemos llamado a nuestro constructor de forma infija podrías ver mejor
como es simplemente <tt class="docutils literal"><span class="pre">:</span></tt>. <tt class="docutils literal"><span class="pre">Empty</span></tt> es como <tt class="docutils literal"><span class="pre">[]</span></tt> y <tt class="docutils literal"><span class="pre">4</span> <span class="pre">`Cons`</span> <span class="pre">(5</span> <span class="pre">`Cons`</span>
<span class="pre">Empty)</span></tt> es como <tt class="docutils literal"><span class="pre">4:(5:[])</span></tt>.</p>
<p>Podemos definir funciones que automáticamente sean infijas si las nombramos
únicamente con caracteres especiales. Podemos hacer lo mismo con los
constructores, ya que son simplemente funciones que devuelve un tipo de dato
concreto. Mira esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">infixr</span> <span class="mi">5</span> <span class="kt">:-:</span>
<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="n">a</span> <span class="kt">:-:</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>Antes de nada, vemos que hay una nueva construcción sintáctica, una
declaración infija. Cuando definimos funciones como operadores, podemos usar
esta cosntrucción para darles un determinado comportamiento (aunque no estamos
obligados a hacerlo). De esta forma definimos el orden de precedencia de un
operador y si asociativo por la izquierda o por la derecha. Por ejemplo, <tt class="docutils literal"><span class="pre">*</span></tt>
es <tt class="docutils literal"><span class="pre">infixl</span> <span class="pre">7</span> <span class="pre">*</span></tt> y <tt class="docutils literal"><span class="pre">+</span></tt> es <tt class="docutils literal"><span class="pre">infixl</span> <span class="pre">6</span> <span class="pre">+</span></tt>. Esto siginifica que ambos son
asociativos por la izquierda de forma que <tt class="docutils literal"><span class="pre">(4</span> <span class="pre">*</span> <span class="pre">3</span> <span class="pre">*</span> <span class="pre">2)</span></tt> es <tt class="docutils literal"><span class="pre">(4</span> <span class="pre">*</span> <span class="pre">3)</span> <span class="pre">*</span> <span class="pre">2)</span></tt>
pero <tt class="docutils literal"><span class="pre">*</span></tt> tiene un orden de precedencia mayor que <tt class="docutils literal"><span class="pre">+</span></tt>, por lo que
<tt class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">+</span> <span class="pre">3</span></tt> es equivalente a <tt class="docutils literal"><span class="pre">(5</span> <span class="pre">*</span> <span class="pre">4)</span> <span class="pre">+</span> <span class="pre">3</span></tt>.</p>
<p>De qualquier modo, al final acabamos escribiendo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">:-:</span> <span class="pre">(List</span> <span class="pre">a)</span></tt> en lugar
de `` Cons a (List a)``. Ahora podemos escribir las listas así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="kt">:-:</span> <span class="n">a</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">100</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)))</span>
</pre></div>
</div>
<p>Haskell serguirá mostrando el cosntructor como una función prefija cuando
derivemos <tt class="docutils literal"><span class="pre">Show</span></tt>, por este motivo aparecen los poréntesis alrededor del
constructor (recuerda que <tt class="docutils literal"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">3</span></tt> es igual que <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">4</span> <span class="pre">3</span></tt>).</p>
<p>Vamos a crear una función que una dos de nuestras listas. Así es como está
definida la función <tt class="docutils literal"><span class="pre">++</span></tt> para listas normales:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">++</span>
<span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">[]</span>     <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que copiamos esta definición y la aplicamos a nuestras listas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">.++</span>
<span class="p">(</span><span class="o">.++</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>
<span class="kt">Empty</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span> <span class="kt">:-:</span> <span class="n">xs</span><span class="p">)</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:-:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">.++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>
</div>
<p>Y así es como funciona:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">6</span> <span class="kt">:-:</span> <span class="mi">7</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">.++</span> <span class="n">b</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">6</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">7</span> <span class="kt">Empty</span><span class="p">))))</span>
</pre></div>
</div>
<p>Bien. Si te apetece puedes implementar todas las funciones que operan con
listas con nuestro tipo de listas.</p>
<p>Fíjate que hemos utilizado un ajuste de patrón <tt class="docutils literal"><span class="pre">(x</span> <span class="pre">:-:</span> <span class="pre">xs)</span></tt>. Esto función
ya que el ajuste de patrones en realidad funciona ajustando constructores.
Podemos ajustar un patrón <tt class="docutils literal"><span class="pre">:-:</span></tt> porque es un constructor de nuesto tipo de
la misma forma que <tt class="docutils literal"><span class="pre">:</span></tt> es un constructor de las listas estándar. Lo mismo
sucede para <tt class="docutils literal"><span class="pre">[]</span></tt>. Ya que el ajuste de patrones funciona (solo) con
constructores de datos, podemos ajustar patrones como los constructores
prefijos normales, constructores infijos o cosas como <tt class="docutils literal"><span class="pre">8</span></tt> o <tt class="docutils literal"><span class="pre">'a'</span></tt>, que
al fin y al cabo son constructores de tipos númericos y caracteres.</p>
<img alt="Árbol binario" class="align-left" src="../_images/binarytree.png" />
<p>Vamos a implementar un árbol binario de búsqueda. Si no estás familiarizado
con los árboles binarios de búsqueda de otros lenguajes como <em>C</em>, aquí tienes
una expliación de lo que son: un elemento apunta a otros dos elementeos, uno
esta a la izquierda y otro a la derecha. El elemento a la izquierda es más
pequeño y el segundo es más grande. Cada uno de estos dos elementos puede
apuntar a otros dos elementos (o a uno o a ninguno). En efecto, cada elemento
tienen sus propios sub-árboles. Lo bueno de los árboles binarios de búsqueda
es que sabemos que todos los elementos que están en el sub-árbol de la
iquierda de, 5, por ejemplo, son menores que 5. Lo elementos que están en el
sub-árbol de la derecha son mayores. Así que si estamos buscando el elemento
8 en nuestro árbol, emepezamos comparándolo con 5, como vemos que es menor que
5, nos vamos al sub-árbol de la derecha. Ahora estaríamos en 7, como es menor
que 8 continuaríamos hacia la derecha. De esta formá encontraríamos el
elemento en tres pasos. Si estuvieramos usando una lista (o un árbol no
balanceado), nos hubiera costado unos 7 pasos encontrar el 8.</p>
<p>Los conjuntos y diccionario de <tt class="docutils literal"><span class="pre">Data.Set</span></tt> y <tt class="docutils literal"><span class="pre">Data.Map</span></tt> están
implementandos utilizando árboles, solo que en lugar de árboles binarios
de búsqueda, utilizan árboles binarios de búsqueda balanceados, de forma que
estén siempre balanceados. Ahora implementaremos simplemente árboles binarios
de búsqueda normales.</p>
<p>Vamos a decir que: un árbol es o bien un árbol vacío o bien un elemento
que contiene un elemento y otros dos árboles. Tiene pinta de que va a encajar
perfectamente con los tipos de datos algebraicos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">EmptyTree</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>Vale. En lugar de construir manualmente un árbol, vamos a crear una función
que tome un elemento y un árbol e inserte dicho elemento en su posición
adecuada dentro del árbol. Hacemos esto comparando el elemento que queremos
insertar con la raíz del árbol y si es menor, vamos a la izquierda y si no
a la derecha. Hacemos lo mismo para coda nodo siguiente hasta que alcanzemos
un árbol vacío. Cuando lo hagamos simplemente insertamos el elmento en
lugar del árbol vacío.</p>
<p>En lenguajes como <em>C</em>, realizamos esta tarea modificando los punteros y
valores del árbol. En Haskell, no podemos modificar nuestro árboles, así que
tenemos que crear un nuevo sub-árbol cada vez que decidamos si vamos a la
derecha o a la izquierda y al final la función de inserción devolver un
árbol complentamente nuevo, ya que Haskell no tiene el concepto de puntero.
Así pues la declaración de tipo de nuestra función será alfgo como <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Tree</span> <span class="pre">a</span> <span class="pre">-</span> <span class="pre">&gt;</span> <span class="pre">Tree</span> <span class="pre">a</span></tt>. Toma un elemento y un árbol y devuelve un nuevo árbol que
posee en su interior dicho elemento. Puede parecer ineficienciente pero la
evaluación perezosa de Hasekell ya se encarga de ello.</p>
<p>Aqui tienes dos funciones. Una de ellas es una función auxiliar para crear un
árbol unitario (que solo contiene un elemento) y la otra es una función que
inserta elementos en un árbol.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span>

<span class="nf">treeInsert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="n">singleton</span> <span class="n">x</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">left</span><span class="p">)</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">singleton</span></tt> es forma rápida de crear un árbol que contenga un
elemento y dos sub-árboles vacios. En la función de inserción, tenemos como
primer patrón el caso base. Si hemos alcanzado un sub-árbol vacio, esto
significa que estamos donde queríamos y en lugar de un árbol vacío, queremos
un árbol unitario que contenga el elemento a insertar. Si no estamos
insertando el elemento en un árbol vacío tenemos que comprobar varias cosas.
Primero, si el elemento que vamos a insertar es el mismo que la raíz del
sub-árbol, simplemente devolvemos el árbol como estaba. Si es menor,
devolvemos un árbol que tenga la misma raíz, el mimso sub-árbol derecho pero
en lugar de su sub-árbol izquierdo, ponemos el árbol que va a contener dicho
elemento. Lo mismo ocurre (pero en sentido contrario) para los valores que
son mayores que el elemento raíz.</p>
<p>A continuación vamos a crear una función que compruebe si un elemento pertence
a un árbol. Primero vamos a definir el caso base. Si estamos buscando un
elemento en un árbol vacío, obviamente el elemento no está ahí. Vale, fíjate
que esto es básicamente lo mismo que el caso base de la búsqueda en listas: si
estamos buscando un elemento en una lista vacía, obviamente el elemento no
está ahí. De todos modos, si no estamos buscando el elemento en un árbol
vacío, entonces tenemos que hacer varias comprobaciones. Si el elemento que
estamos buscando es el elemento raíz ¡Genial! ¿Y si no lo es? Bueno, tenemos
la ventaja de que sabemos que todos los elementos menores que la raíz están
en el sub-árbol izquierdo. Así que si el elemento que estamos buscando es
menor que la raiz, comprobamos si el elemento está en el sub-árbol izquierdo.
Si es mayor, comprobamos el sub-árbol derecho.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">treeElem</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">left</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">right</span>
</pre></div>
</div>
<p>¡Vamos a divertirnos con nuestro árboles! En lugar de contruir manualmente un
árbol (aunque podríamos), usaremos un pliegue para construir un árbol a partir
de una lista. Recuerda, casi cualquier cosa que recorra una lista elemento a
elemento y devuelve alguna especie de valor puede ser implementado con un
pliegue. Empezaremos con un árbol vacío y luego recorreremos la lista desde
la derecha e iremos insertando elementos a nuestro árbol acumulador.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nums</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">numsTree</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="n">nums</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">numsTree</span>
<span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">7</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span>
</pre></div>
</div>
<p>En este <tt class="docutils literal"><span class="pre">foldr</span></tt>, <tt class="docutils literal"><span class="pre">treeInsert</span></tt> es la función de pliegue (toma un árbol y
un elemento de la lista y produce un nuevo árbol) y <tt class="docutils literal"><span class="pre">EmptyTree</span></tt> es el
valor inicial. Por supuesto, <tt class="docutils literal"><span class="pre">nums</span></tt> es la lista que estamos plegando.</p>
<p>No es muy legible el árbol que se muestra por la consola, pero si lo
intentamos, podemos descifrar su estructura. Vemos que el nodo raíz es 5 y
luego tiene dos sub-árboles, uno que tiene como elemento raíz a 3, y otro a 7.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">8</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>Vamos que comprobar la pertencia de un elemento a un árbol funciona
perfectamente. Genial.</p>
<p>Como puede ver los tipos de datos algebraicos en Hasekll son un concepto muy
intersante a la vez que pontentes. Podemos utilizarlos desde para representar
valores booleanos hasta enumeraciónes de los días de la semana, e incluso
árboles binarios de búsquedas.</p>
</div>
<div class="section" id="clases-de-tipos-paso-a-paso-2a-parte">
<h2>Clases de tipos paso a paso (2ª parte)<a class="headerlink" href="#clases-de-tipos-paso-a-paso-2a-parte" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Semáforo" class="align-right" src="../_images/trafficlight.png" />
<p>Hasta ahora hemos aprendido a utilizar algunas clases de tipos estándar de
Haskell y hemos visto que tipos son miembros de ellas. También hemos aprendido
a crear automáticamente instancias de nuestros tipos para las clases de tipos
estándar, pidiéndole a Haskell que las derive por nostros. En esta sección
vamos a ver como podemos crear nuestras propias clases de tipo y a como crear
instancias de tipos para ellas a mano.</p>
<p>Un pequeño recordatorio acerca de las clases de tipos: las clases de tipos
son como las interfaces. Una clase de tipos define un comportamiento (como
comparar por igualdad, comparar por orden, una enumeración, etc.) y luego
ciertos tipos pueden comportarse de forma a la instancia de esa clase de
tipos. El comportamiento de una clase de tipos se consigue definiendo
funciones o simplemente definiendo tipos que luego implementaremos. Así que
cuando digamos que un tipo es una instancia de un clase de tipos, estamos
diciendo que podemos usar las funciones de esa clase de tipos con ese tipo.</p>
<p>Las clases de tipos no tienen nada que ver con las clases de <em>Java</em> o
<em>Pyhton</em>. Esto suele confundir a mucha gente, así que me gustaría que
olvidaras ahora mismo todo lo que sabes sobre las clases en los lenguajes
imperativos.</p>
<p>Por ejemplo, la clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt> es para cosas que pueden ser
equiparadas. Define las funciones <tt class="docutils literal"><span class="pre">==</span></tt> y <tt class="docutils literal"><span class="pre">/=</span></tt>. Si tenemos un tipo
(digamos, <tt class="docutils literal"><span class="pre">Car</span></tt>) y el comparar dos coches con la función <tt class="docutils literal"><span class="pre">==</span></tt> tiene
sentido, entonces tiene sentido que <tt class="docutils literal"><span class="pre">Car</span></tt> sea una instancia de <tt class="docutils literal"><span class="pre">Eq</span></tt>.</p>
<p>Así es como está defina la clase <tt class="docutils literal"><span class="pre">Eq</span></tt> en <tt class="docutils literal"><span class="pre">Prelude</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>¡Alto, alto, atlo! ¡Hay mucha sintaxis y palabras raras ahí! No te preocupes,
estará todo claro en un segundo. Lo primero de todo, cuando escribimos
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></tt> significa que estamos definiendo una clase de tipos nueva
y que se va a llamar <tt class="docutils literal"><span class="pre">Eq</span></tt>. La <tt class="docutils literal"><span class="pre">a</span></tt> es la variable de tipo y significa que
<tt class="docutils literal"><span class="pre">a</span></tt> representará el tipo que dentro de poco hagamos instancia de <tt class="docutils literal"><span class="pre">Eq</span></tt>.
No tiene porque llamarse <tt class="docutils literal"><span class="pre">a</span></tt>, de hecho no tiene ni que ser de una sola
letra, solo debe ser una palabra en minúsculas. Luego definimos varias
funciones. No es obligatorio implementar los cuerpos de las funciones, solo
debemos especificar las declaraciones de tipo de las funciones.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Hay gente que entederá esto mejor si escribimos algo como
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">equiparable</span> <span class="pre">where</span></tt> y luego definimos el tipo de las
funciones como <tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">equiparable</span> <span class="pre">-&gt;</span> <span class="pre">equiparable</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>.</p>
</div>
<p>De todos modos, hemos implementado el cuerpo de las funciones que define
<tt class="docutils literal"><span class="pre">Eq</span></tt>, solo que las hemos implementado en terminos de recursión mutua.
Decimos que dos instancias de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt> son iguales si no son desiguales
y son desiguales y no son iguales. En realidad no teníamos porque haberlo
echo, pero pronto veremos de que forma nos ayuda.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si tenemos un <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></tt> y definimos una declaración
de tipo dentro de la clase como <tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">-a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>, luego,
cuando examinemos el tipo de esa función obtendremos
<tt class="docutils literal"><span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>.</p>
</div>
<p>Así que ya tenemos una clase ¿Qué podemos hacer con ella? Bueno, no mucho.
Pero una vez empezemos a declarar instancias para esa clase, empezaremos a
obtener algun funcionalidad útil. Mira este tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span>
</pre></div>
</div>
<p>Define los estados de un semáforo. Fijate que no hemos derivado ninguna
instancia, ya que vamos a escribirlas a mano, aunque podríamos haberlas
derivado para las clases <tt class="docutils literal"><span class="pre">Eq</span></tt> y <tt class="docutils literal"><span class="pre">Show</span></tt>. Aquí tienes como creamos la
instancia para la clase <tt class="docutils literal"><span class="pre">Eq</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Green</span> <span class="o">==</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Yellow</span> <span class="o">==</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Lo hicimos utilizando la palabra clave <tt class="docutils literal"><span class="pre">instance</span></tt>. Así que <tt class="docutils literal"><span class="pre">class</span></tt> es
para definir nuevas clases de tipos y <tt class="docutils literal"><span class="pre">instance</span></tt> para hacer que nuestros
tipos tengan una instancia para cierta clase de tipos. Cuando estabamos
definiendo <tt class="docutils literal"><span class="pre">Eq</span></tt> escribimos <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></tt> y dijimos que <tt class="docutils literal"><span class="pre">a</span></tt>
representaría el tipo que hiciéramos instancia después. Lo podemos ver
claramente ahora, ya que cuando estamos escribiendo una instancia, escribrimos
<tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">TrafficLight</span> <span class="pre">where</span></tt>. Hemo remplazado la <tt class="docutils literal"><span class="pre">a</span></tt> por el tipo
actual.</p>
<p>Como <tt class="docutils literal"><span class="pre">==</span></tt> fue definido en la definición de clase en términos de <tt class="docutils literal"><span class="pre">/=</span></tt> y
viceversa, solo tenemos que sobreescribir una de ellas en la delcaración de
instancia. A esto se le llama la definición completa mínima de una clase de
tipos, o dicho de otra forma, el mínimo número de funciones que tenemos que
implementar para que nuestro tipo pertenezca a una determinada clase de tipos.
Para rellenar la definición completa mínima de <tt class="docutils literal"><span class="pre">Eq</span></tt>, tenemos que
sobreescribir o bien <tt class="docutils literal"><span class="pre">==</span></tt> o <tt class="docutils literal"><span class="pre">/=</span></tt>. Si <tt class="docutils literal"><span class="pre">Eq</span></tt> hubiese sido definido como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Tendríamos que haber implementado ambas funciones a la hora de crear una
instancia, ya que Hasekell sabría como están relacionadas esas funciones.
De esta forma, la definición completa mínima serían ambas, <tt class="docutils literal"><span class="pre">==</span></tt> y <tt class="docutils literal"><span class="pre">/=</span></tt>.</p>
<p>Como has visto hemos implementado <tt class="docutils literal"><span class="pre">==</span></tt> usando ajuste de patrones. Como hay
muchos más casos donde dos semáforos no están en el mismo estado,
especificamos para cuales son iguales y luego utilizamos un patrón que se
ajuste a cualquier caso que no sea ninguno de los anteriores para decir que no
son iguales.</p>
<p>Vamos a crear también una instancia para <tt class="docutils literal"><span class="pre">Show</span></tt>. Para satisfacer la
definición completa mínima de <tt class="docutils literal"><span class="pre">Show</span></tt>, solo tenemos que implementar la
función <tt class="docutils literal"><span class="pre">show</span></tt>, la cual toma un valor y lo convierte a una cadena.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="s">&quot;Red light&quot;</span>
    <span class="n">show</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="s">&quot;Yellow light&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green light&quot;</span>
</pre></div>
</div>
<p>Una vez más hemos utilizado el ajuste de patrones para conseguir nuestros
objetivos. Vamos a verlo en acción:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Yellow</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span> <span class="n">light</span><span class="p">,</span><span class="kt">Yellow</span> <span class="n">light</span><span class="p">,</span><span class="kt">Green</span> <span class="n">light</span><span class="p">]</span>
</pre></div>
</div>
<p>Perfecto. Podríamos haber derivado <tt class="docutils literal"><span class="pre">Eq</span></tt> y hubiera tenido el mismo efecto.
Sin embargo, derivar <tt class="docutils literal"><span class="pre">Show</span></tt> hubiera representando directamente los
constructores como cadenas. Pero si queremos que las luces aparezcan
como <tt class="docutils literal"><span class="pre">&quot;Red</span> <span class="pre">light&quot;</span></tt> tenemos que crear esta instancia a mano.</p>
<p>También podemos crear clases de tipos que sean subclases de otras clases de
tipos. La declaración de la clase <tt class="docutils literal"><span class="pre">Num</span></tt> es un poco larga, pero aquí tienes
el principio:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>Como ya hemos mencionado anteriormente, hay un montón de sitios donde podemos
poner restriciones de clases. Esto es lo mismo que escribir <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Num</span> <span class="pre">a</span>
<span class="pre">where</span></tt>, solo que decimos que nuestro tipo <tt class="docutils literal"><span class="pre">a</span></tt> debe ser una instancia de
<tt class="docutils literal"><span class="pre">Eq</span></tt>. Basicamente decimos que hay que crear la instancia <tt class="docutils literal"><span class="pre">Eq</span></tt> de un tipo
antes de que éste forme parte forme parte de la clase <tt class="docutils literal"><span class="pre">Num</span></tt>. Antes de que un
tipo se pueda considerar un número, tiene sentido que podamos determinar si
los valores de un tipo puede sen equiparados o no. Esto es todo lo que hay que
saber de las subclases ya que simplemente son restriscciones de clase dentro
de la definición de una clase. Cuando definamos funciones en la declaración
de una clase o en la definición de una instancia, podemos asumir que <tt class="docutils literal"><span class="pre">a</span></tt> es
parte de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt> así que podemos usar <tt class="docutils literal"><span class="pre">==</span></tt> con los valores de ese
tipo.</p>
<p>¿Pero cómo son creadas las instancias del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> o de las listas? Lo
que hace diferente a <tt class="docutils literal"><span class="pre">Maybe</span></tt> de, digamos, <tt class="docutils literal"><span class="pre">TrafficLight</span></tt> es que <tt class="docutils literal"><span class="pre">Maybe</span></tt>
no es por si mismo un tipo concreto, es un constructor de tipo que toma un
parámetro (como <tt class="docutils literal"><span class="pre">Char</span></tt> o cualquier otra cosa) para producir un tipo
concreto. Vamos a echar un vistazo a la clase <tt class="docutils literal"><span class="pre">Eq</span></tt> de nuevo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>A partir de la declaración de tipo, podemos observar que <tt class="docutils literal"><span class="pre">a</span></tt> es utilizado
como un tipo concreto ya que todos los tipos que aparecer en una función deben
deben ser concretos (Recuerda, no puedes tener una función con el tipo
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span></tt> pero si una función <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">a</span></tt> o <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span>
<span class="pre">String</span></tt>). Por este motivo no podemos hacer cosas como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>Ya que como hemos visto, <tt class="docutils literal"><span class="pre">a</span></tt> debe ser un tipo concreto pero <tt class="docutils literal"><span class="pre">Maybe</span></tt> no lo
es. Es un constructor de tipo que toma un parámetro y produce un tipo
concreto. Sería algo pesado tener que escribir <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">Int)`</span>
<span class="pre">where</span></tt>, <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Eq</span> <span class="pre">(Maybe</span> <span class="pre">Char)</span> <span class="pre">where</span></tt>, etc. para cada tipo. Así que
podemos escribirlo así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Esto es como decir que queremos hacer una instancia de <tt class="docutils literal"><span class="pre">Eq</span></tt> para todos los
tipos <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">algo</span></tt>. De hecho, podríamos haber escrito <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">algo</span></tt>, pero
preferimos elegir nombres con una sola letra para ser fieles al estilo de
Haskell. Aquí, <tt class="docutils literal"><span class="pre">(Maybe</span> <span class="pre">m)</span></tt> hace el papel de <tt class="docutils literal"><span class="pre">a</span></tt> en <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></tt>.
Mientras que <tt class="docutils literal"><span class="pre">Maybe</span></tt> no es un tipo concreto, <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">m</span></tt> sí. Al utilizar un
parámetro tipo (<tt class="docutils literal"><span class="pre">m</span></tt>, que está en minúsculas), decimos que queremos todos los
tipos que sean de la forma <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">m</span></tt>, donde <tt class="docutils literal"><span class="pre">m</span></tt> es cualquier tipo que
forme parte de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt>.</p>
<p>Sin embargo, hay un problema con esto ¿Puedes averiguarlo? Utilizamos <tt class="docutils literal"><span class="pre">==</span></tt>
sobre los contenidos de <tt class="docutils literal"><span class="pre">Maybe</span></tt> pero nadie nos asegura de que lo que
contiene <tt class="docutils literal"><span class="pre">Maybe</span></tt> forme parte de la clase <tt class="docutils literal"><span class="pre">Eq</span></tt>. Por este motivo tenemos que
modificar nuestra declaración de instancia:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>Hemos añadido una restricción de clase. Con esta instancia estamos diciendo:
Queremos que todos los tipos con la forma <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">m</span></tt> sean miembros de la
clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt>, pero solo aquellos tipos donde <tt class="docutils literal"><span class="pre">m</span></tt> (lo que está
contenido dentro de <tt class="docutils literal"><span class="pre">Maybe</span></tt>) sean miembros también de <tt class="docutils literal"><span class="pre">Eq</span></tt>. En realidad
así sería como Haskell derivaría esta instancia.</p>
<p>La mayoría de las veces, las restricciones de clase en las <em>declaraciones de
clases</em> son utilizadas para crear una clases de tipos que sean subclases de
otras clases de tipos mientras que las restricciones de clase en las
<em>declaraciones de instancias</em> son utilizadas para expresar los requisitos de
algún tipo. Por ejemplo, ahora hemos expresado que el contenido de <tt class="docutils literal"><span class="pre">Maybe</span></tt>
debe formar parte de la clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt>.</p>
<p>Cuando creas una instancia, si ves que un tipo es utilizado como un tipo
concreto en la declaración de tipos (como <tt class="docutils literal"><span class="pre">a</span></tt> en <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>), debes
añadir los parámetros de tipos correspondientes y rodearlo con paréntesis de
forma que acabes teniendo un tipo concreto.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Ten en cuenta que el tipo para el cual estás trantando de hacer una
instancia remplazará el parámetro de la declaración de clase. La
<tt class="docutils literal"><span class="pre">a</span></tt> de <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Eq</span> <span class="pre">a</span> <span class="pre">where</span></tt> será remplazada con un tipo real
cuando crees una instancia, así que trata mentalmente de poner el
tipo en la declaración de tipo de las funiones.
<tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt> no tiene mucho sentido, pero
<tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">Boo</span></tt> sí. Pero esto es
simplemente una forma de ver las cosas, ya que <tt class="docutils literal"><span class="pre">==</span></tt> simpre tendrá
el tipo <tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>, sin importar las
instancias que hagamos.</p>
</div>
<p>Oh, una cosa más. Si quieres ver las instancias que existen de una clase de
tipos, simplemente haz <tt class="docutils literal"><span class="pre">:info</span> <span class="pre">YourTypeClass</span></tt> en GHCi. Así que si utilizamos
<tt class="docutils literal"><span class="pre">:info</span> <span class="pre">Num</span></tt> nos mostrará que funciones están definidas en la clase de tipos
y nos mostrará también una lista con los tipos que forman parte de esta clase.
<tt class="docutils literal"><span class="pre">:info</span></tt> también funciona con tipos y constructores de tipo. Si hacemos
<tt class="docutils literal"><span class="pre">:info</span> <span class="pre">Maybe</span></tt> veremos todas las clases de tipos de las que éste forma parte.
<tt class="docutils literal"><span class="pre">:info</span></tt> también te muestra el tipo de una función. Bastante útil.</p>
</div>
<div class="section" id="la-clase-de-tipos-yes-no">
<h2>La clase de tipos Yes-No<a class="headerlink" href="#la-clase-de-tipos-yes-no" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Sí y no" class="align-left" src="../_images/yesno.png" />
<p>En JavaScript y otros lenguajes débilmente tipados, puedes poner casi
cualquier cosa dentro de una expresión. Por ejemplo, puedes hacer todo lo
siguiente: <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(0)</span> <span class="pre">alert(&quot;YEAH!&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></tt>, <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(&quot;&quot;)</span> <span class="pre">alert</span>
<span class="pre">(&quot;YEAH!&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></tt>, <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(false)</span> <span class="pre">alert(&quot;YEAH&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!)</span></tt>,
etc. Y todos estos mostrarán un mensaje diciendo <tt class="docutils literal"><span class="pre">NO!</span></tt>. Si hacemos
<tt class="docutils literal"><span class="pre">if</span> <span class="pre">(&quot;WHAT&quot;)</span> <span class="pre">alert</span> <span class="pre">(&quot;YEAH&quot;)</span> <span class="pre">else</span> <span class="pre">alert(&quot;NO!&quot;)</span></tt> mostrará <tt class="docutils literal"><span class="pre">&quot;YEAH!&quot;</span></tt> ya que
en JavaScript las cadenas no vacías son consideradas valores verdaderos.</p>
<p>Aunque el uso estricto de <tt class="docutils literal"><span class="pre">Bool</span></tt> para la semántica de booleanos funciona
mejor en Haskell, vamos a intentar implementar este comportamiento de
JavaScript ¡Solo para divertirnos! Empecemos con la declaración de clase.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">YesNo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Muy simple. La clase de tipos <tt class="docutils literal"><span class="pre">YesNo</span></tt> define una función. Esta función toma
un valor de un tipo cualquiera que puede expresar algún valor de verdad y nos
dice si es verdadero o no. Fíjate en la forma que usamos <tt class="docutils literal"><span class="pre">a</span></tt> en la función,
<tt class="docutils literal"><span class="pre">a</span></tt> tiene que ser un tipo concreto.</p>
<p>Lo siguiente es definir algunas instancias. Para los números, asumimos que
(como en JavaScript) cualquier número que no sea 0 es verdadero y 0 es falso.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>La listas vacías (y por extensión las cadenas) son valores falsos, mientras
que las listas no vacías tienen un valor verdadero.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Fíjate como hemos puesto un parámetro de tipo dentro para hacer de la lista un
tipo concreto, aunque no suponemos nada acerca de lo que contiene la lista.
Qué más... Mmmm... ¡Ya se! <tt class="docutils literal"><span class="pre">Bool</span></tt> también puede contener valores verdaderos
y falos y es bastante obvio cual es cual.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
<p>¿Eh? ¿Qué es <tt class="docutils literal"><span class="pre">id</span></tt>? Simplemente es una función de la librería estándar que
toma un parámetro y devuelve lo mismo, lo cual es lo mismo que tendríamos que
escribir aquí.</p>
<p>Vamos a hacer también una instancia para <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">yesno</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>No necesitamos una restricción de clase ya que no suponemos nada acerca de los
contenidos de <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Simplemente decimos que es verdadero si es un valor
<tt class="docutils literal"><span class="pre">Just</span></tt> y falso si es <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Seguimos teniendo que escribir
<tt class="docutils literal"><span class="pre">(Maybe</span> <span class="pre">a)</span></tt> en lugar de solo <tt class="docutils literal"><span class="pre">Maybe</span></tt> ya que, si lo piensas un poco, una
función <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt> no puede existir (ya que <tt class="docutils literal"><span class="pre">Maybe</span></tt> no es un tipo
concreto), mientras que <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt> es correcto. Aún así, sigue siendo
genial ya que ahora, cualquier tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">algo</span></tt> es parte de la clase`
<tt class="docutils literal"><span class="pre">YesNo</span></tt> y no importa lo que sea <tt class="docutils literal"><span class="pre">algo</span></tt>.</p>
<p>Antes definimos un tipo <tt class="docutils literal"><span class="pre">Tree</span> <span class="pre">a</span></tt> para representar la búsqueda binaria.
Podemos decir que un árbol vacío tiene un valor falso mientras cualquier otra
cosa tiene un valor verdadero.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>¿Puede ser el estado de un semáforo un valor verdadero o falso? Claro. Si
está rojo, paras. Si está verde, continuas. ¿Si está ámbar? Ehh... normalmente
suelo acelerar ya que vivo por y para la adrenalina.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>Genial, ahora tenemos unas cuantas instancias, vamos a jugar con ellas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">hci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="n">length</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;haha&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="kt">Just</span> <span class="mi">0</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">EmptyTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">yesno</span>
<span class="nf">yesno</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>Bien ¡Funciona! Vamos a hacer una función que imite el comportamiento de una
sentencia <tt class="docutils literal"><span class="pre">if</span></tt>, pero que funcione con valores <tt class="docutils literal"><span class="pre">YesNo</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">yesnoIf</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">yesnoIf</span> <span class="n">yesnoVal</span> <span class="n">yesResult</span> <span class="n">noResult</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">yesno</span> <span class="n">yesnoVal</span> <span class="kr">then</span> <span class="n">yesResult</span> <span class="kr">else</span> <span class="n">noResult</span>
</pre></div>
</div>
<p>Bastante simple. Toma un valor con un grado de verdad y otros dos valores más.
Si el primer valor es verdadero, devuelve el primer valor de los otros dos,
de otro modo, devuelve el segundo.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">[]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">True</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">500</span><span class="p">)</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">Nothing</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="la-clase-de-tipos-functor">
<h2>La clase de tipos functor<a class="headerlink" href="#la-clase-de-tipos-functor" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hasta ahora, nos hemos encontrado con un montón de clases de tipos de la
librería estándar. Hemos jugado con <tt class="docutils literal"><span class="pre">Ord</span></tt>, la cual es para cosas que pueden
ser ordenadas. Hemos visto <tt class="docutils literal"><span class="pre">Eq</span></tt>, que es para cosas que pueden ser
equiparadas. Vimos también <tt class="docutils literal"><span class="pre">Show</span></tt>, la cual sirve como interfaz para los
tipos cuyos valores pueden ser representados como cadenas. Nuestro buen amigo
<tt class="docutils literal"><span class="pre">Read</span></tt> estará aquí siempre que necesitemos convertir una cadena a un valor
de algún tipo. Y ahora, vamos a echar un vistazo a la clase de tipos
<tt class="docutils literal"><span class="pre">Functor</span></tt>, la cual es básicamente para cosas que se pueden mapear.
Seguramente ahora mismo estés pensando en listas, ya que mapear una lista es
algún muy común en Haskell. Y estás en lo cierto, el tipo lista es miembro de
la clase de tipos <tt class="docutils literal"><span class="pre">Functor</span></tt>.</p>
<p>¿Qué mejor forma de conocer la clase de tipos <tt class="docutils literal"><span class="pre">Functor</span></tt> que ver como está
implementada? Vamos a echar una ojeada.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<img alt="Functor" class="align-right" src="../_images/functor.png" />
<p>De acuerdo. Hemos visto que define una función, <tt class="docutils literal"><span class="pre">fmap</span></tt>, y no proporciona
ninguna implementación por defecto para ella. El tipo de <tt class="docutils literal"><span class="pre">fmap</span></tt> es
interesante. En las definiciones de clases de tipos que hemos visto hasta
ahora, la variable de tipo que ha tenido un papel importante en la clase de
tipos ha sido un tipo concreto, como <tt class="docutils literal"><span class="pre">a</span></tt> en <tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">::</span> <span class="pre">(Eq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Bool</span></tt>. Pero ahora, <tt class="docutils literal"><span class="pre">f</span></tt> no es un tipo concreto (un tipo que puede tener
un valor, como <tt class="docutils literal"><span class="pre">Int</span></tt>, <tt class="docutils literal"><span class="pre">Bool</span></tt> o <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></tt>), sino un constructor de
tipos que toma un tipo como parámetro. Un ejemplo rápido para recordar:
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt> es un tipo concreto, pero <tt class="docutils literal"><span class="pre">Maybe</span></tt> es un constructor de tipos
que toma un tipo como parámetro. De cualquier modo, hemo visto que <tt class="docutils literal"><span class="pre">fmap</span></tt>
toma una función de un tipo a otro y un functor aplicado a un tipo y devuelve
otro functor aplicado con el otor tipo.</p>
<p>Si esto te suena un poco confuso, no te preocupes. Lo verás todo más claro
ahora cuando mostremos un cuantos ejemplos. Mmm... esta declaración de tipo
me recuerda a algo. Si no sabes cual es el tipo de <tt class="docutils literal"><span class="pre">map</span></tt>, es este: <tt class="docutils literal"><span class="pre">map</span> <span class="pre">::</span>
<span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[b]</span></tt>.</p>
<p>¡Interesante! Toma una función de un tipo a otro y una lista de un tipo y
devuelve una lista del otro tipo. Amigos, creo que acabamos de descubir un
functor. De hecho, <tt class="docutils literal"><span class="pre">map</span></tt> es <tt class="docutils literal"><span class="pre">fmap</span></tt> pero solo funciona con listas. Aquí
tienes como las listas tienen una instancia para la clase <tt class="docutils literal"><span class="pre">Functor</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="n">map</span>
</pre></div>
</div>
<p>¡Eso es! Fíjate que no hemos escrito <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">[a]</span> <span class="pre">where</span></tt>, ya que
a partir de <tt class="docutils literal"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">b</span></tt> vemos que <tt class="docutils literal"><span class="pre">f</span></tt> tiene que ser
un cosntructor de tipos que toma un parámetro. <tt class="docutils literal"><span class="pre">[a]</span></tt> ya es un tipo concreto
(un lista con cualquier tipo dentro), mientras que <tt class="docutils literal"><span class="pre">[]</span></tt> es un constructor
de tipos que toma un parámetro y produce cosas como <tt class="docutils literal"><span class="pre">[Int]</span></tt>, <tt class="docutils literal"><span class="pre">[String]</span></tt> o
incluso <tt class="docutils literal"><span class="pre">[[String]]</span></tt>.</p>
<p>Como para las listas, <tt class="docutils literal"><span class="pre">fmap</span></tt> es simplemente <tt class="docutils literal"><span class="pre">map</span></tt>, obtenemos el mismo
resultado cuando las usamos con listas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>¿Qué pasa cuando realizamos <tt class="docutils literal"><span class="pre">map</span></tt> o <tt class="docutils literal"><span class="pre">fmap</span></tt> sobre listas vacías? Bien,
desde luego obenemos una lista vacía. Simplemente convierte una lista vacía
con el tipo <tt class="docutils literal"><span class="pre">[a]</span></tt> a una lista vacía con el tipo <tt class="docutils literal"><span class="pre">[b]</span></tt>.</p>
<p>Los tipos que pueden actuar como una caja pueden ser functores. Puede pensar
en una lista como una caja que tiene un número ilimitado de pequeños
compartimientos y puden estar todos vacíos, o pueden estár algunos llenos.
Asi que, ¿Qué más tiene la propiedad de comportarse como una caja? Por
ejemplo, el tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. De algún modo, es como una caja que puede o bien
no contener nada, en cuyo caso su valor será <tt class="docutils literal"><span class="pre">Nothing</span></tt>, o puede contener
algo, como <tt class="docutils literal"><span class="pre">&quot;HAHA&quot;</span></tt>, en cuyo caso su valor ser`á <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">&quot;HAHA&quot;</span></tt>. Aquí
tienes como <tt class="docutils literal"><span class="pre">Maybe</span></tt> es un functor:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>De nuevo, fíjate que hemos escrito <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">Maybe</span> <span class="pre">where</span></tt> en lugar
de <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Maybe</span> <span class="pre">m)</span> <span class="pre">where</span></tt>, como hicimos cuando utilizamos la
clase <tt class="docutils literal"><span class="pre">YesNo</span></tt> junto con <tt class="docutils literal"><span class="pre">Maybe</span></tt>. <tt class="docutils literal"><span class="pre">Functor</span></tt> quiere un constructor de
tipos que tome un tipo y no un tipo concreto. Si mentalemente remplazas las
<tt class="docutils literal"><span class="pre">f</span></tt> con <tt class="docutils literal"><span class="pre">Maybe</span></tt>, <tt class="docutils literal"><span class="pre">fmap</span></tt> actua como <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></tt>
para este tipo en particular, lo cual se ve bien. Pero si remplazas <tt class="docutils literal"><span class="pre">f</span></tt> con
<tt class="docutils literal"><span class="pre">(Maybe</span> <span class="pre">m)</span></tt>, entonces parecerá que actua como <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">a</span> <span class="pre">-&gt;</span>
<span class="pre">Maybe</span> <span class="pre">m</span> <span class="pre">b</span></tt>, lo cual no tiene ningún maldito sentido ya que <tt class="docutils literal"><span class="pre">Maybe</span></tt> toma un
solo parámetro.</p>
<p>De cualquier forma, la implementación de <tt class="docutils literal"><span class="pre">fmap</span></tt> es muy simple. Si es un
valor vacío o <tt class="docutils literal"><span class="pre">Nothing</span></tt>, entonces simplemente devolvemos <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Si
mapeamos una caja vacía obtenemos una caja vacía. Tiene sentido. De la misma
forma que si mapeamos una lista vacía obtenemos un lista vacía. Si no es un
valor vacío, sino más bien un único valor envuelto por <tt class="docutils literal"><span class="pre">Just</span></tt>, entonces
aplicamos la función al contenido de <tt class="docutils literal"><span class="pre">Just</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;Something serious.&quot;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="s">&quot;Something serious. HEY GUYS IM INSIDE THE JUST&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">200</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">400</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<p>Otra cosa que puede ser mapeada y por tanto puede tener una instancia de
<tt class="docutils literal"><span class="pre">Functor</span></tt> es nuestro tipo <tt class="docutils literal"><span class="pre">Tree</span> <span class="pre">a</span></tt>. También puede ser visto como una caja
(contiene varios o ningún valor) y el constructor de tipos <tt class="docutils literal"><span class="pre">Tree</span></tt> toma
exactamente un parámetro de tipo. Si vemos la función <tt class="docutils literal"><span class="pre">fmap</span></tt> como si fuera
una función hecha exclusivamente para <tt class="docutils literal"><span class="pre">Tree</span></tt>, su declaración de tipo sería
como <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Tree</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Tree</span> <span class="pre">b</span></tt>. Vamos a utilizar la recursión con éste.
Mapear un árbol vacío poducirá un árbol vacío. Mapear un árbol no vacío
producirá un árbol en el que la función será aplicada al elemento raíz
y sus sub-árboles derechos e izquierdos serán los mismos sub-árboles, solo
que serán mapeado con la función.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">EmptyTree</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">leftsub</span> <span class="n">rightsub</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">leftsub</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">rightsub</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">EmptyTree</span>
<span class="kt">EmptyTree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">12</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">20</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))))</span> <span class="kt">EmptyTree</span>
</pre></div>
</div>
<p>¡Bien! ¿Qué pasa con <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>? ¿Puede ser un functor? La clase de tipos
<tt class="docutils literal"><span class="pre">Functor</span></tt> quiere constructores de tipos que tomen un solo parámetro de tipo
pero <tt class="docutils literal"><span class="pre">Either</span></tt> toma dos. Mmm... ¡Ya se! aplicaremos parcialmente <tt class="docutils literal"><span class="pre">Either</span></tt>
suministrando un solo parámetro de forma que solo tenga un parámetro libre.
Aquí tienes como el tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span></tt> es un functor en las librerías estándar.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
</pre></div>
</div>
<p>Bueno, bueno ¿Qué hemos hecho aquí? Pudes ver como hemos creado una instancia
para <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span></tt> en lugar de para solo <tt class="docutils literal"><span class="pre">Either</span></tt>. Esto es así porque`
<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span></tt> es un constructor de tipos que toma un parámetro, mientras que
<tt class="docutils literal"><span class="pre">Either</span></tt> toma dos. Si <tt class="docutils literal"><span class="pre">fmap</span></tt> fuese específicamente para <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span></tt>
entonces su declaración de tipo sería <tt class="docutils literal"><span class="pre">(b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">Either</span> <span class="pre">a</span> <span class="pre">c</span></tt>
ya que es lo mismo que <tt class="docutils literal"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c)</span> <span class="pre">-&gt;</span> <span class="pre">(Either</span> <span class="pre">a)</span> <span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">(Either</span> <span class="pre">a)</span> <span class="pre">c</span></tt>. En la
implementación, mapeamos en el caso del constructor de tipos <tt class="docutils literal"><span class="pre">Right</span></tt>, pero
no lo hacemos para el caso de <tt class="docutils literal"><span class="pre">Left</span></tt>. ¿Por qué? Bueno, si volvemos atrás
para ver como se define el tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>, varíamos algo como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div>
</div>
<p>Bueno, si quisieramos mapear una función sobre ambos, <tt class="docutils literal"><span class="pre">a</span></tt> y <tt class="docutils literal"><span class="pre">b</span></tt> deberían
tener el mimso tipo. Quiero decir, si quisieramos mapear una función que
toma una cadena y devuelve otra cadena y <tt class="docutils literal"><span class="pre">b</span></tt> fuese una cadena pero <tt class="docutils literal"><span class="pre">a</span></tt>
fuese un número, ésto no funcionaria. También, viendo <tt class="docutils literal"><span class="pre">fmap</span></tt> si operara solo
con valores de <tt class="docutils literal"><span class="pre">Either</span></tt>, veríamos que el primer parámetro tiene que
permanecer igual mientras que el segundo puede variar y el primer parámetro
está asociado al constructor de datos <tt class="docutils literal"><span class="pre">Left</span></tt>.</p>
<p>Esto también encaja con nuestra analogía de las cajas si pensamos en <tt class="docutils literal"><span class="pre">Left</span></tt>
como una especie de caja vacía con un mensaje de error escrito en un lado
diciendonos porque la caja está vacía.</p>
<p>Los diccionarios de <tt class="docutils literal"><span class="pre">Data.Map</span></tt> también son functores ya que pueden contener
(o no) valores. En el caso de <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></tt>, <tt class="docutils literal"><span class="pre">fmap</span></tt> mapearía una función
<tt class="docutils literal"><span class="pre">v</span> <span class="pre">-&gt;</span> <span class="pre">v'</span></tt> sobre un diccionario <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v</span></tt> y devolvería un diccionario con
el tipo <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">v'</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Fíjate que <tt class="docutils literal"><span class="pre">'</span></tt> no tiene ningún significado especial en los tipos
de la misma forma que no tienen ningún significado especial a la
hora de nombrar valores. Se suele utilizar para referirse a cosas
que son similares, solo que un poco cambiadas.</p>
</div>
<p>¡Trata de imaginarte como se crea la instancia de <tt class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span></tt> para <tt class="docutils literal"><span class="pre">Functor</span></tt>
tú mismo!</p>
<p>Con la clase de tipos <tt class="docutils literal"><span class="pre">Functor</span></tt> hemos visto como las clases de tipos puden
representar conceptos de orden superior interesantes. También hemos tenido un
poco de práctica aplicando parcialmente tipos y creando instancias. En uno de
los siguientes capítulos veremos algunas de las leyes que se aplican
a los functores.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Los functores deben obedecer algunas leyes de forma que tengan unas
propiedades de las que podamos depender para no tener que pensar
mucho luego. Si usamos <tt class="docutils literal"><span class="pre">fmap</span> <span class="pre">(+1)</span></tt> sobre un la lista <tt class="docutils literal"><span class="pre">[1,2,3,4]</span></tt>
esperemamos obtener <tt class="docutils literal"><span class="pre">[2,3,4,5]</span></tt> y no su inversa, <tt class="docutils literal"><span class="pre">[5,4,3,2]</span></tt>. Si
usamos <tt class="docutils literal"><span class="pre">fmap</span> <span class="pre">(\a</span> <span class="pre">-&gt;</span> <span class="pre">a)</span></tt> (la función identidad, que simplemente
devuelve su parámetro) sobre un lista, esperamos obtener la misma
lista como resultado. Por ejemplo, si le damos una instancia erronea
a nuestro tipo <tt class="docutils literal"><span class="pre">Tree</span></tt>, al usar <tt class="docutils literal"><span class="pre">fmap</span></tt> en un árbol donde el
sub-árbol izquierdo de un nodo solo contenga elementos menores que
el nodo y el sub-árbol derecho solo contenga elementos mayores que
el nodo podría producir un árbol donde no se cumpliera esto. Veremos
la leyes de los functores con más detalle en un próximo capítulo.</p>
</div>
</div>
<div class="section" id="familias-y-artes-marciales">
<h2>Familias y artes marciales<a class="headerlink" href="#familias-y-artes-marciales" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Typefoo" class="align-right" src="../_images/typefoo.png" />
<p>Los constructores de tipos toman otros tipos como parámetros y terminan
produciendo tipos concretos. Esto me recuerda a las funciones, las cuales
toman valores como parámetros y producen valores. Hemos visto que los
constructores de tipos pueden ser parcialmente aplicados (<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">String</span></tt> es
un constructor de tipos que toma un tipo y devuelve un tipo concreto, como
<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">String</span> <span class="pre">Int</span></tt>), al igual que la funciones. Muy interesante. En esta
sección, definiremos formalmente como los tipos son aplicados a los
constructores de tipos, de la misma definiremos formalmente como los valores
son aplicados a las funciones utilizando declaraciones de tipo. <strong>No
necesitas leer esta sección para continuar con tu búsqueda de la sabiduría
sobre Haskell</strong> y no consigues entenderlo, no te preocupes. Sin embargo,
si lo haces conseguiras un conocimiento profundo del sistema de tipos.</p>
<p>Así que, valores como <tt class="docutils literal"><span class="pre">3</span></tt>, <tt class="docutils literal"><span class="pre">&quot;YEAH&quot;</span></tt> o <tt class="docutils literal"><span class="pre">takeWhile</span></tt> (las funciones
también son valores ya que podemos usarlas como parámetros) tienen sus
correspondientes tipos. Los tipos son una pequeña etiqueta que llevan los
valores de forma que nos permitan razonar sobre estos. Pero los tipos tienen
sus propias pequeñas etiquetas, llamadas <strong>familias</strong>. Una familia es más o
menos el tipo de un tipo. Puede sonar un poco enrevesado y confuso, pero
en realidad es un concepto muy intersante.</p>
<p>¿Qué son las familias y para que son útiles? Bueno, vamos a examinar la
familia de un tipo utilizando el comando <tt class="docutils literal"><span class="pre">:k</span></tt> en GHCi.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Int</span>
<span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>¿Una estrella? Intrigante... ¿Qué significa? Una <tt class="docutils literal"><span class="pre">*</span></tt> significa que el tipo
es un tipo concreto. Un tipo concreto es un tipo que no toma ningún parámetro
de tipo y valores solo pueden tener tipos que sean tipos concretos. Si tuviera
que leer <tt class="docutils literal"><span class="pre">*</span></tt> en voz alta (hasta ahora no he tenido que hacerlo), diría
<em>estrella</em> o simplemente <em>tipo</em>.</p>
<p>Vale, ahora vamos a ver cual es la familia de <tt class="docutils literal"><span class="pre">Maybe</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span>
<span class="kt">Maybe</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>El constructor de tipos <tt class="docutils literal"><span class="pre">Maybe</span></tt> toma un tipo concreto (como <tt class="docutils literal"><span class="pre">Int</span></tt>) y luego
devuelve un tipo concreto como <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt>. Y esto es lo que la familia nos
está diciendo. De la misma forma que <tt class="docutils literal"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></tt> representa una función que
toma un <tt class="docutils literal"><span class="pre">Int</span></tt> y devuelve un <tt class="docutils literal"><span class="pre">Int</span></tt>, <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt> representa un constructor de
tipos que toma un tipo concreto y devuelve otro tipo concreto. Vamos a aplicar
el parámetro de tipo a <tt class="docutils literal"><span class="pre">Maybe</span></tt> y ver cual es su familia.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Maybe</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>¡Justo como esperaba! Hemo pasado un parámetro de tipo a <tt class="docutils literal"><span class="pre">Maybe</span></tt> y hemos
obtenido un tipo concreto (esto es lo que significa <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>). Un símil
(aunque no equivalente, los tipos y las familias son dos cosas distintas)
sería si hicieramos <tt class="docutils literal"><span class="pre">:t</span> <span class="pre">isUpper</span></tt> y <tt class="docutils literal"><span class="pre">:t</span> <span class="pre">isUpper</span> <span class="pre">'A'</span></tt>. <tt class="docutils literal"><span class="pre">isUpper</span></tt> tiene el
tipo <tt class="docutils literal"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt> y <tt class="docutils literal"><span class="pre">isUpper</span> <span class="pre">'A'</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">Bool</span></tt> ya que su valor
es básicamente <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<p>Utilizamos <tt class="docutils literal"><span class="pre">:k</span></tt> con un tipo para obtener su familia, de la misma forma que
utilizamos <tt class="docutils literal"><span class="pre">:t</span></tt> con un valor para obtener su tipo. Como ya hemos dicho, los
tipos son las etiquetas de los valores y las familias son las etiquetas de los
tipos y hay similitudes entre ambos.</p>
<p>Vamos a ver otra familia.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span>
<span class="kt">Either</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>¡Aha! Esto nos dice que <tt class="docutils literal"><span class="pre">Either</span></tt> toma dos tipos concretos como parámetros
de tipo y produce un tipo concreto. También se parece a una declaracion de
tipo de una función que toma dos valores y devuelve algo. Los construcotores
de tipos están currificados (como las funciones), así que podemos aplicarlos
parcialmente.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div>
</div>
<p>Cuando quisimos que <tt class="docutils literal"><span class="pre">Either</span></tt> formara parte de la clase de tipos <tt class="docutils literal"><span class="pre">Functor</span></tt>,
tuvimos que aplicarlo parcialmente ya que <tt class="docutils literal"><span class="pre">Functor</span></tt> quiere tipos que tomen
un solo parámetro`,` mientras que <tt class="docutils literal"><span class="pre">Either</span></tt> toma dos. En otras palabras,
<tt class="docutils literal"><span class="pre">Functor</span></tt> quiere tipos de la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt> y por eso tuvimos que
aplicar parcialmente <tt class="docutils literal"><span class="pre">Either</span></tt> para obtener una familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt> en lugar
de su familia original <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Si vemos la definición de <tt class="docutils literal"><span class="pre">Functor</span></tt>
otra vez</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>veremos que la variable de tipo <tt class="docutils literal"><span class="pre">f</span></tt> es utiliza como un tipo que que toma un
tipo y produce un tipo concreto. Sabemos que produce un tipo concreto porque
es utilizada como el tipo de un valor en una función. Podemos deducir que los
tipos que quieren amigables con <tt class="docutils literal"><span class="pre">Functor</span></tt> debe ser de la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>.</p>
<p>Ahora vamos a practicar un poco de artes marciales. Echa un vistazo a la clase
de tipos que voy a utilizar:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Tofu</span> <span class="n">t</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="ow">::</span> <span class="n">j</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="n">j</span>
</pre></div>
</div>
<p>Parece complicado ¿Cómo podríamos crear un tipo que tuviera una instancia para
esta clase de tipos estraña? Bueno, vamos a ver que familia tiene que tener.
Como <tt class="docutils literal"><span class="pre">j</span> <span class="pre">a</span></tt> es utilizado como el tipo del valor que la función <tt class="docutils literal"><span class="pre">tofu</span></tt> toma
como parámetro, <tt class="docutils literal"><span class="pre">j</span> <span class="pre">a</span></tt> debe tener la familia <tt class="docutils literal"><span class="pre">*</span></tt>. Asumimos <tt class="docutils literal"><span class="pre">*</span></tt> para <tt class="docutils literal"><span class="pre">a</span></tt>
de forma que podemos inferir que <tt class="docutils literal"><span class="pre">j</span></tt> pertenece a la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>.
Vemos que <tt class="docutils literal"><span class="pre">t</span></tt> también tiene que producir un tipo concreto y toma dos tipos.
Sabiendo que <tt class="docutils literal"><span class="pre">a</span></tt> es de la familia <tt class="docutils literal"><span class="pre">*</span></tt> y <tt class="docutils literal"><span class="pre">j</span></tt> de <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>, podemos
inferir que <tt class="docutils literal"><span class="pre">t</span></tt> es de la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Así que toma un
tipo concreto (<tt class="docutils literal"><span class="pre">a</span></tt>), un constructor de tipos (<tt class="docutils literal"><span class="pre">j</span></tt>)  que toma un tipo
concreto y devuelve un tipo concreto. Wau.</p>
<p>Vale, vamos a crear un tipo con una familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Aquí
tienes una posible solución.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Frank</span> <span class="n">a</span> <span class="n">b</span>  <span class="ow">=</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">::</span> <span class="n">b</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>¿Cómo sabemos que este tipo pertenece a la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>?
Bueno, los campos de un TDA (tipos de datos algebraicos, <em>ADT</em> en inglés)
sirven para contener valores, así que obviamente pertenecen a la familia
<tt class="docutils literal"><span class="pre">*</span></tt>. Asumimos <tt class="docutils literal"><span class="pre">*</span></tt> para <tt class="docutils literal"><span class="pre">a</span></tt>, lo que significa que <tt class="docutils literal"><span class="pre">b</span></tt> toma un parámetro
de tipo y por lo tanto pertenece a la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Ahora que sabemos
las familia de <tt class="docutils literal"><span class="pre">a</span></tt> y <tt class="docutils literal"><span class="pre">b</span></tt> ya que son parámetros de <tt class="docutils literal"><span class="pre">Frank</span></tt>, vemos que
<tt class="docutils literal"><span class="pre">Frank</span></tt> pertenece a la familia <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. El primer <tt class="docutils literal"><span class="pre">*</span></tt>
representa <tt class="docutils literal"><span class="pre">a</span></tt> y <tt class="docutils literal"><span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span></tt> representa <tt class="docutils literal"><span class="pre">b</span></tt>. Vamos a crear algunos
valores de <tt class="docutils literal"><span class="pre">Frank</span></tt> y comprobar sus tipos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">Maybe</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Tree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>Mmm... Como <tt class="docutils literal"><span class="pre">frankField</span></tt> tiene el tipo en forma de <tt class="docutils literal"><span class="pre">a</span> <span class="pre">b</span></tt>, sus valores
deben tener tipos de forma similar. Puede ser como <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">&quot;HAHA&quot;</span></tt>, el cual
tiene el tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">[Char]</span></tt> o puede ser como <tt class="docutils literal"><span class="pre">['Y','E','S']</span></tt> que tiene
el tipo <tt class="docutils literal"><span class="pre">[Char]</span></tt> (si usaramos nuestro tipo de listas que creamos
anteriormente, sería <tt class="docutils literal"><span class="pre">List</span> <span class="pre">Char</span></tt>). Y vemos que los tipos de los valores de
<tt class="docutils literal"><span class="pre">Frank</span></tt> se corresponden con la familia de <tt class="docutils literal"><span class="pre">Frank</span></tt>. <tt class="docutils literal"><span class="pre">[Char]</span></tt> pertenece a
la familia <tt class="docutils literal"><span class="pre">*</span></tt> y <tt class="docutils literal"><span class="pre">Maybe</span></tt> pertenece a <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Como para poder tener
valores un tipo tiene que ser un tipo concreto y por lo tanto debe ser
completamente aplicado, cada valor de <tt class="docutils literal"><span class="pre">Frank</span> <span class="pre">bla</span> <span class="pre">blaaa</span></tt> pertenece a la
familia <tt class="docutils literal"><span class="pre">*</span></tt>.</p>
<p>Crear la instancia de <tt class="docutils literal"><span class="pre">Frank</span></tt> para <tt class="docutils literal"><span class="pre">Tofu</span></tt> es bastante simple. Hemos visto
que <tt class="docutils literal"><span class="pre">tofu</span></tt> toma un <tt class="docutils literal"><span class="pre">j</span> <span class="pre">a</span></tt> (que por ejemplo podría ser <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt>) y
devuelve un <tt class="docutils literal"><span class="pre">t</span> <span class="pre">j</span> <span class="pre">a</span></tt>. Así que si remplazamos <tt class="docutils literal"><span class="pre">j</span></tt> por <tt class="docutils literal"><span class="pre">Frank</span></tt>, el tipo del
resultado sería <tt class="docutils literal"><span class="pre">Frank</span> <span class="pre">Int</span> <span class="pre">Maybe</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Tofu</span> <span class="kt">Frank</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Frank</span> <span class="n">x</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Maybe</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">[]</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]}</span>
</pre></div>
</div>
<p>No es muy útil, pero hemos calentado. Vamos a continuar haciedo artes
marciales. Tenemos este tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Barry</span> <span class="n">t</span> <span class="n">k</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span> <span class="n">yabba</span> <span class="ow">::</span> <span class="n">p</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">::</span> <span class="n">t</span> <span class="n">k</span> <span class="p">}</span>
</pre></div>
</div>
<p>Y ahora queremos crear una instancia para la clase <tt class="docutils literal"><span class="pre">Functor</span></tt>. <tt class="docutils literal"><span class="pre">Functor</span></tt>
requiere tipos cuya familia sea <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt> pero <tt class="docutils literal"><span class="pre">Barry</span></tt> no parece que
pertenezca a esa familia. ¿Cúal es la familia de <tt class="docutils literal"><span class="pre">Barry</span></tt>? Bueno, vemos que
toma tres parámetros de tipo, así que va ser algo como <tt class="docutils literal"><span class="pre">algo</span> <span class="pre">-&gt;</span> <span class="pre">algo</span> <span class="pre">-&gt;</span> <span class="pre">algo</span>
<span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Esta claro que <tt class="docutils literal"><span class="pre">p</span></tt> es un tipo concreto y por lo tanto pertenece a la
familia <tt class="docutils literal"><span class="pre">*</span></tt>. Para <tt class="docutils literal"><span class="pre">k</span></tt> asumimos <tt class="docutils literal"><span class="pre">*</span></tt> y por extensión, <tt class="docutils literal"><span class="pre">t</span></tt> pertenece a
<tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Ahora solo tenemos que remplazar estas familia por los <em>algos</em> que
hemos utilizado y veremos que el tipo pertenece a la familia <tt class="docutils literal"><span class="pre">(*</span> <span class="pre">-&gt;</span> <span class="pre">*)</span> <span class="pre">-&gt;</span> <span class="pre">*`</span>
<span class="pre">`-&gt;</span> <span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Vamos a comprobarlo con GHCi.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Barry</span>
<span class="kt">Barry</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div>
</div>
<p>Ah, teníamos razón. Ahora, para hacer que este tipo forme parte de la clase
<tt class="docutils literal"><span class="pre">Functor</span></tt> tenemos que aplicar parcialmente los dos primeros parámetros de
tipo de forma que nos quedemos con <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt>. Esto significa que comenzaremos
con nuestra declaración de instancia así: <tt class="docutils literal"><span class="pre">instance</span> <span class="pre">Functor</span> <span class="pre">(Barry</span> <span class="pre">a</span> <span class="pre">b)</span>
<span class="pre">where</span></tt>. Si vemos <tt class="docutils literal"><span class="pre">fmap</span></tt> como si estuviese hecho exclusivamente para`
<tt class="docutils literal"><span class="pre">Barry</span></tt>, tendría un tipo <tt class="docutils literal"><span class="pre">fmap</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span> <span class="pre">b</span></tt>,
ya que simplemente hemos remplazado la <tt class="docutils literal"><span class="pre">f</span></tt> de <tt class="docutils literal"><span class="pre">Functor</span></tt> por <tt class="docutils literal"><span class="pre">Barry</span> <span class="pre">c</span> <span class="pre">d</span></tt>.
El tercer parámetro de tipo de <tt class="docutils literal"><span class="pre">Barry</span></tt> tendría que cambiar y de esta forma
tendríamos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Barry</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">}</span>
</pre></div>
</div>
<p>¡Ahí lo tienes! Simplemente hemos aplicado <tt class="docutils literal"><span class="pre">f</span></tt> sobre el primer campo.</p>
<p>En esta sección, hemos dado un buen vistazo a como funcionan los parámetros de
tipos y como se formalizan con la familias, de la misma forma que formalizamos
los parámetros de las funciones con las declaraciones de tipo. Hemos visto que
hay similitudes entre las funciones y los constructores de tipos. De todas
formas, son cosas totalmente distintas. Cuando trabajamos con Haskell,
normalmente no debes preocuparte por la familias ni inferir mentalmente las
familias como hemos hecho aquí. Lo normal es que tengas que aplicar
parcialmente tu tipo a <tt class="docutils literal"><span class="pre">*</span> <span class="pre">-&gt;</span> <span class="pre">*</span></tt> o <tt class="docutils literal"><span class="pre">*</span></tt> cuando creamos una instancia para
alguna clase de la librería estándar, pero está bien saber como funciona
realmente. Es interesante saber que los tipos tienen sus propios pequeños
tipos también. De nuevo, no tienes porque entender todo lo que acabamos de
hacer aquí, pero si entiendes como funcionan las familias, tienes más
posibilidades de entender correctamente el sistema de tipos de Haskell.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="EntradaSalida.html" title="Entrada y salida"
             >siguiente</a></li>
        <li class="right" >
          <a href="Modulos.html" title="Módulos"
             >anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Miran Lipovača.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>