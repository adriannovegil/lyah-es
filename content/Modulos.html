
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Módulos &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../static/style.css" type="text/css" />
    <link rel="stylesheet" href="../static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../static/jquery.js"></script>
    <script type="text/javascript" src="../static/underscore.js"></script>
    <script type="text/javascript" src="../static/doctools.js"></script>
    <script type="text/javascript" src="../static/translations.js"></script>
    <link rel="shortcut icon" href="../static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Creando nuestros propios tipos y clases de tipos" href="ClasesDeTipos.html" />
    <link rel="prev" title="Funciones de orden superior" href="OrdenSuperior.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ClasesDeTipos.html" title="Creando nuestros propios tipos y clases de tipos"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="OrdenSuperior.html" title="Funciones de orden superior"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="modulos">
<h1>Módulos<a class="headerlink" href="#modulos" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="cargando-modulos">
<h2>Cargando módulos<a class="headerlink" href="#cargando-modulos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Módulos" class="align-right" src="../images/modules.png" />
<p>Un módulo de Haskell es una colección de funciones, tipos y clases de tipos
relacionadas entre si. Un programa Haskell es una colección de módulos donde
el módulo principal carga otros módulos y utiliza las funciones definidas
en ellos para realizar algo. Tener el código divido en módulos tiene bastantes
ventajas. Si un módulo es lo suficientemente genérico, las funciones que son
exportadas pueden ser utilizadas en una gran variedad de programas. Si tu
código esta separado en módulos que no dependen mucho entre ellos (también
decimos que están débilmente acoplados), luego puedes reutilizarlos. Esto hace
que la tarea de programar sea más manejable teniendo ya que está todo dividido
en varias partes, cada una con su propio propósito.</p>
<p>La librería estándar de Haskell está dividida en varios módulos, cada uno de
ellos está formado por funciones y tipos que de alguna forma están
relacionados y sirven para propósito común. Existe un módulo para manipular
listas, un módulos para la programación concurrente, un módulo para trabajar
con números complejos, etc. Todas las funciones, tipos y clases de tipos con
las que hemos trabajado hasta ahora son parte del módulo <tt class="docutils literal"><span class="pre">Prelude</span></tt>, el cual
es importado por defecto. En este capítulo vamos a ver unos cuantos módulos
útiles y sus respectivas funciones. Pero primero, vamos a ver como se importan
los módulos.</p>
<p>La sintaxis para importar módulos en un script de Haskell es <tt class="docutils literal"><span class="pre">import</span> <span class="pre">&lt;module</span>
<span class="pre">name&gt;</span></tt>. Debe aparecer antes de que definamos cualquier función, así que las
importaciones de módulos suelen estar al principio de los ficheros. Un script
puede, obviamente, importar varios módulos. Simplemente hay que poner cada
<tt class="docutils literal"><span class="pre">import</span></tt> en líneas separadas. Vamos a importar el módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt>, el
cual contiene un puñado de útiles funciones para trabajar con listas, y
utilizaremos una función que exporta dicho módulo para crear una función que
nos diga cuantos elementos únicos hay en una lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">numUniques</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">numUniques</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">nub</span>
</pre></div>
</div>
<p>Cuando realizamos <tt class="docutils literal"><span class="pre">import</span> <span class="pre">Data.List</span></tt>, todas las funciones que <tt class="docutils literal"><span class="pre">Data.List</span></tt>
exporta están disponibles en el espacio de nombres global. Esto significa que
podemos acceder a todas estas funciones desde nuestro script. <tt class="docutils literal"><span class="pre">nub</span></tt> es una
función que está definida en <tt class="docutils literal"><span class="pre">Data.List</span></tt> la cual toma una lista y devuelve
otra sin elementos duplicados. Componer <tt class="docutils literal"><span class="pre">length</span></tt> y <tt class="docutils literal"><span class="pre">nub</span></tt> haciendo
<tt class="docutils literal"><span class="pre">length</span> <span class="pre">.</span> <span class="pre">nub</span></tt> produce una función equivalente a <tt class="docutils literal"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">length</span> <span class="pre">(nub</span> <span class="pre">xs)</span></tt>.</p>
<p>También puedes importar módulos y utilizarlos cuando estamos trabajando con
GHCi. Si estamos en una sesión de GHCi y queremos utilizar las funciones que
exporta <tt class="docutils literal"><span class="pre">Data.List</span></tt> hacemos esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
</pre></div>
</div>
<p>Si queremos cargar varios módulos dentro de GHCi no tenemos porque utilizar
<tt class="docutils literal"><span class="pre">:m</span> <span class="pre">+</span></tt> varias veces, simplemente podemos cargar varios módulos de golpe:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span>
</pre></div>
</div>
<p>Sin embargo, si ya has cargado un script que importa algún módulo, no tienes
que utilizar <tt class="docutils literal"><span class="pre">:m</span> <span class="pre">+</span></tt> para poder utilizarlo.</p>
<p>Si únicamente necesitas algunas funciones de un módulo, puedes seleccionarlas
para que solamente se importen dichas funciones. Si queremos importan solo las
funciones <tt class="docutils literal"><span class="pre">nub</span></tt> y <tt class="docutils literal"><span class="pre">sort</span></tt> de <tt class="docutils literal"><span class="pre">Data.List</span></tt> hacemos lo siguiente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">nub</span><span class="p">,</span> <span class="nf">sort</span><span class="p">)</span>
</pre></div>
</div>
<p>También puede importar todas las funciones de un módulo excepto algunas
seleccionadas. Normalmente esto se utiliza cuando tenemos varios módulos que
exportan una función con el mismo nombre y nos queremos librar de una de
ellas. Digamos que ya tenemos una función llamada <tt class="docutils literal"><span class="pre">nub</span></tt> y queremos importar
todas las funciones de <tt class="docutils literal"><span class="pre">Data.List</span></tt> excepto la función <tt class="docutils literal"><span class="pre">nub</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">nub</span><span class="p">)</span>
</pre></div>
</div>
<p>Otra forma de tratar con las colisiones de nombres es con las importaciones
cualificadas. El módulo <tt class="docutils literal"><span class="pre">Data.Map</span></tt>, que ofrece una estructura de datos para
buscar valores por clave, exporta un montón de funciones con nombres iguales
a las funciones de <tt class="docutils literal"><span class="pre">Prelude</span></tt>, como <tt class="docutils literal"><span class="pre">filter</span></tt> o <tt class="docutils literal"><span class="pre">null</span></tt>. Así que cuando
importamos <tt class="docutils literal"><span class="pre">Data.Map</span></tt> y llamamos a <tt class="docutils literal"><span class="pre">filter</span></tt>, Haskell no sabe a que función
llamar. Aquí tienes como lo solucionamos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span>
</pre></div>
</div>
<p>De esta forma, si queremos referirnos a la función <tt class="docutils literal"><span class="pre">filter</span></tt> de <tt class="docutils literal"><span class="pre">Data.Map</span></tt>,
tenemos que usar <tt class="docutils literal"><span class="pre">Data.Map.filter</span></tt>, mientras que si usamos simplemente
<tt class="docutils literal"><span class="pre">filter</span></tt> nos estamos referimos al filtro normal que todos conocemos.
Escribir <tt class="docutils literal"><span class="pre">Data.Map</span></tt> delante de todas las funciones es bastante pesado. Por
este motivo podemos renombrar una importación cualificada con algo un poco
más corto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
</pre></div>
</div>
<p>De esta forma, para referirnos a la función <tt class="docutils literal"><span class="pre">filter</span></tt> de <tt class="docutils literal"><span class="pre">Data.Map</span></tt> solo
tenemos que usar <tt class="docutils literal"><span class="pre">M.filter</span></tt>.</p>
<p>Puede usar es útil
<a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/libraries/">referencia</a>  para
ver que módulos están en la librería estándar. Una forma de obtener
información acerca de Haskell es simplemente hacer click por la referencia
de la librería estándar y explorar sus módulos y sus funciones. También puedes
ver el código fuente de cada módulo. Leer el código fuente de algunos módulos
es una muy buena forma de aprender Haskell.</p>
<p>Puedes buscar funciones o buscar donde están localizadas usando
<a class="reference external" href="http://haskell.org/hoogle">Hoogle</a>. Es un increíble motor de búsqueda de
Haskell. Puedes buscar por nombre de función, nombre de módulo o incluso por
la definición de tipo de una función.</p>
</div>
<div class="section" id="data-list">
<h2>Data.List<a class="headerlink" href="#data-list" title="Enlazar permanentemente con este título">¶</a></h2>
<p>El módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt> trata exclusivamente con listas, obviamente. Ofrece
funciones muy útiles para trabajar con listas. Ya hemos utilizado alguna de
estas funciones (como <tt class="docutils literal"><span class="pre">map</span></tt> y <tt class="docutils literal"><span class="pre">filter</span></tt>) ya que el módulo <tt class="docutils literal"><span class="pre">Prelude</span></tt>
exporta algunas funciones de <tt class="docutils literal"><span class="pre">Data.List</span></tt> por conveniencia. No hace falta
importar el módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt> de forma cualificada porque no colisiona con
ningún nombre de <tt class="docutils literal"><span class="pre">Prelude</span></tt> excepto por los que ya toma este de
<tt class="docutils literal"><span class="pre">Data.List</span></tt>. Vamos a dar un vistazo a algunas funciones que aún no hemos
conocido.</p>
<blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">intersperse</span></tt> toma un elemento y una lista pone ese elemento entre cada
par de elementos de la lista. Una demostración:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="sc">&#39;.&#39;</span> <span class="s">&quot;MONKEY&quot;</span>
<span class="s">&quot;M.O.N.K.E.Y&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">intercalate</span></tt> toma una lista y una listas de listas. Inserta la primera
lista entre todas las demás lista, dando como resultado una única lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="s">&quot; &quot;</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there guys&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">transpose</span></tt> transpone una lista de listas. Si miras la lista de listas
como una matriz 2D, las columnas se convierten en filas y viceversa.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;htg&quot;</span><span class="p">,</span><span class="s">&quot;ehu&quot;</span><span class="p">,</span><span class="s">&quot;yey&quot;</span><span class="p">,</span><span class="s">&quot;rs&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Supongamos que tenemos los polinomios <img class="math" src="../images/math/90d1ec6f48a98d2b9f2c200c11bcbd470a2b5965.png" alt="3x^{2} + 5x + 9"/>,
<img class="math" src="../images/math/9ead7c768f7b1304eca3610904a3ccc777abc9d6.png" alt="10x^{3} + 9"/> y <img class="math" src="../images/math/e9268878e310aacd2eb5cd8322c4ac757f321d80.png" alt="8x^{3} + 5x^{2} + x - 1"/> y queremos sumarlos.
Podemos usar las listas <tt class="docutils literal"><span class="pre">[0,3,5,9]</span></tt>, <tt class="docutils literal"><span class="pre">[10,0,0,9]</span></tt> y <tt class="docutils literal"><span class="pre">[8,5,1,-1]</span></tt> para
representarlos en Haskell. Ahora, para sumarlos lo único que tenemos que
hacer es:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span>
</pre></div>
</div>
<p>Cuando transponemos estas tres listas, las potencias cúbicas están en la
primera fila, los cuadrados en la segunda fila, etc. Al mapear <tt class="docutils literal"><span class="pre">sum</span></tt>
sobre esto produce el resultado que buscamos.</p>
</li>
<li><img alt="Listas lego" class="first align-right" src="../images/legolists.png" />
<p><tt class="docutils literal"><span class="pre">foldl'</span></tt> y <tt class="docutils literal"><span class="pre">foldl1'</span></tt> son versiones estrictas de sus respectivas
versiones perezosas. Cuando usamos pliegues perezosos sobre listas
muy grandes solemos obtener errores de desbordamiento de pila. El motivo
de que suceda esto es que dada la naturaleza de los pliegues perezosos,
el valor acumulador no es actualizado hasta que se realiza el pliegue. Lo
que en realidad pasa es que el acumulador hace un especie de promesa de que
él calculará el valor cuando se le pide que produzca un resultado (a esto
también se le llama thunk). Esto pasa para cada valor intermedio del
acumulador y todos esos <em>thunks</em> desbordan la pila. Los pliegues estrictos
no sufren de este error ya que van calculando de verdad los valores
intermedios según recorren la lista en lugar de de llenar la pila con
<em>thunks</em>. Ya sabes, si alguna vez te encuentras con errores de desbordamiento
de pila mientras realizas un pliegue, prueba estas funciones.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">concat</span></tt> aplana una lista de listas en una simple lista con los mismos
elementos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="s">&quot;car&quot;</span><span class="p">]</span>
<span class="s">&quot;foobarcar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Básicamente elimina un nivel de anidamiento. Si quieras aplanar
completamente <tt class="docutils literal"><span class="pre">[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</span></tt>, que es una lista de
listas de listas, tienes que aplanarla dos veces.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">concatMap</span></tt> es lo mismo que hacer primero un mapeado con una función a
una lista y concatenar todos los resultados.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">and</span></tt> toma una lista de booleanos y devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt> solo si todos los
elementos de la lista son <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">or</span></tt> es como <tt class="docutils literal"><span class="pre">and</span></tt> solo que devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt> solo si existe algún
elemento <tt class="xref docutils literal"><span class="pre">True</span></tt> en la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">any</span></tt> y <tt class="docutils literal"><span class="pre">all</span></tt> toman un predicado y una lista y comprueban si el
predicado se satisface para algún o para todos los elementos
respectivamente. Normalmente usamos estas funciones en lugar de tener que
mapear un lista y luego usar <tt class="docutils literal"><span class="pre">all</span></tt> o <tt class="docutils literal"><span class="pre">or</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">iterate</span></tt> toma una función y un valor inicial. Aplica esa función al
valor inicial, luego aplica la función al resultado anterior, luego aplica
es misma función al resultado anterior otra vez, etc. Devuelve todos los
resultados en forma de lista infinita.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span> <span class="s">&quot;haha&quot;</span>
<span class="p">[</span><span class="s">&quot;haha&quot;</span><span class="p">,</span><span class="s">&quot;hahahaha&quot;</span><span class="p">,</span><span class="s">&quot;hahahahahaha&quot;</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">splitAt</span></tt> toma un número y una lista. Luego divide la lista por el
índice indicado y devuelve una dupla con ambas listas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;man&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">100</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;heyman&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;heyman&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;foobar&quot;</span> <span class="kr">in</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
<span class="s">&quot;barfoo&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">takeWhile</span></tt> es una función realmente útil. Toma elemento de una lista
mientras el predicado se mantenga a cierto, y luego cuando encuentra un
elemento que no satisface el predicado, corta la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This&quot;</span>
</pre></div>
</div>
<p>Digamos que queremos saber la suma de todas las potencias cúbicas que
están por debajo de 10.000. No podemos mapear <tt class="docutils literal"><span class="pre">(^3)</span></tt> a <tt class="docutils literal"><span class="pre">[1..]</span></tt>, aplicar
un filtro y luego sumar el resultado ya que filtrar una lista infinita
nunca termina. Tu sabes que todos los elementos son ascendentes pero
Haskell no lo sabe. Por eso usamos esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="mi">53361</span>
</pre></div>
</div>
<p>Aplicamos <tt class="docutils literal"><span class="pre">(^3)</span></tt> a una lista infinita y una vez que una elemento mayor
que 10.000 es encontrado, se corta la lista. De esa forma, luego podemos
sumar la lista fácilmente.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">dropWhile</span></tt> es similar, solo que descarta elemento mientras el predicado
se cumpla. Una vez que el predicado se evalúa a <tt class="xref docutils literal"><span class="pre">False</span></tt>, devuelve el
resto de la lista. ¡Una función encantadora!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot; is a sentence&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Nos dan una lista que representa los valores de las acciones por fechas.
La lista contiene 4-tuplas cuyo primer elemento es el valor de la acción,
el segundo el año, el tercero es el mes y el cuarto el día. Si quisiéramos
saber cuando una acción alcanzara por primera vez los 1000$, podríamos usar
esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stock</span> <span class="ow">=</span> <span class="p">[(</span><span class="mf">994.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mf">995.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mf">999.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mf">998.3</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">(</span><span class="n">dropWhile</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="n">stock</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">span</span></tt> es un tipo de <tt class="docutils literal"><span class="pre">takeWhile</span></tt>, solo que devuelve una dupla de
listas. La primera lista contiene todo lo que tendría la lista resultante
de <tt class="docutils literal"><span class="pre">takeWhile</span></tt>. La lista contendría toda la lista que hubiese sido
cortada.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
      <span class="kr">in</span> <span class="s">&quot;First word:&quot;</span> <span class="o">++</span> <span class="n">fw</span> <span class="o">++</span> <span class="s">&quot;, the rest:&quot;</span> <span class="o">++</span> <span class="n">rest</span>
<span class="s">&quot;First word: This, the rest: is a sentence&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first">Mientras que <tt class="docutils literal"><span class="pre">span</span></tt> divide la lista cuando el predicado deja de
cumplirse, <tt class="docutils literal"><span class="pre">break</span></tt> divide la lista cuando el predicado se cumple por
primera vez. Equivale a <tt class="docutils literal"><span class="pre">span</span> <span class="pre">(not</span> <span class="pre">.</span> <span class="pre">p)</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div>
</div>
<p>Cuando usamos <tt class="docutils literal"><span class="pre">break</span></tt>, la segunda lista comenzará con el primer elemento
que satisfaga el predicado.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">sort</span></tt> simplemente ordena una lista. El tipo de elementos que contenga
la lista tiene que ser miembro de clase de tipos <tt class="docutils literal"><span class="pre">Ord</span></tt>, ya que si los
elementos de la lista no se pueden poner en algún tipo de orden, la lista
no se puede ordenar.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="s">&quot;This will be sorted soon&quot;</span>
<span class="s">&quot;    Tbdeehiillnooorssstw&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">group</span></tt> toma una lista y agrupa los elementos adyacentes que sean iguales
en sublistas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">]]</span>
</pre></div>
</div>
<p>Si ordenamos una lista antes de agruparla podemos obtener cuantas veces se
repite cada elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">length</span> <span class="n">l</span><span class="p">))</span> <span class="o">.</span> <span class="n">group</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">inits</span></tt> y <tt class="docutils literal"><span class="pre">tails</span></tt> son como <tt class="docutils literal"><span class="pre">init</span></tt> y <tt class="docutils literal"><span class="pre">tail</span></tt>, solo que se aplican
recursivamente hasta que no queda nada en la lista. Observa:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">inits</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tails</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">w</span> <span class="ow">=</span> <span class="s">&quot;w00t&quot;</span> <span class="kr">in</span> <span class="n">zip</span> <span class="p">(</span><span class="n">inits</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">tails</span> <span class="n">w</span><span class="p">)</span>
<span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">),(</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">),(</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">),(</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">),(</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Vamos a usar un pliegue para implementar una búsqueda de una sublista
dentro de una lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">search</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">search</span> <span class="n">needle</span> <span class="n">haystack</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">nlen</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">needle</span>
    <span class="kr">in</span>  <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">take</span> <span class="n">nlen</span> <span class="n">x</span> <span class="o">==</span> <span class="n">needle</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="n">tails</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div>
</div>
<p>Primero llamamos a <tt class="docutils literal"><span class="pre">tails</span></tt> con la lista en la que estamos buscando. Luego
recorremos cada cola y vemos si empieza con lo que estamos buscando.</p>
</li>
<li><p class="first">Con esto, en realidad hemos creado una función que se comporta como
<tt class="docutils literal"><span class="pre">isInfixOf</span></tt>. <tt class="docutils literal"><span class="pre">isInfixOf</span></tt> busca una sublista dentro de una lista y
devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt> si la sublista que estamos buscando está en algún lugar
de la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cats&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">isPrefixOf</span></tt> y <tt class="docutils literal"><span class="pre">isInfixOf</span></tt> buscan una sublista desde el principio o
des el final de una lista, respectivamente.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">elem</span></tt> y <tt class="docutils literal"><span class="pre">notElem</span></tt> comprueban si un elemento está dentro de una lista.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">partition</span></tt> toma una lista y un predicado y devuleve una dupla de listas.
La primera lista contiene todos los elementos que satisfacen el predicado,
la segunda todos los que no.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOBMORGAN&quot;</span><span class="p">,</span><span class="s">&quot;sidneyeddy&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>Es importante conocer las diferencias que tiene esta función con <tt class="docutils literal"><span class="pre">span</span></tt> y
<tt class="docutils literal"><span class="pre">break</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOB&quot;</span><span class="p">,</span><span class="s">&quot;sidneyMORGANeddy&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tanto <tt class="docutils literal"><span class="pre">span</span></tt> como <tt class="docutils literal"><span class="pre">break</span></tt> terminan cuando encuentran el primer elemento
que satisface o no satisface el predicado, <tt class="docutils literal"><span class="pre">partition</span></tt> recorre la lista
entera y la va dividiendo según el predicado.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">find</span></tt> toma una lista y un predicado y devuelve el primer elemento que
satisface el predicado. Pero, devuelve el elemento envuelto en un valor
<tt class="docutils literal"><span class="pre">Maybe</span></tt>. Veremos con más detalles los tipos de datos algebraicos en el
siguiente capítulo pero de momento esto es todo lo que necesitas saber: un
valor <tt class="docutils literal"><span class="pre">Maybe</span></tt> puede ser o un <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">algo</span></tt> o <tt class="docutils literal"><span class="pre">Nothing</span></tt>. De la misma
forma que una lista puede ser o una lista vacía o una con elementos, un
valor <tt class="docutils literal"><span class="pre">Maybe</span></tt> puede ser o un elemento o ninguno. Y como el tipo de la
lista dice que, por ejemplo, una lista de enteros es <tt class="docutils literal"><span class="pre">[Int]</span></tt>, el tipo de
un <tt class="docutils literal"><span class="pre">Maybe</span></tt> que contenga un entero es <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt>. De todas formas,
vamos a ver la función <tt class="docutils literal"><span class="pre">find</span></tt> en acción.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">find</span>
<span class="nf">find</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>Fíjate en el tipo de <tt class="docutils literal"><span class="pre">find</span></tt>. Su resultado es del tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. Esto
es parecido a tener algo del tipo <tt class="docutils literal"><span class="pre">[a]</span></tt>, solo que un valor del tipo
<tt class="docutils literal"><span class="pre">Maybe</span></tt> solo puede tener o un elemento o ninguno, mientras que una lista
puede tener ningún elemento, un solo elemento, o varios de ellos.</p>
<p>Recuerda cuando estábamos buscando la primera vez que una acción superaba
los 1000$. Utilizamos <tt class="docutils literal"><span class="pre">head</span> <span class="pre">(dropWhile</span> <span class="pre">(\(val,y,m,d)</span> <span class="pre">-&gt;</span> <span class="pre">val</span> <span class="pre">&lt;</span> <span class="pre">1000)`</span>
<span class="pre">stock</span></tt>. Recuerda también que <tt class="docutils literal"><span class="pre">head</span></tt> no es una función segura. ¿Qué
pasaría si nunca hubiésemos alcanzado los 1000$? <tt class="docutils literal"><span class="pre">dropWhile</span></tt> hubiese
devuelto una lista vacía y aplicar <tt class="docutils literal"><span class="pre">head</span></tt> en una lista vacía solo da un
resultado, un error. Sin embargo, si usamos <tt class="docutils literal"><span class="pre">find</span> <span class="pre">(\(val,y,m,d)</span> <span class="pre">-&gt;</span> <span class="pre">val</span> <span class="pre">&gt;</span>
<span class="pre">1000)</span> <span class="pre">stock</span></tt>, podemos estar mucho más tranquilos. Si nuestras acciones
nunca superan los 1000$ (es decir, ningún elemento satisface el predicado),
obtendremos <tt class="docutils literal"><span class="pre">Nothing</span></tt>, y si sí lo hacen obtendremos una respuesta válida,
como <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1001.4,2008,9,4)</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">elemIndex</span></tt> es parecido a <tt class="docutils literal"><span class="pre">elem</span></tt>, solo que no devuelve un valor
booleano. Quizá devuelva el índice del elemento que estamos buscando. Si
elemento no está en la lista devolverá <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">elemIndex</span>
<span class="nf">elemIndex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">elemIndices</span></tt> es como <tt class="docutils literal"><span class="pre">elemIndex</span></tt>, solo que devuelve una lista de
índices en caso de que el elemento que estamos buscando aparezca varias
veces por la lista. Como estamos usando una lista para representar los
índices, no necesitamos el tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>, ya que el caso de que no se
encuentre nada puede ser representado con la lista vacía, la cual es
sinónimo de <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39; &#39;</span> <span class="p">`</span><span class="n">elemIndices</span><span class="p">`</span> <span class="s">&quot;Where are the spaces?&quot;</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">findIndex</span></tt> es como <tt class="docutils literal"><span class="pre">find</span></tt>, solo que puede devolver el índice del
primer elemento que satisfaga el predicado. <tt class="docutils literal"><span class="pre">findIndices</span></tt> devuelve el
indice de todos los elementos que satisfagan el predicado en forma de
lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndices</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;Where Are The Caps?&quot;</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">Ya hemos hablado de <tt class="docutils literal"><span class="pre">zip</span></tt> y de <tt class="docutils literal"><span class="pre">zipWith</span></tt>. Vimos que estas funciones
combinaban dos listas, ya sea con una dupla o con una función binaria (en
el sentido de que toma dos parámetros) ¿Y si queremos combinar tres listas?
¿O combinar tres listas con una función que toma tres parámetros? Bueno,
para eso tenemos <tt class="docutils literal"><span class="pre">zip3</span></tt>, <tt class="docutils literal"><span class="pre">zip4</span></tt>, etc. y <tt class="docutils literal"><span class="pre">zipWith3</span></tt>, <tt class="docutils literal"><span class="pre">zipWith4</span></tt>,
etc. Estas variantes llegan hasta 7. Esto puede parece algún tipo arreglo,
pero funciona muy bien en la realidad, ya que no hay tantas ocasiones en
las que queramos combinar 8 listas. También existe una forma muy ingeniosa
de combinar un número infinito de listas, pero no hemos avanzado aún lo
suficiente como para explicarlo aquí.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith3</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip4</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div>
</div>
<p>Como las otras funciones, la listas resultantes son tan largas como la
la lista más corta.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">lines</span></tt> es una función muy útil cuando tratamos con algún tipo de
entrada, como ficheros. Toma una cadena y devuelve cada línea de esa cadena
separada en una lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line&quot;</span>
<span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span><span class="s">&quot;second line&quot;</span><span class="p">,</span><span class="s">&quot;third line&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">'\n'</span></tt> es el carácter que representa el salto de línea unix. Las barras
invertidas tienen un significado especial en las cadenas y caracteres de
Haskell.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">unlines</span></tt> es la función inversa de <tt class="docutils literal"><span class="pre">lines</span></tt>. Toma una lista de cadenas
y las une utilizando un <tt class="docutils literal"><span class="pre">'\n'</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unlines</span> <span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span> <span class="s">&quot;second line&quot;</span><span class="p">,</span> <span class="s">&quot;third line&quot;</span><span class="p">]</span>
<span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">words</span></tt> y <tt class="docutils literal"><span class="pre">unwords</span></tt> sirven para separar separar una línea de texto por
palabras. Muy útil.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these are the words in this sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these           are    the words in this</span><span class="se">\n</span><span class="s">sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unwords</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;mate&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there mate&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first">Ya hemos visto antes <tt class="docutils literal"><span class="pre">nub</span></tt>. Toma una lista y elimina los elementos
repetidos, devolviendo una lista en la que cada elemento es único. Esta
función tiene un nombre muy raro. Resulta que <tt class="docutils literal"><span class="pre">nub</span></tt> significa una
pequeña parte o una parte esencial de algo. En mi opinión, creo que
deberían usar nombres reales para las funciones en lugar de palabras
ancestrales.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;Lots of words and stuff&quot;</span>
<span class="s">&quot;Lots fwrdanu&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">delete</span></tt> toma un elemento y una lista y elimina el primer elemento
idéntico de esa lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey there ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere gang!&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">\\</span></tt> es la función división. Funciona como una división basicamente.
Elimina la primera ocurrencia de la lista de la derecha de los elementos
de la lista de la izquierda.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">\\</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Im a big baby&quot;</span> <span class="o">\\</span> <span class="s">&quot;big&quot;</span>
<span class="s">&quot;Im a  baby&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">[1..10]</span> <span class="pre">\\</span> <span class="pre">[2,5,9]</span></tt> es como hacer <tt class="docutils literal"><span class="pre">delete</span> <span class="pre">2</span> <span class="pre">.</span> <span class="pre">delete</span> <span class="pre">5</span> <span class="pre">.</span> <span class="pre">delete</span> <span class="pre">9</span> <span class="pre">$</span>
<span class="pre">[1..10]</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">union</span></tt> funciona como la unión de conjuntos. Devuelve la unión de dos
listas. Básicamente recorre cada elemento de la segunda lista y lo añade
a la primera lista si está aún no lo contenía. Ten cuidado, los duplicados
solo son eliminados de la primera lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey man&quot;</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="s">&quot;man what&#39;s up&quot;</span>
<span class="s">&quot;hey manwt&#39;sup&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">intersect</span></tt> funciona como la intersección de conjuntos. Devuelve los
elementos que están en ambas listas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">intersect</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">insert</span></tt> toma un elemento y una lista que puede ser ordenada e inserta
este elemento en la última posición donde sea menor o igual que el elemento
siguiente. En otras palabras, <tt class="docutils literal"><span class="pre">insert</span></tt> recorrerá la lista hasta que
encuentre un elemento mayor que el elemento que estamos insertando, y lo
insertará antes de dicho elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>El <tt class="docutils literal"><span class="pre">4</span></tt> es insertado justo después del <tt class="docutils literal"><span class="pre">3</span></tt> y antes del <tt class="docutils literal"><span class="pre">5</span></tt> en el
primer ejemplo, y entre <tt class="docutils literal"><span class="pre">3</span></tt> y el <tt class="docutils literal"><span class="pre">4</span></tt> en el segundo.</p>
<p>Si usamos <tt class="docutils literal"><span class="pre">insert</span></tt> para introducir algo en una lista ordenada el
resultado seguirá estando ordenado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="sc">&#39;g&#39;</span> <span class="o">$</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;f&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;h&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</blockquote>
<p>Lo que <tt class="docutils literal"><span class="pre">length</span></tt>, <tt class="docutils literal"><span class="pre">take</span></tt>, <tt class="docutils literal"><span class="pre">drop</span></tt>, <tt class="docutils literal"><span class="pre">splitAt</span></tt>, <tt class="docutils literal"><span class="pre">!!</span></tt> y <tt class="docutils literal"><span class="pre">replicate</span></tt>
tienen en común es que toman un <tt class="docutils literal"><span class="pre">Int</span></tt> como parámetro (o lo devulen),
incluso aunque estas funciones podrían ser más genéricas y útiles si
simplemente tomaran cualquier tipo que fuera parte de las clases de tipos
<tt class="docutils literal"><span class="pre">Integral</span></tt> o <tt class="docutils literal"><span class="pre">Num</span></tt> (dependiendo de las funciones). Lo hacen por mótivos
hístoricos. Probablemente si arreglaran esto dejaría de funcionar mucho código
ya existente. Este es el motivo por el que <tt class="docutils literal"><span class="pre">Data.List</span></tt> tiene sus propias
variantes más genéricas, se llaman <tt class="docutils literal"><span class="pre">genericLength</span></tt>, <tt class="docutils literal"><span class="pre">genericTake</span></tt>,
<tt class="docutils literal"><span class="pre">genericDrop</span></tt>, <tt class="docutils literal"><span class="pre">genericSplitAt</span></tt>, <tt class="docutils literal"><span class="pre">genericIndex</span></tt> y <tt class="docutils literal"><span class="pre">genericReplicate</span></tt>.
Por ejemplo, <tt class="docutils literal"><span class="pre">length</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">length</span> <span class="pre">::</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">Int</span></tt>. Si intentamos
obtener la media de una lista de número usando <tt class="docutils literal"><span class="pre">let</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">[1..6]</span> <span class="pre">in</span> <span class="pre">sum</span> <span class="pre">xs</span> <span class="pre">/</span>
<span class="pre">length</span> <span class="pre">xs</span></tt> obtendremos un error de tipo, ya que no podemos usar <tt class="docutils literal"><span class="pre">/</span></tt> con un
<tt class="docutils literal"><span class="pre">Int</span></tt>. Por otra parte <tt class="docutils literal"><span class="pre">genericLength</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">genericLength</span> <span class="pre">::</span>
<span class="pre">(Num</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">[b]</span> <span class="pre">-&gt;</span> <span class="pre">a</span></tt>. Como <tt class="docutils literal"><span class="pre">Num</span></tt> puede comportarse como un número en coma
flotante, obtener la media haciendo <tt class="docutils literal"><span class="pre">let</span> <span class="pre">xs</span> <span class="pre">=</span> <span class="pre">[1..6]</span> <span class="pre">in</span> <span class="pre">sum</span> <span class="pre">xs</span> <span class="pre">/</span>
<span class="pre">genericLength</span> <span class="pre">xs</span></tt> funciona perfectamente.</p>
<p>Las funciones <tt class="docutils literal"><span class="pre">nub</span></tt>, <tt class="docutils literal"><span class="pre">delete</span></tt>, <tt class="docutils literal"><span class="pre">union</span></tt>, <tt class="docutils literal"><span class="pre">intersect</span></tt> y <tt class="docutils literal"><span class="pre">group</span></tt> tienen
sus repectivas funciones más generales llamadas <tt class="docutils literal"><span class="pre">nubBy</span></tt>, <tt class="docutils literal"><span class="pre">deleteBy</span></tt>,
<tt class="docutils literal"><span class="pre">unionBy</span></tt>, <tt class="docutils literal"><span class="pre">intersectBy</span></tt> y <tt class="docutils literal"><span class="pre">groupBy</span></tt>. La diferencia entre ellas es que
el primer conjunto de funciones usa <tt class="docutils literal"><span class="pre">==</span></tt> para comprobar la igualdad,
mientras que el otro conjunto toman una función de igualdad y comparan
elementos utilizando esta función. <tt class="docutils literal"><span class="pre">group</span></tt> es lo mismo que <tt class="docutils literal"><span class="pre">groupBy</span> <span class="pre">(==)</span></tt>.</p>
<p>Por ejemplo, digamos que tenemos una lista que contiene el valor de una
función para cada segundo. Queremos segmentar la lista en sublistas basandonos
en cuando un valor estaba por debajo de cero y cuando estaba por encima. Si
usaramos un <tt class="docutils literal"><span class="pre">group</span></tt> normal simplemente agruparía lod valores iguales
adyacentes. Pero lo que nosotros queremos es agruparlos según vaya siendo
positivos o no. Aqui es donde entra en juengo <tt class="docutils literal"><span class="pre">groupBy</span></tt>. La función de
igualdad que toman las funciones con el sufijo <tt class="docutils literal"><span class="pre">By</span></tt> deben tomar dos
parámetros del mismo tipo y devolver <tt class="xref docutils literal"><span class="pre">True</span></tt> si consideran que son iguales
por su propio criterio.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">values</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.9</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mf">29.1</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]]</span>
</pre></div>
</div>
<p>De est forma podemos ver claramente que secciones son positivas y cuales
negativas. La función de igualdad que hemos utilizado solo devuleve <tt class="xref docutils literal"><span class="pre">True</span></tt>
cuando los dos valores son positivos o son los dos negativos. Esta función
de igualdad también se puede escribir como <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">||</span> <span class="pre">(x</span>
<span class="pre">&lt;=</span> <span class="pre">0)</span> <span class="pre">&amp;&amp;</span> <span class="pre">(y</span> <span class="pre">&lt;=</span> <span class="pre">0)</span></tt> aunque para mi gusto la primera es más legible. Existe
incluso una forma más clara de escribir funciones de igualdad para estas
funciones si importamos la función <tt class="docutils literal"><span class="pre">on</span></tt> del módulo <tt class="docutils literal"><span class="pre">Data.Function</span></tt>. <tt class="docutils literal"><span class="pre">on</span></tt>
se define como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">on</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que <tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">`on`</span> <span class="pre">(&gt;</span> <span class="pre">0)</span></tt> devuelve una función de igualdad que se
comporta igual que <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">(x</span> <span class="pre">&gt;</span> <span class="pre">0)</span> <span class="pre">==</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">0)</span></tt>. <tt class="docutils literal"><span class="pre">on</span></tt> se utiliza mucho con
todas estas funciones, ya que con ella, podemos hacer cosas como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]]</span>
</pre></div>
</div>
<p>¡Muy legible! Puedes leerlo de golpe: Agrupa esto por igualdad en si los
elementos son mayores que cero.</p>
<p>De forma similar, la funciones <tt class="docutils literal"><span class="pre">sort</span></tt>, <tt class="docutils literal"><span class="pre">insert</span></tt>, <tt class="docutils literal"><span class="pre">maximum</span></tt> y <tt class="docutils literal"><span class="pre">minimum</span></tt>
también tienen sus equivalentes más generales. Fucniones como <tt class="docutils literal"><span class="pre">groupBy</span></tt>
toman funciones que determinan si dos elemento son iguales o no. <tt class="docutils literal"><span class="pre">sortBy</span></tt>,
<tt class="docutils literal"><span class="pre">insertBy</span></tt>, <tt class="docutils literal"><span class="pre">maximumBy</span></tt> y <tt class="docutils literal"><span class="pre">minimumBy</span></tt> toman una función que determina si
si un elemento es mayor, igual o menor que otro. El tipo de <tt class="docutils literal"><span class="pre">sortBy</span></tt> es
<tt class="docutils literal"><span class="pre">sortBy</span> <span class="pre">::</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Ordering)</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></tt>. Si recuerdas, el tipo
<tt class="docutils literal"><span class="pre">Ordering</span></tt> puede tomar los valores <tt class="docutils literal"><span class="pre">GT</span></tt>, <tt class="docutils literal"><span class="pre">EQ</span></tt> y <tt class="docutils literal"><span class="pre">LT</span></tt>. <tt class="docutils literal"><span class="pre">sort</span></tt> es
equivalente a <tt class="docutils literal"><span class="pre">sort</span> <span class="pre">compare</span></tt>, ya que <tt class="docutils literal"><span class="pre">comapare</span></tt> simplemente toma dos
elementos cuyos tipos esten en la clase de tipos <tt class="docutils literal"><span class="pre">Ord</span></tt> y devuelve su relación
de orden.</p>
<p>Las listas pueden ser comparadas por orden lexicográfico ¿Y si tenemos una
lista de listas y no queremos ordenarlas en base al contenido de las listas
interiores sino a sus tamaños? Bueno, como probablemente hayas imaginado, para
eso está la función <tt class="docutils literal"><span class="pre">sortBy</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sortBy</span> <span class="p">(</span><span class="n">compare</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">length</span><span class="p">)</span> <span class="n">xs</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div>
</div>
<p>¡Increíble! <tt class="docutils literal"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">length</span></tt>, eso se lee casi como el inglés real. Si
no estás seguro de como funciona <tt class="docutils literal"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">length</span></tt> aquí, equivalente a
<tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">length</span> <span class="pre">x</span> <span class="pre">`compare`</span> <span class="pre">length</span> <span class="pre">y</span></tt>. Cuando tratamos con funciones que
tienen el sufijo <tt class="docutils literal"><span class="pre">By</span></tt> que toman funciones de igualdad normalmente utilizamos
<tt class="docutils literal"><span class="pre">(==)</span> <span class="pre">`on`</span> <span class="pre">algo</span></tt> y cuando tratamos con las que toman funciones de orden
solemos utilizar <tt class="docutils literal"><span class="pre">compare</span> <span class="pre">`on`</span> <span class="pre">algo</span></tt>.</p>
</div>
<div class="section" id="data-char">
<h2>Data.Char<a class="headerlink" href="#data-char" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="¡Caracteres lego!" class="align-right" src="../images/legochar.png" />
<p>El módulo <tt class="docutils literal"><span class="pre">Data.Char</span></tt> contiene lo que su nombre sugiere. Exporta funciones
que tratan con caracteres. También es útil cuando mapeamos o filtramos
cadenas ya que al fin y al cabo son listas de caracteres.</p>
<p><tt class="docutils literal"><span class="pre">Data.Char</span></tt> exporta un buen puñado de predicados sobre caracteres. Esto es,
funciones que toman un carácter y nos dicen si una suposición acerca de él
es verdadera o falsa. Aquí los tienes:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">isControl</span></tt> comprueba si un carácter es de control o no.</li>
<li><tt class="docutils literal"><span class="pre">isSpace</span></tt> comprueba si un carácter es uno de los caracteres de espacio
en blanco. Eso incluye espacios, tabuladores, saltos de línea, etc.</li>
<li><tt class="docutils literal"><span class="pre">isLower</span></tt> comprueba si un carácter está en minúsculas.</li>
<li><tt class="docutils literal"><span class="pre">isUpper</span></tt> comprueba si un carácter está en mayúsculas.</li>
<li><tt class="docutils literal"><span class="pre">isAlpha</span></tt> comprueba si un carácter es una letra.</li>
<li><tt class="docutils literal"><span class="pre">isAlphaNum</span></tt> comprueba si un carácter es una letra o un número.</li>
<li><tt class="docutils literal"><span class="pre">isPrim</span></tt> comprueba si un carácter es imprimible. Los caracteres de
control, por ejemplo, no lo son.</li>
<li><tt class="docutils literal"><span class="pre">isDigit</span></tt> comprueba si un carácter es un dígito.</li>
<li><tt class="docutils literal"><span class="pre">isOctDigit</span></tt> comprueba si un carácter es un dígito octal.</li>
<li><tt class="docutils literal"><span class="pre">isHexDigit</span></tt> comprueba si un carácter es un dígito hexadecimal.</li>
<li><tt class="docutils literal"><span class="pre">isLetter</span></tt> comprueba si un carácter es una letra.</li>
<li><tt class="docutils literal"><span class="pre">isMark</span></tt> comprueba si un carácter es una marca Unicode. Esto caracteres
que se combinan con sus adyacentes.</li>
<li><tt class="docutils literal"><span class="pre">isNumber</span></tt> comprueba si un carácter numérico.</li>
<li><tt class="docutils literal"><span class="pre">isPunctuation</span></tt> comprueba si un carácter es un signo de puntuación.</li>
<li><tt class="docutils literal"><span class="pre">isSymbol</span></tt> comprueba si un carácter es símbolo matemático o el de una
moneda.</li>
<li><tt class="docutils literal"><span class="pre">isSeparator</span></tt> comprueba si un carácter es un espacio o un separador
Unicode.</li>
<li><tt class="docutils literal"><span class="pre">isAscii</span></tt> comprueba si un carácter es uno de los primeros 128 caracteres
del conjunto de caracteres Unicode.</li>
<li><tt class="docutils literal"><span class="pre">isLatin1</span></tt> comprueba si un carácter es uno de los primeros 256 caracteres
del conjunto de caracteres Unicode.</li>
<li><tt class="docutils literal"><span class="pre">isAsciiUpper</span></tt> comprueba si un carácter está en mayúsculas y además es
ascii.</li>
<li><tt class="docutils literal"><span class="pre">isAsciiLower</span></tt> comprueba si un carácter está en minúsculas y además es
ascii.</li>
</ul>
</blockquote>
<p>Todas estas funciones tienen el tipo <tt class="docutils literal"><span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>. La mayoría de las veces
las usaras para filtrar cadenas o algo parecido. Por ejemplo, digamos que
vamos a hacer un programa que toma un nombre de usuario y dicho nombre solo
puede estar compuesto por caracteres alfanuméricos. Podemos usar la función
<tt class="docutils literal"><span class="pre">all</span></tt> del módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt> para determinar si el nombre es correcto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;bobby283&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;eddy the fish!&quot;</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>En caso de que no te acuerdes, <tt class="docutils literal"><span class="pre">all</span></tt> toma un predicado y devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt>
solo si dicho predicado se cumple para toda la lista.</p>
<p>También podemos utilizar la función <tt class="docutils literal"><span class="pre">isSpace</span></tt> para simular la función
<tt class="docutils literal"><span class="pre">words</span></tt> del módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Mmm... bueno, hace lo mismo que <tt class="docutils literal"><span class="pre">words</span></tt> pero nos dejamos algunos elementos
que contienen un solo espacio ¿Qué podemos hacer? Ya se, vamos a filtrarlos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">any</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">.</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">$</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">Data.Char</span></tt> también exporta un tipo de dato parecido a <tt class="docutils literal"><span class="pre">Ordering</span></tt>. El tipo
<tt class="docutils literal"><span class="pre">Ordering</span></tt> puede tener un valor <tt class="docutils literal"><span class="pre">LT</span></tt>, <tt class="docutils literal"><span class="pre">EQ</span></tt> o <tt class="docutils literal"><span class="pre">GT</span></tt>. Es una especie de
enumeración. Describe una serie de posibles resultados dados al comparar dos
elementos. El tipo <tt class="docutils literal"><span class="pre">GeneralCategory</span></tt> también es una enumeración. Representa
una serie de categorías a las que puede pertenecer un carácter. La función
principal para obtener la categoría de un carácter es <tt class="docutils literal"><span class="pre">generalCategory</span></tt>.
Tiene el tipo <tt class="docutils literal"><span class="pre">generalCategory</span> <span class="pre">::</span> <span class="pre">Char</span> <span class="pre">-&gt;</span> <span class="pre">GeneralCategory</span></tt>. Existen 31
categorías diferentes así que no las vamos a mostrar, pero vamos a jugar un
poco con esta función.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39; &#39;</span>
<span class="kt">Space</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;A&#39;</span>
<span class="kt">UppercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">LowercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;.&#39;</span>
<span class="kt">OtherPunctuation</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;9&#39;</span>
<span class="kt">DecimalNumber</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">generalCategory</span> <span class="s">&quot; </span><span class="se">\t\n</span><span class="s">A9?|&quot;</span>
<span class="p">[</span><span class="kt">Space</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">UppercaseLetter</span><span class="p">,</span><span class="kt">DecimalNumber</span><span class="p">,</span><span class="kt">OtherPunctuation</span><span class="p">,</span><span class="kt">MathSymbol</span><span class="p">]</span>
</pre></div>
</div>
<p>Como <tt class="docutils literal"><span class="pre">GeneralCategory</span></tt> forma parte de la clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt> podemos hacer
cosas como <tt class="docutils literal"><span class="pre">generalCategory</span> <span class="pre">c</span> <span class="pre">==</span> <span class="pre">Space</span></tt>.</p>
<p>Para terminar, aquí tienes unas cuantas funciones que convierten caracteres:</p>
<blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">toUpper</span></tt> convierte un carácter a mayúsculas. Lo espacios, números y todo
lo demás permanece igual.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">toLower</span></tt> convierte un carácter a minúsculas.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">toTitle</span></tt> es similar a <tt class="docutils literal"><span class="pre">toUpper</span></tt> excepto para una pocas letras.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">digitToInt</span></tt> convierte un carácter a un <tt class="docutils literal"><span class="pre">Int</span></tt>. Para que funcione, el
carácter debe estar entre los rangos <tt class="docutils literal"><span class="pre">'0'..'9'</span></tt>, <tt class="docutils literal"><span class="pre">'a'..'f'</span></tt> y
<tt class="docutils literal"><span class="pre">'A'..'F'</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;34538&quot;</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;FF85AB&quot;</span>
<span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">intToDigit</span></tt> es la función inversa de <tt class="docutils literal"><span class="pre">digitToInt</span></tt>. Toma un <tt class="docutils literal"><span class="pre">Int</span></tt> que
este en el rango <tt class="docutils literal"><span class="pre">0..15</span></tt> y lo convierte a un carácter en minúsculas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">15</span>
<span class="sc">&#39;f&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">5</span>
<span class="sc">&#39;5&#39;</span>
</pre></div>
</div>
</li>
<li><p class="first">La función <tt class="docutils literal"><span class="pre">ord</span></tt> y <tt class="docutils literal"><span class="pre">chr</span></tt> convierte caracteres a sus respectivas
representaciones numéricas y viceversa.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ord</span> <span class="sc">&#39;a&#39;</span>
<span class="mi">97</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chr</span> <span class="mi">97</span>
<span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">ord</span> <span class="s">&quot;abcdefgh&quot;</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">]</span>
</pre></div>
</div>
<p>La diferencia entre dos valores de <tt class="docutils literal"><span class="pre">ord</span></tt> de dos caracteres es igual a
la diferencia que existe entre ellos dos en la tabla Unicode.</p>
<p>El cifrado César es un método primitivo para cifrar mensajes desplazando
cada carácter un número fijo de posiciones en el alfabeto. Podemos crear
una especie de cifrado César nosotros mismo, solo que no nos vamos a ceñir
únicamente al alfabeto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">encode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">encode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">ords</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">ord</span> <span class="n">msg</span>
        <span class="n">shifted</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="n">ords</span>
    <span class="kr">in</span>  <span class="n">map</span> <span class="n">chr</span> <span class="n">shifted</span>
</pre></div>
</div>
<p>Primero, convertimos la cadena en una lista de número. Luego, le añadimos
una cantidad constante a cada número y convertimos la lista de números
resultantes en otra cadena de texto. Si te va más la composición, podías
haber hecho lo mismo con <tt class="docutils literal"><span class="pre">map</span> <span class="pre">(chr</span> <span class="pre">.</span> <span class="pre">(+</span> <span class="pre">shift)</span> <span class="pre">.</span> <span class="pre">ord)</span> <span class="pre">msg</span></tt>. Vamos a
probar a codificar unos mensajes.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Khhhhh|&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">4</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Liiiii}&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">1</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;bcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">5</span> <span class="s">&quot;Marry Christmas! Ho ho ho!&quot;</span>
<span class="s">&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;</span>
</pre></div>
</div>
<p>Parece que está bien cifrado. Descifrar un mensaje es básicamente volver a
poner los caracteres desplazados en su lugar.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">decode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">decode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span> <span class="n">encode</span> <span class="p">(</span><span class="n">negate</span> <span class="n">shift</span><span class="p">)</span> <span class="n">msg</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Im a little teapot&quot;</span>
<span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">3</span> <span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="s">&quot;Im a little teapot&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">5</span> <span class="o">.</span> <span class="n">encode</span> <span class="mi">5</span> <span class="o">$</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This is a sentence&quot;</span>
</pre></div>
</div>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="data-map">
<h2>Data.Map<a class="headerlink" href="#data-map" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las listas de asociación (también llamadas diccionarios) son listas que son
utilizadas para almacenar pares clave-valor donde el orden no importa. Por
ejemplo, podemos tener una lista de asociación para almacenar números de
teléfono, donde los números de telefono serían los valores y los nombres de la
gente serían las claves. No nos importa el orden en el que esten almacenados,
solo queremos obtener el número aducuado para cada persona.</p>
<p>La forma más obvia de representar una lista de asociación en Haskell sería
utilizar una lista de duplas. El primer componente de las duplas sería la
clave, y el segundo el valor. Aquí tienes un ejemplo de una lista de
asociación de números de telefono:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>A pesar de que esta alineación extraña, es simplemente un lista de duplas
de cadenas. La tarea más común cuando trabajamos con listas de asociación es
buscar un valor por clave. Vamos a crear una función que busque un valor dada
una clave.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Muy simple. Esta función toma una clave y una lista, filtra la lista de forma
que solo queden claves que coincidan con la clave que se le paso, obtiene el
primer elemento de la lista resultante y luego devuelve el valor asociado.
Pero ¿Qué pasa si la clave que estamos buscando no esta en la lista? Mmm... Si
la clave no está en la lista, acabamos intentando aplicar <tt class="docutils literal"><span class="pre">head</span></tt> en una
lista vacía, por lo que tendremos un error de ejecución. Sin embargo, debemos
evitar que nuestros programas se rompan tan facilmente, así que vamos a usar
el tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Si no encontramos la clave, devolvemos <tt class="docutils literal"><span class="pre">Nothing</span></tt> y en
caso de que la encontremos, devolvemos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">algo</span></tt>, donde algo es el valor
asociado a esa clave.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>
                            <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span>
                            <span class="kr">else</span> <span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Fíjate en la declaración de tipo. Toma una clave que puede ser comparada por
igualdad, una lista de asociación y puede devolver un valor. Suena bien.</p>
<p>Esta es una función recursiva de libro que opera con listas. Caso base,
dividir una lista en cabeza y cola, llamada recursiva... Esto es un pliegue
clásico, asi que vamos a implementarlo con un pliegue.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Normalmente es mejor usar un pligue en estos casos de recursión
estándar sobre listas en lugar de una recursión explícita ya que
resulta más legible y fácil de identificar. Todo el mundo sabe que
se está realizando un pliegue cuando ve una llamada a <tt class="docutils literal"><span class="pre">foldr</span></tt>,
pero toma un poco más de tiempo leer una recursión explícita.</p>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;penny&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;853-2492&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;betty&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;555-2938&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;wilma&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Nothing</span>
</pre></div>
</div>
<img alt="¡Mapa lego!" class="align-left" src="../images/legomap.png" />
<p>¡Funciona perfectamente! Si tenemos el número de una chica obtenemos dicho
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">número</span></tt>, en otro caso obtenemos <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>Acabamos de implementar la función <tt class="docutils literal"><span class="pre">lookup</span></tt> del módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt>. Si
queremos obtener el valor correspondiente a una clave solo tenemos que
recorrer la lista hasta que la encontremos. El módulo <tt class="docutils literal"><span class="pre">Data.Tree</span></tt> ofrece
listas de asociación mucho más eficientes (ya que están implementadas con
árboles) y también ofrece un montón de funciones útiles. De ahora en adelante
diremos que estamos trabajando con diccionarios en lugar de listas de
asociación.</p>
<p>Debido a que <tt class="docutils literal"><span class="pre">Data.Map</span></tt> exporta funciones que colisionan con las de
<tt class="docutils literal"><span class="pre">Prelude</span></tt> y <tt class="docutils literal"><span class="pre">Data.List</span></tt>, lo importaremos de forma cualificada.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
</pre></div>
</div>
<p>Pon esta sentencia en un script y luego cárgalo con GHCi.</p>
<p>Vamos a continuar y ver que tiene <tt class="docutils literal"><span class="pre">Data.Map</span></tt> para nosotros. Aquí tienes un
resumen básico de las funciones.</p>
<blockquote>
<ul>
<li><p class="first">La función <tt class="docutils literal"><span class="pre">fromList</span></tt> tomo una lista de asociación (en forma de lista) y
devuelve un diccionario con las mismas asociaciones.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
<p>En caso de que existan claves duplicadas en la lista de asociación, los
duplicados son descartados. Este es la declaración de tipo de <tt class="docutils literal"><span class="pre">fromList</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
</pre></div>
</div>
<p>Dice que toma una lista de duplas <tt class="docutils literal"><span class="pre">k</span></tt> y <tt class="docutils literal"><span class="pre">v</span></tt> y devuelve un diccionario
que asocia las claves <tt class="docutils literal"><span class="pre">k</span></tt> con los valores <tt class="docutils literal"><span class="pre">v</span></tt>. Fíjate que cuando
creábamos listas de asociación con listas normales, las claves solo tenían
que ser igualables (su tipo pertenecía a la clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt>) pero
ahora tienen que ser ordenables. Esto es básicamente una restricción del
módulo <tt class="docutils literal"><span class="pre">Data.Map</span></tt>. Necesita que las claves sean ordenables para que pueda
organizarlas en un árbol.</p>
<p>Debes utilizar siempre el módulo <tt class="docutils literal"><span class="pre">Data.Map</span></tt> para las asociaciones
clave-valor a no ser que las claves son sean de la clase de tipos <tt class="docutils literal"><span class="pre">Ord</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">empty</span></tt> representa un diccionario vacío. No toma ningún parámetro,
simplemente devuelve un diccionario vacío.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">insert</span></tt> toma una una clave, un valor y un diccionario y devuelve un
nuevo diccionario exactamente igual al anterior, solo que contiene además
la nueva clave-valor.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="p">(</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span>  <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
</pre></div>
</div>
<p>Podemos implementar nuestra propia función <tt class="docutils literal"><span class="pre">fromList</span></tt> usando únicamente
un diccionario vacío, <tt class="docutils literal"><span class="pre">insert</span></tt> y un pliegue. Mira:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fromList&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
<span class="nf">fromList&#39;</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">v</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div>
</div>
<p>Es un pliegue bastante simple. Empezamos con un diccionario vacío y luego
vamos plegando la lista desde la derecha, insertando nuevos pares
clave-valor en el acumulador.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">null</span></tt> comprueba si un diccionario está vacío.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">size</span></tt> nos da el tamaño de un diccionario.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="mi">5</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">singleton</span></tt> toma una clave y un valor y nos devuelve un diccionario que
solo contiene esa clave.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">9</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">lookup</span></tt> funciona como la función <tt class="docutils literal"><span class="pre">lookup</span></tt> de <tt class="docutils literal"><span class="pre">Data.List</span></tt>, solo que
opera con diccionarios en lugar de listas. Devuelve <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">algo</span></tt> si
encuentra la clave o <tt class="docutils literal"><span class="pre">Nothing</span></tt> en caso contrario.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">member</span></tt> es un predicado que toma una clave y un diccionario y nos dice
si dicha clave está contenida en el diccionario.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">map</span></tt> y <tt class="docutils literal"><span class="pre">filter</span></tt> funcionan de forma similar a sus equivales de listas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">400</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">900</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">isUpper</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">toList</span></tt> es la inversa de <tt class="docutils literal"><span class="pre">fromList</span></tt>.</p>
<blockquote>
<p>ghci&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3
[(4,3),(9,2)]</p>
</blockquote>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">keys</span></tt> y <tt class="docutils literal"><span class="pre">elems</span></tt> devuelven una lista con todas la claves o todo los
valores respectivamente. <tt class="docutils literal"><span class="pre">keys</span></tt> es equivalente a <tt class="docutils literal"><span class="pre">map</span> <span class="pre">fst</span> <span class="pre">.</span> <span class="pre">Map.toList</span></tt>
y <tt class="docutils literal"><span class="pre">elems</span></tt> es equivalente a <tt class="docutils literal"><span class="pre">map</span> <span class="pre">snd</span> <span class="pre">.</span> <span class="pre">Map.toList</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">fromListWith</span></tt> es una función muy interesante. Actúa com <tt class="docutils literal"><span class="pre">fromList</span></tt>,
solo que no descarta ningún predicado, en su lugar, utiliza una función que
le pasemos para decidir cual de ellas debe añadirse. Digamos que una chica
puede tener varios números de teléfono y tenemos una lista de asociación
como esta:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;342-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;827-9162&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;555-2111&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>De esta forma si usamos <tt class="docutils literal"><span class="pre">fromList</span></tt> perderemos algunos números. Así que
podemos hacer esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="kt">String</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">number1</span> <span class="n">number2</span> <span class="ow">-&gt;</span> <span class="n">number1</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">number2</span><span class="p">)</span> <span class="n">xs</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;827-9162, 943-2929, 493-2928&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;wendy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;939-8282&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;betty&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;342-2492, 555-2938&quot;</span>
</pre></div>
</div>
<p>En caso de que se encuentre una clave duplicada, la función que pasemos se
encargará de combinar los valores de es clave. También podríamos hacer
primero todos los valores de la lista de asociación listas unitarias y
luego utilizar <tt class="docutils literal"><span class="pre">++</span></tt> para combinar los números.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,[</span><span class="n">v</span><span class="p">]))</span> <span class="n">xs</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="p">[</span><span class="s">&quot;827-9162&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Muy simple. Otro caso sería si estamos creando un diccionario a partir de
una lista de asociación que contiene números y que cuando se encuentra una
clave duplicada, queremos que el valor más grande sea el que se mantenga.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="n">max</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span>
</pre></div>
</div>
<p>O también podríamos haber elegido que estos valores se sumaran:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">108</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">62</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">37</span><span class="p">)]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">insertWith</span></tt> es un <tt class="docutils literal"><span class="pre">insert</span></tt> de la misma forma que <tt class="docutils literal"><span class="pre">fromListWith</span></tt> lo
es para <tt class="docutils literal"><span class="pre">fromList</span></tt>. Inserta una clave-valor en un diccionario, pero si
el diccionario ya contiene dicha clave, usa la función que le pasamos para
determinar que hacer.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insertWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">104</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
</pre></div>
</div>
</li>
</ul>
</blockquote>
<p>Estas son solo algunas de la funciones que contiene <tt class="docutils literal"><span class="pre">Data.Map</span></tt>. Puedes ver
un lista completa de las funciones que contiene en su
<a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs">documentación</a>.</p>
</div>
<div class="section" id="data-set">
<h2>Data.Set<a class="headerlink" href="#data-set" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Conjuntos lego" class="align-right" src="../images/legosets.png" />
<p>El módulo <tt class="docutils literal"><span class="pre">Data.Set</span></tt> nos ofrece operaciones con conjuntos. Conjuntos como
los conjuntos en matemáticas. Los <tt class="docutils literal"><span class="pre">conjuntos</span></tt> son un tipo de datos mezcla
entre las lista y los diccionarios. Todos los elementos de un conjunto son
únicos. Y como internamente son implementados con árboles (como los
diccionarios de <tt class="docutils literal"><span class="pre">Data.Map</span></tt>) están ordenados. Comprobar si existe un
elemento, insertarlo, eliminarlo, etc. es mucho más eficiente que hacerlo con
listas. Las operaciones más comunes cuando trabajamos con conjuntos son
insertar elementos, comprobar si existe un elemento en el conjunto y convertir
un conjunto en una lista.</p>
<p>Como los nombres que exporta <tt class="docutils literal"><span class="pre">Data.Set</span></tt> colisionan con los de <tt class="docutils literal"><span class="pre">Prelude</span></tt> y
<tt class="docutils literal"><span class="pre">Data.List</span></tt> lo importamos de forma cualificada.</p>
<p>Pon esta sentencia en un script:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">Set</span>
</pre></div>
</div>
<p>Y luego carga el script con GHCi.</p>
<p>Digamos que tenemos dos trozos de texto. Queremos saber que caracteres son
usados en ambos trozos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">text1</span> <span class="ow">=</span> <span class="s">&quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;</span>
<span class="nf">text2</span> <span class="ow">=</span> <span class="s">&quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">fromList</span></tt> funciona como es de esperar. Toma una lista y la
convierte en un conjunto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set1</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set2</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot; .?AIRadefhijlmnorstuy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !Tabcdefghilmnorstuvwy&quot;</span>
</pre></div>
</div>
<p>Como puedes ver los elementos están ordenados y cada elemento es único. Ahora
vamos a utilizar la función <tt class="docutils literal"><span class="pre">intersection</span></tt> para ver que elementos están en
ambos conjuntos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">intersection</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; adefhilmnorstuy&quot;</span>
</pre></div>
</div>
<p>Podemos usar la función <tt class="docutils literal"><span class="pre">difference</span></tt> para ver que elementos del primer
conjunto no están en el segundo y viceversa.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot;.?AIRj&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set2</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot;!Tbcgvw&quot;</span>
</pre></div>
</div>
<p>O podemos ver todas letras que fueron utilizadas en ambos textos usando
<tt class="docutils literal"><span class="pre">union</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</span>
</pre></div>
</div>
<p>Las funciones  <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">size</span></tt>, <tt class="docutils literal"><span class="pre">member</span></tt>, <tt class="docutils literal"><span class="pre">empty</span></tt>, <tt class="docutils literal"><span class="pre">singleton</span></tt>,
<tt class="docutils literal"><span class="pre">insert</span></tt> y <tt class="docutils literal"><span class="pre">delete</span></tt> funcionan como esperas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">8</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">delete</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>También se puede consultar por subconjuntos o conjuntos propios. El conjunto A
es un subconjunto de B, si B contiene todos los elementos de A. El conjunto A
es un conjunto propio de B si B contiene todos los elementos que contiene A
y ninguno más.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isProperSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>También podemos usar las funciones <tt class="docutils literal"><span class="pre">map</span></tt> y <tt class="docutils literal"><span class="pre">filter</span></tt> con ellos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Los conjuntos son normalmente utilizados para eliminar los elementos
duplicados de una lista de forma que primero hacemos un conjunto con`
<tt class="docutils literal"><span class="pre">`fromList</span></tt> y luego lo volvemos a convertir en una lista con <tt class="docutils literal"><span class="pre">toList</span></tt>.
La función <tt class="docutils literal"><span class="pre">nub</span></tt> de <tt class="docutils literal"><span class="pre">Data.List</span></tt> ya realiza esta tarea, pero si estas
eliminando duplicados de un gran lista es mucho más eficiente si insertar los
elementos en un conjunto y luego convertirlo en una lista en lugar de utilizar
<tt class="docutils literal"><span class="pre">nub</span></tt>.  Pero <tt class="docutils literal"><span class="pre">nub</span></tt> solo requiere que los elemento de la lista sean de la
clase de tipos <tt class="docutils literal"><span class="pre">Eq</span></tt>, mientras que los elementos de los conjuntos deben ser
de la clase <tt class="docutils literal"><span class="pre">Ord</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">setNub</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">toList</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">setNub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot; ACEHIKLNRSTWY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot;HEY WATSCRKLIN&quot;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">setNub</span></tt> es mucho más rápido que <tt class="docutils literal"><span class="pre">nub</span></tt> para listas grandes, pero como
puedes ver, <tt class="docutils literal"><span class="pre">nub</span></tt> preserva el orden en los que los elementos aparecen en la
lista mientras que <tt class="docutils literal"><span class="pre">setNub</span></tt> no.</p>
</div>
<div class="section" id="creando-nuestros-propios-modulos">
<h2>Creando nuestros propios módulos<a class="headerlink" href="#creando-nuestros-propios-modulos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Creando módulos" class="align-right" src="../images/making_modules.png" />
<p>Hasta ahora hemos visto unos cuantos módulos interesantes, pero ¿Cómo creamos
nuestros propios módulos? Casi todo lenguaje de programación te permite que
dividas tu código en varios ficheros y Haskell no es diferente. Cuando creamos
programas, es una buena práctica que las funciones y tipos que de alguna forma
están relacionados estén en el mismo módulo. De esta forma, podemos fácilmente
reutilizar esas funciones en otros programas importando esos módulos.</p>
<p>Vamos a ver como podemos crear nuestro propio módulo haciendo un pequeño
módulo que exporte funciones que nos permitan calcular el volumen y el área de
unos cuantos objetos geométricos. Empezaremos creando un fichero llamado
<tt class="docutils literal"><span class="pre">Geometry.hs</span></tt>.</p>
<p>Decimos que un módulo exporta unas funciones. Lo que significa que cuando
utilizamos un módulo, podemos ver las funciones que dicho modulo exporta.
Puede definir funciones que son llamadas internamente, pero solo podemos ver
las funciones que exporta.</p>
<p>Especificamos el nombre de un módulo al principio del módulo. Si hemos llamado
al fichero <tt class="docutils literal"><span class="pre">Geometry.hs</span></tt> debemos darle el nombre de <tt class="docutils literal"><span class="pre">Geomtry</span></tt> a nuestro
módulo. Luego, especificamos la funciones que se exportan, y luego comenzamos
a definir dichas funciones. Así que empezamos con esto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>Como observamos, vamos a calcular el área y el volumen de las esferas, cubos y
hexaedros. Continuemos y definamos estas funciones:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">sphereVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereVolume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">sphereArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereArea</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">cubeVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeVolume</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidVolume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cubeArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeArea</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidArea</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cuboidVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidVolume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">cuboidArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidArea</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p>Geometría clásica. Aunque hay un par de cosas que destacar. Como un cubo es un
caso especial de un hexaedro, hemos definido el área y el volumen tratándolo
como un hexaedro con todos sus lados iguales. También hemos definido una
función auxiliar llamada <tt class="docutils literal"><span class="pre">rectangleArea</span></tt>, la cual calcula el área de un
rectángulo basándose en el tamaño de sus lados. Es muy trivial ya que se
trata de una multiplicación. Hemos utilizado esta función en las funciones
<tt class="docutils literal"><span class="pre">cuboidArea</span></tt> y <tt class="docutils literal"><span class="pre">cuboidVolume</span></tt> pero no la hemos exportado. Esto es debido a
que queremos que nuestro módulo solo muestre funciones para tratar estos tres
objetos dimensionales, hemos utilizado <tt class="docutils literal"><span class="pre">rectangleArea</span></tt> pero no la hemos
exportado.</p>
<p>Cuando estamos creando un módulo, normalmente exportamos solo las funciones
que actúan como una especia de interfaz de nuestro módulo de forma que la
implementación se mantenga oculta. Si alguien usa nuestro módulo <tt class="docutils literal"><span class="pre">Geometry</span></tt>,
no nos tenemos que preocupar por funciones las funciones que no exportamos.
Podemos decidir cambiar esas funciones por completo o eliminarlas a cambio
de una nueva versión (podríamos eliminar <tt class="docutils literal"><span class="pre">rectangleArea</span></tt> y utilizar <tt class="docutils literal"><span class="pre">*</span></tt>)
y nadie se daría cuenta ya que no las estamos exportando.</p>
<p>Para utilizar nuestro módulos simplemente usamos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Geometry</span>
</pre></div>
</div>
<p>Aunque <tt class="docutils literal"><span class="pre">Geometry.hs</span></tt> debe estar en el mismo directorio que el programa que
lo está utilizando.</p>
<p>También podemos dar a los módulos una estructura jerárquica. Cada módulo puede
tener cualquier número de submódulos y ellos mismo pueden tener cualquier otro
número de submódulos. Vamos a dividir las funciones del módulo <tt class="docutils literal"><span class="pre">Geometry</span></tt> en
tres submódulos de forma de cada objeto tenga su propio módulo.</p>
<p>Primero creamos un directorio llamado <tt class="docutils literal"><span class="pre">Geometry</span></tt>. Mantén la G en mayúsculas.
Dentro de él crearemos los ficheros <tt class="docutils literal"><span class="pre">sphere.hs</span></tt>, <tt class="docutils literal"><span class="pre">cuboid.hs</span></tt>, y
<tt class="docutils literal"><span class="pre">cube.hs</span></tt>. Este será el contenido de los ficheros:</p>
<p><tt class="docutils literal"><span class="pre">sphere.hs</span></tt></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Geometry.Sphere</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cuboid.hs</span></tt></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Geometry.Cuboid</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">cube.hs</span></tt></p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">Geometry.Cube</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">volume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">area</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>
</pre></div>
</div>
<p>¡Bien! El primero es <tt class="docutils literal"><span class="pre">Geometry.Sphere</span></tt>. Fíjate que primero hemos creado
una carpeta llamada <tt class="docutils literal"><span class="pre">Geometry</span></tt> y luego y luego hemos definido el nombre como
<tt class="docutils literal"><span class="pre">Geometry.Sphere</span></tt>. Hicimos los mismo con el hexaedro. Fíjate también que
en los tres módulos hemos definido funciones con los mismos nombres. Podemos
hacer esto porque están separados en módulos distintos. Queremos utilizar las
funciones de <tt class="docutils literal"><span class="pre">Geometry.Cuboid</span></tt> en <tt class="docutils literal"><span class="pre">Geometry.Cube</span></tt> pero no podemos usar
simplemente <tt class="docutils literal"><span class="pre">import</span> <span class="pre">Geometry.Cuboid</span></tt> ya que importaríamos funciones con el
mismo nombre que en <tt class="docutils literal"><span class="pre">Geometry.Cube</span></tt>. Por este motivo lo cualificamos.</p>
<p>Así que si ahora estamos en un fichero que se encuentra en el mismo lugar
que la carpeta <tt class="docutils literal"><span class="pre">Geometry</span></tt> podemos utilizar:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Geometry.Sphere</span>
</pre></div>
</div>
<p>Y luego podemos utilizar <tt class="docutils literal"><span class="pre">area</span></tt> y <tt class="docutils literal"><span class="pre">volume</span></tt> y nos darán el área y el
volumen de una esfera. Si queremos usar dos o más módulos de éstos, tenemos
que cualificarlos para que no hayan conflictos con los nombres. Podemos usar
algo como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Sphere</span> <span class="k">as</span> <span class="n">Sphere</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cube</span> <span class="k">as</span> <span class="n">Cube</span>
</pre></div>
</div>
<p>Ahora podemos llamar a <tt class="docutils literal"><span class="pre">Sphere.area</span></tt>, <tt class="docutils literal"><span class="pre">Sphere.volume</span></tt>, <tt class="docutils literal"><span class="pre">Cuboid.area</span></tt>,
etc. y cada uno calculará el área o el volumen de su respectivo objeto.</p>
<p>La próxima que te encuentres escribiendo un módulo que es muy grande y tienen
un montón de funciones, trata de encontrar que funciones tienen un propósito
común y luego intenta ponerlas en un mismo módulo. De esta forma, serás capaz
de importar dicho módulo la próxima vez que escribas un programa y requiera la
misma funcionalidad.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="ClasesDeTipos.html" title="Creando nuestros propios tipos y clases de tipos"
             >siguiente</a></li>
        <li class="right" >
          <a href="OrdenSuperior.html" title="Funciones de orden superior"
             >anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Miran Lipovača.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>