
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Un puñado de mónadas &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Unas cuantas mónadas más" href="MasMonadas.html" />
    <link rel="prev" title="Funtores, funtores aplicativos y monoides" href="Funtores.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="MasMonadas.html" title="Unas cuantas mónadas más"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="Funtores.html" title="Funtores, funtores aplicativos y monoides"
             accesskey="P">anterior</a> |</li>
        <li><a href="../main.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="un-punado-de-monadas">
<h1>Un puñado de mónadas<a class="headerlink" href="#un-punado-de-monadas" title="Enlazar permanentemente con este título">¶</a></h1>
<p>La primera vez que hablamos de los funtores, vimos que son un concepto útil
para los valores que se pueden mapear. Luego, llevamos ese concepto un poco
más lejos y vimos los funtores aplicativos, que nos permite ver los valores
de ciertos tipos de datos como una especia de valores con un contexto de forma
que podemos aplicar funciones normales sobre ellos mantenido dicho contexto.</p>
<p>En este capítulos hablaremos de las mónadas, que simplemente son una versión
ampliada de los funtores aplicativos, de la misma forma que los funtores
aplicativos son una versión ampliada de los funtores.</p>
<img alt="¡Más chulo que tú!" class="align-right" src="../_images/smugpig.png" />
<p>Cuando hablamos de los funtores vimos que es era posible mapear funciones
sobre varios tipos de datos. Para lograrlo utilizábamos la clase de tipos
<tt class="docutils literal"><span class="pre">Functor</span></tt>. Dada una función del tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> y un dato del tipo <tt class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></tt>
nos preguntábamos cómo mapeamos esta función sobre el dato de forma que
obtuviésemos un resulto con el tipo <tt class="docutils literal"><span class="pre">f</span> <span class="pre">b</span></tt>. Vimos como mapear funciones sobre
datos del tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>, del tipo <tt class="docutils literal"><span class="pre">[a]</span></tt>, <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></tt>, etc. Incluso vimos
como mapear funciones <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> sobre funciones <tt class="docutils literal"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">a</span></tt> de forma
que el resultado daba funciones del tipo <tt class="docutils literal"><span class="pre">r</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt>. Para contestar a la
pregunta que nos hacíamos de como mapear una función sobre un dato, lo único
que tenemos que hacer es mirar el tipo de <tt class="docutils literal"><span class="pre">fmap</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Y luego hacer que funcione con el tipo de datos para el que estamos creando
la instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt>.</p>
<p>Luego vimos que era posible mejorar los funtores. Decíamos: ¡Hey! ¿qué pasa si
tenemos una función <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> dentro del valor de un funtor? Como por
ejemplo, <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(*3)</span></tt>, y queremos aplicarla a <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">5</span></tt>. ¿Qué pasaría si en
vez de aplicarla a <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">5</span></tt> la aplicamos a <tt class="docutils literal"><span class="pre">Nothing</span></tt>? ¿O si tenemos
<tt class="docutils literal"><span class="pre">[(*2),(+4)]</span></tt> y queremos aplicarla a <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>? ¿Cómo hacemos para que
funcione de forma general? Para ello utilizamos la clase de tipos
<tt class="docutils literal"><span class="pre">Applicative</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>También vimos que podíamos tomar un valor normal e introducirlo dentro de un
tipo de datos. Por ejemplo, podemos tomar un <tt class="docutils literal"><span class="pre">1</span></tt> en introducirlo en un
tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> de forma que resulte en <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">1</span></tt>. O incluso podríamos crear
un <tt class="docutils literal"><span class="pre">[1]</span></tt>. O una acción de E/S que no realizara nada y devolviera un <tt class="docutils literal"><span class="pre">1</span></tt>.
La función que realiza esta acción es <tt class="docutils literal"><span class="pre">pure</span></tt>.</p>
<p>Como ya dijimos, un valor aplicativo puede verse como un valor dentro de un
contexto. Un valor <em>adornado</em> en términos técnicos. Por ejemplo, el carácter
<tt class="docutils literal"><span class="pre">'a'</span></tt> es un simple carácter normal, mientras que <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">'a'</span></tt> tiene añadido
un cierto contexto. En lugar de un <tt class="docutils literal"><span class="pre">Char</span></tt> tenemos un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Char</span></tt>, que nos
dice que su valor puede ser un carácter o bien la ausencia de un carácter.</p>
<p>También es genial ver como la clase de tipos <tt class="docutils literal"><span class="pre">Applicative</span></tt> nos permite
utilizar funciones normales con esos contextos de forma que los contextos
se mantengan. Observa:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (*) &lt;$&gt; Just 2 &lt;*&gt; Just 8</span>
<span class="go">Just 16</span>
<span class="go">ghci&gt; (++) &lt;$&gt; Just &quot;klingon&quot; &lt;*&gt; Nothing</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; (-) &lt;$&gt; [3,4] &lt;*&gt; [1,2,3]</span>
<span class="go">[2,1,0,3,2,1]</span>
</pre></div>
</div>
<p>Estupendo, ahora que los tratamos con valores aplicativos, los valores
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> representan cómputos que pueden fallar, <tt class="docutils literal"><span class="pre">[a]</span></tt> representan
cómputos que tienen varios resultados (cómputos no deterministas), <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></tt>
representan valores que tienen efectos secundarios, etc.</p>
<p>Las mónadas son una extensión natural de los funtores aplicativos y tratan
de resolver lo siguiente: si tenemos un valor en un cierto contexto, <tt class="docutils literal"><span class="pre">m</span> <span class="pre">a</span></tt>,
¿cómo podemos aplicarle una función que toma un valor normal <tt class="docutils literal"><span class="pre">a</span></tt> y devuelve
un valor en un contexto? Es decir, ¿cómo podemos aplicarle una función del
tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></tt>? Básicamente lo que queremos es esta función:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p><strong>Si tenemos un valor adornado y una función que toma un valor y devuelve un
valor adornado, ¿cómo pasamos el primer valor adornado a la función?</strong>. Esta
será la pregunta principal que nos haremos cuando trabajemos con las mónadas.
Escribimos <tt class="docutils literal"><span class="pre">m</span> <span class="pre">a</span></tt> en lugar de <tt class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></tt> ya que <tt class="docutils literal"><span class="pre">m</span></tt> representa mónadas, aunque
las mónadas no son más que funtores aplicativos que soportan la función
<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>. Llamamos <em>lazo</em> a la función <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>.</p>
<p>Cuando tenemos un valor normal <tt class="docutils literal"><span class="pre">a</span></tt> y una función normal <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> es muy
fácil pasar ese valor a la función. Simplemente hay que aplicar la función
a ese valor de forma normal. Pero cuando estamos trabajando con valores que
vienen dentro de un cierto contexto, tenemos que tomarnos un tiempo para
ver como estos valores adornados se pasan a las funciones y para ver como
se comportan. No te preocupes, verás que es muy fácil.</p>
<div class="section" id="manos-a-la-obra-con-maybe">
<h2>Manos a la obra con Maybe<a class="headerlink" href="#manos-a-la-obra-con-maybe" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Mónadas, saltamontes..." class="align-left" src="../_images/buddha.png" />
<p>Ahora que ya tenemos una pequeña idea del cometido de la mónadas, vamos a
expandirla en detalle.</p>
<p>Para sorpresa de nadie, <tt class="docutils literal"><span class="pre">Maybe</span></tt> es una mónada, así que vamos a explorarlo un
poco más a ver si podemos combinar lo que ya sabemos con las mónadas.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Llegados a este punto, asegurate de que entiendes los
<a class="reference internal" href="Funtores.html#aplicativos"><em>funtores aplicativos</em></a>. Será más fácil si sabes
como funcionan varias instancias de <tt class="docutils literal"><span class="pre">Applicative</span></tt> y que tipo
de cómputos representan, ya que las mónadas no son más que una
expasión de los funtores aplicativos.</p>
</div>
<p>Un valor de tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> representa un valor del tipo <tt class="docutils literal"><span class="pre">a</span></tt> dentro del
contexto de que ocurra un posible fallo. Un valor <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">&quot;dharma&quot;</span></tt> representa
que la cadena <tt class="docutils literal"><span class="pre">&quot;dharma&quot;</span></tt> está presente mientras que <tt class="docutils literal"><span class="pre">Nothing</span></tt> representa
su ausencia, o si vemos la cadena como el resultado de un cómputo, significará
que dicho cómputo ha fallado.</p>
<p>Cuando hablamos de <tt class="docutils literal"><span class="pre">Maybe</span></tt> como funtor vimos que cuando mapeamos una
función sobre él con <tt class="docutils literal"><span class="pre">fmap</span></tt>, se mapea solo cuando es un valor <tt class="docutils literal"><span class="pre">Just</span></tt>, de
otro modo <tt class="docutils literal"><span class="pre">Nothing</span></tt> se mantiene como resultado ya que no hay nada sobre lo
que mapear.</p>
<p>Como esto:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; fmap (++&quot;!&quot;) (Just &quot;wisdom&quot;)</span>
<span class="go">Just &quot;wisdom!&quot;</span>
<span class="go">ghci&gt; fmap (++&quot;!&quot;) Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Como funtor aplicativo funciona de forma similar. Sin embargo, los funtores
aplicativos también poseen funciones dentro de los funtores. <tt class="docutils literal"><span class="pre">Maybe</span></tt> es un
funtor aplicativo de forma que cuando aplicamos <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> con una función
contenida en un <tt class="docutils literal"><span class="pre">Maybe</span></tt> a un valor contenido en un <tt class="docutils literal"><span class="pre">Maybe</span></tt>, ambos deben
ser valores <tt class="docutils literal"><span class="pre">Just</span></tt> para que el resultado sea también un valor <tt class="docutils literal"><span class="pre">Just</span></tt>, en
caso contrario el resultado será <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Tiene sentido ya que si no
tenemos o bien la función o bien el valor, no podemos crear un resultado a
partir de la nada, así que hay que propagar el fallo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just (+3) &lt;*&gt; Just 3</span>
<span class="go">Just 6</span>
<span class="go">ghci&gt; Nothing &lt;*&gt; Just &quot;greed&quot;</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; Just ord &lt;*&gt; Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Cuando utilizamos el estilo aplicativo con funciones normales para que actúen
con valores del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> es similar. Todos los valores deben ser
<tt class="docutils literal"><span class="pre">Just</span></tt> si queremos que el resultado también lo sea.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; max &lt;$&gt; Just 3 &lt;*&gt; Just 6</span>
<span class="go">Just 6</span>
<span class="go">ghci&gt; max &lt;$&gt; Just 3 &lt;*&gt; Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Y ahora vamos a ver como podríamos implementar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Como ya
hemos dicho, <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> toma un valor monádico y una función que toma un valor
normal y devuelve otro valor monádico, de forma que aplica esta función al
valor monádico. ¿Cómo consigue hacerlo si la función solo toma valores
normales? Bueno, para lograrlo hay que tomar en cuenta el contexto de ese
valor monádico.</p>
<p>En este caso, <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> tomará un valor con el tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> y una función de
tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">``Maybe</span> <span class="pre">b</span></tt> y de alguna forma aplicará esta función para dar como
resultado <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">b</span></tt>. Para imaginarnos como se hace, podemos apoyarnos en lo
que ya sabemos de los funtores aplicativos. Digamos que tenemos una función
del tipo <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">(x+1)</span></tt>. Toma un número, le añade <tt class="docutils literal"><span class="pre">1</span></tt> y lo introduce
en un <tt class="docutils literal"><span class="pre">Just</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (\x -&gt; Just (x+1)) 1</span>
<span class="go">Just 2</span>
<span class="go">ghci&gt; (\x -&gt; Just (x+1)) 100</span>
<span class="go">Just 101</span>
</pre></div>
</div>
<p>Si le pasaramos como parámetro <tt class="docutils literal"><span class="pre">1</span></tt> devolvería <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">2</span></tt>. Si le pasaramos
<tt class="docutils literal"><span class="pre">100</span></tt> devolvería <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">101</span></tt>. Simple. Ahora viene lo bueno: ¿cómo pasamos
un dato del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> a esta función? Si pensamos en <tt class="docutils literal"><span class="pre">Maybe</span></tt> como un
funtor aplicativo contestar a esta pregunta es bastante fácil. Si le pasamos
un valor <tt class="docutils literal"><span class="pre">Just</span></tt>, toma el valor que contiene y le aplica la función. Si le
pasamos <tt class="docutils literal"><span class="pre">Nothing</span></tt>, mmm, bueno, tenemos la función pero no tenemos nada que
pasarle. En este caso vamos a hacer lo mismo que hicimos anteriormente y
diremos que el resultado será <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>En lugar de llamar a esta función <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, vamos a llamarla <tt class="docutils literal"><span class="pre">applyMaybe</span></tt> por
ahora. Toma un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> y una función que devuelve un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">b</span></tt> y se las
ingenia para aplicar esa función a <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. Aquí está la función:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">applyMaybe</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">applyMaybe</span> <span class="kt">Nothing</span> <span class="n">f</span>  <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">applyMaybe</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>Vale, ahora vamos a jugar un poco con ella. La utilizamos de forma infija  de
forma que el valor <tt class="docutils literal"><span class="pre">Maybe</span></tt> estará en la parte izquierda y la función a
aplicar en la parte derecha:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just 3 `applyMaybe` \x -&gt; Just (x+1)</span>
<span class="go">Just 4</span>
<span class="go">ghci&gt; Just &quot;smile&quot; `applyMaybe` \x -&gt; Just (x ++ &quot; :)&quot;)</span>
<span class="go">Just &quot;smile :)&quot;</span>
<span class="go">ghci&gt; Nothing `applyMaybe` \x -&gt; Just (x+1)</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; Nothing `applyMaybe` \x -&gt; Just (x ++ &quot; :)&quot;)</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>En este ejemplo vemos que cuando utilizamos <tt class="docutils literal"><span class="pre">applyMaybe</span></tt> con un valor
<tt class="docutils literal"><span class="pre">Just</span></tt> y una función, la función simplemente se aplica al valor contenido en
<tt class="docutils literal"><span class="pre">Just</span></tt>. Cuando la utilizamos con un valor <tt class="docutils literal"><span class="pre">Nothing</span></tt>, el resultado final es
<tt class="docutils literal"><span class="pre">Nothing</span></tt>. ¿Qué pasa si la función devuelve un <tt class="docutils literal"><span class="pre">Nothing</span></tt>? Vamos ver:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just 3 `applyMaybe` \x -&gt; if x &gt; 2 then Just x else Nothing</span>
<span class="go">Just 3</span>
<span class="go">ghci&gt; Just 1 `applyMaybe` \x -&gt; if x &gt; 2 then Just x else Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Justo como imaginábamos. Si el valor monádico de la izquierda es <tt class="docutils literal"><span class="pre">Nothing</span></tt>,
el resultado final es <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Y si la función de la derecha devuelve
<tt class="docutils literal"><span class="pre">Nothing</span></tt>, el resultado será de nuevo <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Es muy parecido a cuando
utilizabamos <tt class="docutils literal"><span class="pre">Maybe</span></tt> como funtor aplicativo y obteniamos como resultado
<tt class="docutils literal"><span class="pre">Nothing</span></tt> si en algún lugar había un <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>Parace que para <tt class="docutils literal"><span class="pre">Maybe</span></tt>, hemos averiguado como tomar un valor decorado y
pasarlo a una función que toma un parámetro normal y devuelve otro valor
decorado. Lo hemos conseguido teniendo en cuenta que los valores del tipo
<tt class="docutils literal"><span class="pre">Maybe</span></tt> representan cómputo que pueden fallar.</p>
<p>Seguramente te este preguntado: ¿y esto es útil? Puede parecer que los
funtores aplicativos son más potentes que las mónadas, ya que los funtores
aplicativos permiten tomar una función normal y hacer que opere sobre valores
con un cierto contexto. Veremos que las mónadas pueden hacer exactamente lo
mismo ya que son una versión mejorada de los funtores aplicativos, pero
también veremos que pueden hacer más cosas que los funtores aplicativos no
pueden hacer.</p>
<p>Volvermos con <tt class="docutils literal"><span class="pre">Maybe</span></tt> en un momento, pero primero, vamos a ver la clase de
tipos que define las mónadas.</p>
</div>
<div class="section" id="la-clase-de-tipos-de-las-monadas">
<h2>La clase de tipos de las mónadas<a class="headerlink" href="#la-clase-de-tipos-de-las-monadas" title="Enlazar permanentemente con este título">¶</a></h2>
<p>De la misma forma que los funtores tienen una clase <tt class="docutils literal"><span class="pre">Functor</span></tt> y que los
funtores aplicativos tienen una clase <tt class="docutils literal"><span class="pre">Applicative</span></tt>, las mónadas vienen con
su propia clase de tipos: <tt class="docutils literal"><span class="pre">Monad</span></tt> ¡Wau! ¿Quíen lo hubiera imaginado? Así es
como luce su definición:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>

    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>

    <span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
    <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">y</span>

    <span class="n">fail</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
    <span class="n">fail</span> <span class="n">msg</span> <span class="ow">=</span> <span class="ne">error</span> <span class="n">msg</span>
</pre></div>
</div>
<img alt="Así te ves cuando juegas con las mónadas" class="align-right" src="../_images/kid.png" />
<p>Empecemos por la primera línea. Dice <tt class="docutils literal"><span class="pre">class</span> <span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">where</span></tt>. Pero espera, ¿no
hemos dicho que las mónadas no son más que funtores aplicativos ampliados? ¿No
debería haber una resitricción de clase como
<tt class="docutils literal"><span class="pre">class</span> <span class="pre">(Applicative</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">&gt;</span> <span class="pre">Monad</span> <span class="pre">m</span> <span class="pre">where</span></tt> de forma que el tipo tenga que ser
un funtor aplicativo primero antes de ser una mónada? Bueno, debería, pero
cuando se creo Haskell, la gente que lo creo no pensó que los funtores
aplicativos encajarían bien en Haskell así que no aparece. Pero ten seguro que
cada mónada es un funtor aplicativo, incluso aunque la declaración de la clase
<tt class="docutils literal"><span class="pre">Monad</span></tt> diga lo contrario.</p>
<p>La primera función que define la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt> es <tt class="docutils literal"><span class="pre">return</span></tt>. Es lo
mismo que <tt class="docutils literal"><span class="pre">pure</span></tt> pero con un nombre diferente. Su tipo es
<tt class="docutils literal"><span class="pre">(Monad</span> <span class="pre">m)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">a</span></tt>. Toma un valor y lo introduce en el contexto por
defecto que pueda albergar dicho valor. En otras palabras, toma un valor y lo
introduce en una mónada. Siempre hace lo mismo que la función <tt class="docutils literal"><span class="pre">pueda</span></tt> de la
clase de tipos <tt class="docutils literal"><span class="pre">Applicative</span></tt>, por lo que ya estmos familiarizados al uso
de <tt class="docutils literal"><span class="pre">return</span></tt>. Ya hemos utilizado <tt class="docutils literal"><span class="pre">return</span></tt> cuando trabajamos con la E/S. La
utilizabamos para crear una acción de E/S que no hiciera nada salvo contener
un valor. Con <tt class="docutils literal"><span class="pre">Maybe</span></tt> toma un valor y lo introduce en un valor <tt class="docutils literal"><span class="pre">Just</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Recordatorio: <tt class="docutils literal"><span class="pre">return</span></tt> no se parece en nada al <tt class="docutils literal"><span class="pre">return</span></tt> de la
mayoría de los otro lenguajes de programación. No termina la
ejecución ni nada por el estilo, simplemente toma un valor normal y
lo introduce en un contexto.</p>
</div>
<img alt="¡Sí!" class="align-left" src="../_images/tur2.png" />
<p>La siguiente función es <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> o lazo. Es como la aplicación de funciones,
solo que en lugar de tomar un valor y pasarlo a una función normal, toma un
valor monádico (es decir, un valor en un cierto contexto) y lo pasa a una
función que toma un valor normal pero devuelve otro valor monádico.</p>
<p>A continuación tenemos <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>. No le vamos a prestar mucha ateción ahora mismo
ya que viene con una implementación por defecto y prácticamente nunca
tendremos que implementarla cuando creemos instancias de <tt class="docutils literal"><span class="pre">Monad</span></tt>.</p>
<p>La función final de la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt> es <tt class="docutils literal"><span class="pre">fail</span></tt>. Nunca la
utilizaremos explícitamente en nuestro código. En cambio, Haskell la utilizará
para permitir fallos en una construción sintáctica para las mónadas que
veremos más adelante. No tenemos que preocuparnos demasiado con <tt class="docutils literal"><span class="pre">fail</span></tt> ahora
mismo.</p>
<p>Ahora que ya sabemos como luce la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt>, vamos a ver como
es la instancia de <tt class="docutils literal"><span class="pre">Maybe</span></tt> para la clase <tt class="docutils literal"><span class="pre">Monad</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">x</span>
    <span class="kt">Nothing</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>  <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
    <span class="n">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">return</span></tt> es lo mismo que <tt class="docutils literal"><span class="pre">pure</span></tt>, no hay que pensar mucho. Hacemos
exactamente lo mismo que hacíamos con <tt class="docutils literal"><span class="pre">Applicative</span></tt>, introducimos un valor
en <tt class="docutils literal"><span class="pre">Just</span></tt>.</p>
<p>La función <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es exactamente igual <tt class="docutils literal"><span class="pre">applyMaybe</span></tt>. Cuando le pasamos
un valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> a esta función, tenemos en cuenta el contexto y
devolvemos <tt class="docutils literal"><span class="pre">Nothing</span></tt> si el valor a la izquierda es <tt class="docutils literal"><span class="pre">Nothing</span></tt> ya que no
existe forma posible de aplicar la función con este valor. Si es un valor
<tt class="docutils literal"><span class="pre">Just</span></tt> tomamos lo que hay dentro de él y aplicamos la función.</p>
<p>Podemos probar un poco <tt class="docutils literal"><span class="pre">Maybe</span></tt> como mónada:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return &quot;WHAT&quot; :: Maybe String</span>
<span class="go">Just &quot;WHAT&quot;</span>
<span class="go">ghci&gt; Just 9 &gt;&gt;= \x -&gt; return (x*10)</span>
<span class="go">Just 90</span>
<span class="go">ghci&gt; Nothing &gt;&gt;= \x -&gt; return (x*10)</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Nada nuevo o emocionante en la primera línea ya que ya hemos usado <tt class="docutils literal"><span class="pre">pure</span></tt>
con <tt class="docutils literal"><span class="pre">Maybe</span></tt> y sabemos que <tt class="docutils literal"><span class="pre">return</span></tt> es igual que <tt class="docutils literal"><span class="pre">pure</span></tt> solo que con otro
nombre. La siguientes dos líneas muestran como funciona <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> un poco más.</p>
<p>Fíjate en como hemos pasado <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">9</span></tt> a la función <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">return</span> <span class="pre">(x*10)</span></tt>,
<tt class="docutils literal"><span class="pre">x</span></tt> toma el valor <tt class="docutils literal"><span class="pre">9</span></tt> dentro de la función. Parece como si fueramos
capaces de extraer el valor de un <tt class="docutils literal"><span class="pre">Maybe</span></tt> sin utilizar un ajuste de
patrones. Y aún así no perdemos el contexto de los tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>, porque
cuando es <tt class="docutils literal"><span class="pre">Nothing</span></tt>, el resultado de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> será <tt class="docutils literal"><span class="pre">Nothing</span></tt> también.</p>
</div>
<div class="section" id="en-la-cuerda-floja">
<span id="pierre"></span><h2>En la cuerda floja<a class="headerlink" href="#en-la-cuerda-floja" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Pierre" class="align-left" src="../_images/pierre.png" />
<p>Ahora que ya sabemos como parar un valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> a una función
del tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></tt> teniendo en cuenta el contexto de un posible fallo,
vamos a ver como podemos usar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> repetidamente para manejar varios
valores <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>.</p>
<p>Pierre ha decidido tomar un descanso en su trabajo en la piscifactoria e
intentar caminar por la cuerda floja. No lo hace nada mal, pero tiene un
problema: ¡los pájaros se posan sobre su barra de equilibrio! Aterrizan y se
toman un pequeño respiro, hablan con sus respectivos amigos ovíparos y luego
se marchan en busca de algo de comida. Ha Pierre no le importaría demasiado si
el número de pájaros que se posan en cada lado de la barra fuera el mismo. Sin
embargo, a menudo, todos los pájaros se posan en el mismo lado y desequilibran
a Pierre tirándolo de la cuerda de forma embarazosa (utiliza un red de
seguridad obviamente).</p>
<p>Digamos que matiene el equilibrio si el número de pájaros posados a la
izquierda y a la derecha de la barra no difere en más de tres. Así que si hay
un pájaro en la parte derecha y otros cuatro pájaros en la parte izquierda no
pasa nada. Pero si un quinto pájaro aterriza en la parte derecha pierde el
quilibrio y cae.</p>
<p>Vamos a simular un grupo de pájaros que aterrizan o inician el vuelo desde la
barra y ver si Pierre sigue sobre la barra tras un número de eventos
relacionados con estas aves. Por ejemplo, queremos saber que le pasará a
Pierre si primero llega un pájaro al lado izquierdo de la barra, luego cuatro
pájaros más se posan sobre la parte derecha y luego el pájaro de la izquierda
decide volar de nuevo.</p>
<p>Podemos representar la barra con un par de enteros. El primer componente
indicará el número de pájaros a la izquierda mientras que el segundo indicará
el número de pájaros de la derecha:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Birds</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">Pole</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Birds</span><span class="p">,</span><span class="kt">Birds</span><span class="p">)</span>
</pre></div>
</div>
<p>Primero creamos un sinónimo para <tt class="docutils literal"><span class="pre">Int</span></tt>, llamado <em>pájaros</em> (<tt class="docutils literal"><span class="pre">Birds</span></tt>), ya
que estamos utilizando enteros para representar el número de pájaros. Luego
creamos otro sinónimo de tipos <tt class="docutils literal"><span class="pre">(Birds,</span> <span class="pre">Birds)</span></tt> y lo llamamos <em>barra</em>
(<tt class="docutils literal"><span class="pre">Pole</span></tt>).</p>
<p>A continuación creamos una función que toma un número de pájaros y los posa
sobre un determinado lado de la barra. Aquí están las funciones:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">landLeft</span> <span class="ow">::</span> <span class="kt">Birds</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span>
<span class="nf">landLeft</span> <span class="n">n</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span><span class="n">right</span><span class="p">)</span>

<span class="nf">landRight</span> <span class="ow">::</span> <span class="kt">Birds</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span>
<span class="nf">landRight</span> <span class="n">n</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Bastante simple. Vamos a probarlas:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; landLeft 2 (0,0)</span>
<span class="go">(2,0)</span>
<span class="go">ghci&gt; landRight 1 (1,2)</span>
<span class="go">(1,3)</span>
<span class="go">ghci&gt; landRight (-1) (1,2)</span>
<span class="go">(1,1)</span>
</pre></div>
</div>
<p>Para hacer que los pájaros vuelen simplemente tenmos que pasarles a estas
funciones un número negativo. Como estas funciones devuelven un valor del
tipo <tt class="docutils literal"><span class="pre">Pole</span></tt>, podemos encadenarlas:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; landLeft 2 (landRight 1 (landLeft 1 (0,0)))</span>
<span class="go">(3,1)</span>
</pre></div>
</div>
<p>Cuando aplicamos la función <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">1</span></tt> a <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt> obtenemos <tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">0)</span></tt>.
Luego aterrizamos un pájaro sobre el lado derecho, por lo que obtenemos
<tt class="docutils literal"><span class="pre">(1,</span> <span class="pre">1)</span></tt>. Para terminar aterrizamos dos pájaros más sobre el lado izquierdo,
lo cual resulta en <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">1)</span></tt>. Aplicamos una función a algo escribirendo
primero el nombre de la función y luego sus parámetros, pero en este caso
sería mejor si la barra fuera primero y luego las funciones de aterrizar. Si
creamos una función como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">x</span> <span class="o">-:</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div>
</div>
<p>Podríamos aplicar funciones escribiendo primero el parámetro y luego el nombre
de la función:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; 100 -: (*3)</span>
<span class="go">300</span>
<span class="go">ghci&gt; True -: not</span>
<span class="go">False</span>
<span class="go">ghci&gt; (0, 0) -: landLeft 2</span>
<span class="go">(2,0)</span>
</pre></div>
</div>
<p>Utilizando esto podemos aterrrizar varios pájaros de un forma mucho más
legible:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (0, 0) -: landLeft 1 -: landRight 1 -: landLeft 2</span>
<span class="go">(3,1)</span>
</pre></div>
</div>
<p>¡Genial! Es ejemplo es equivalente al ejemplo anterior en el que
aterrizamos varias aves en la barra, solo que se ve más limpio. Así es más
obvio que empezamos con <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt> y luego aterrizamos un pájaro sobre la
izquierda, otro sobre la derecha y finalmente dos más sobre la izquierda.</p>
<p>Hasta aquí bien, pero, ¿qué sucede si aterrizan diez pájaros sobre un lado?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; landLeft 10 (0,3)</span>
<span class="go">(10,3)</span>
</pre></div>
</div>
<p>¿Diez pájaros en la parte izquierda y solo tres en la derecha? Seguro que
Pierre ya debe estar volando por los aires en esos momentos. En este ejemplo
es bastante obvio pero, ¿y si tenemos una secuencia como esta?:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)</span>
<span class="go">(0,2)</span>
</pre></div>
</div>
<p>A primera vista puede parecer que todo esta bien pero si seguimos los pasos,
veremos que en un determinado momento hay cuatro pájaros a la derecha y
ninguno a la izquierda. Para arreglar esto debemos darle una vuelta de tuerca
a las funciones <tt class="docutils literal"><span class="pre">landLeft</span></tt> y <tt class="docutils literal"><span class="pre">landRight</span></tt>. A partir de lo que hemos
aprendido queremos que estas funciones sean capaces de fallar. Es decir,
queremos que devuelvan una barra si Pierre consigue mantener el equilibrio
pero que fallen en caso de que Pierre lo pierda. ¡Y qué mejor manera de
añadir el contexto de un posible fallo a un valor que utilizar <tt class="docutils literal"><span class="pre">Maybe</span></tt>!
Vamos a reescribir estas funciones:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">landLeft</span> <span class="ow">::</span> <span class="kt">Birds</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">landLeft</span> <span class="n">n</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">abs</span> <span class="p">((</span><span class="n">left</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">right</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">otherwise</span>                    <span class="ow">=</span> <span class="kt">Nothing</span>

<span class="nf">landRight</span> <span class="ow">::</span> <span class="kt">Birds</span> <span class="ow">-&gt;</span> <span class="kt">Pole</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">landRight</span> <span class="n">n</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">abs</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">otherwise</span>                    <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>En lugar de devolver un <tt class="docutils literal"><span class="pre">Pole</span></tt> estas funciones devuelven un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt>.
Siguen tomando el número de pájaros y el estado de la barra anterior, pero
ahora comprueban si el número de pájaros y la posición de estos es suficiente
como para desquilibrar a Pierre. Utilizamos guardas para comprabar si
diferencia entre el número de pájaros en cada lado es menor que cuatro. Si lo
es devuelve una nueva barra dentro de un <tt class="docutils literal"><span class="pre">Just</span></tt>. Si no lo es, devuelven
<tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>Vamos a jugar con estas pequeñas:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; landLeft 2 (0,0)</span>
<span class="go">Just (2,0)</span>
<span class="go">ghci&gt; landLeft 10 (0,3)</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>¡Bien! Cuando aterrizamos pájaros sin que Pierre pierda el equilibrio
obtenemos una nueva barra dentro de un <tt class="docutils literal"><span class="pre">Just</span></tt>. Pero cuando unos cunatos
pájaros de más acaban en un lado de la barra obtenemos <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Esto esta
muy bien pero ahora hemos perido la posibilidad de aterrizar pájaros de forma
repetiva sobre la barra. Ya no podemos usar <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">1</span> <span class="pre">(landRight</span> <span class="pre">1</span> <span class="pre">(0,0))</span></tt>
ya que cuando aplicamos <tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">1</span></tt> a <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt> no obtenemos un <tt class="docutils literal"><span class="pre">Pole</span></tt>,
sino un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt>. <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">1</span></tt> toma un <tt class="docutils literal"><span class="pre">Pole</span></tt> y no un
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt>.</p>
<p>Necesitamos una forma de tomar un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt> y pasarlo a una función que
toma un <tt class="docutils literal"><span class="pre">Pole</span></tt> y devuelve un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt>. Por suerte tenemos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, que
hace exáctamen lo que buscamos para <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Vamos a probarlo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; landRight 1 (0,0) &gt;&gt;= landLeft 2</span>
<span class="go">Just (2,1)</span>
</pre></div>
</div>
<p>Recuerda, <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span></tt> tiene un tipo <tt class="docutils literal"><span class="pre">Pole</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">Pole</span></tt>. No podemos
pasarle directamente un valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Pole</span></tt> que es el resultado de
<tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">1</span> <span class="pre">(0,</span> <span class="pre">0)</span></tt>, así que utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> que toma un valor con un
determinado contexto y se lo pasa a <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span></tt>. De hecho <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> nos
permite tratar valores <tt class="docutils literal"><span class="pre">Maybe</span></tt> como valores en un contexto si pasamos
<tt class="docutils literal"><span class="pre">Nothing</span></tt> a <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span></tt>, de forma que el resultado será <tt class="docutils literal"><span class="pre">Nothing</span></tt> y el
fallo ser propagará:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Nothing &gt;&gt;= landLeft 2</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Gracias a esto ahora podemos encadenar varios aterrizajes que pueden consguir
tirar a Pierre ya que <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> nos permite pasar valores monádicos a funciones
que toman valores normales.</p>
<p>Aquí tienes una secuencia de aterrizajes:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return (0,0) &gt;&gt;= landRight 2 &gt;&gt;= landLeft 2 &gt;&gt;= landRight 2</span>
<span class="go">Just (2,4)</span>
</pre></div>
</div>
<p>Al principio hemos utilizado <tt class="docutils literal"><span class="pre">return</span></tt> para insertar una barra dentro de un
<tt class="docutils literal"><span class="pre">Just</span></tt>. Podríamos haber aplicado <tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">2</span></tt> directamente a <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0),</span>
<span class="pre">hubiéramos</span> <span class="pre">llegado</span> <span class="pre">al</span> <span class="pre">mismo</span> <span class="pre">resultado,</span> <span class="pre">pero</span> <span class="pre">de</span> <span class="pre">esta</span> <span class="pre">forma</span> <span class="pre">podemos</span> <span class="pre">utilizar</span>
<span class="pre">``&gt;&gt;=</span></tt> para cada función de forma más consistente. Se pasa <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,</span> <span class="pre">0)</span></tt> a
<tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">2</span></tt>, lo que devuelve <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,</span> <span class="pre">2)</span></tt>. Luego se le pasa este valor
a <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span></tt> obteniendo <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(2,</span> <span class="pre">2)</span></tt> y así sucesivamente.</p>
<p>Recuerda el ejemplo que dijimos que tiraría a Pierre:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (0,0) -: landLeft 1 -: landRight 4 -: landLeft (-1) -: landRight (-2)</span>
<span class="go">(0,2)</span>
</pre></div>
</div>
<p>Como vemos no simula la interacción con las aves correctamente ya que en medio
la barra ya estaría volando por los aires pero el resultado no lo refleja.
Pero ahora vamos a probar a utilizar la aplicación monádica (<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>) en lugar
de la aplicación normal:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return (0,0) &gt;&gt;= landLeft 1 &gt;&gt;= landRight 4 &gt;&gt;= landLeft (-1) &gt;&gt;= landRight (-2)</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<img alt="Soy un platano" class="align-right" src="../_images/banana.png" />
<p>Perfecto. El resultado final representa un fallo, que es justo lo que
esperamos. Vamos a ver como se consigue este resultado. Primero, <tt class="docutils literal"><span class="pre">return</span></tt>
introduce <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt> en el contexto por defecto, convirtiéndolo en
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,</span> <span class="pre">0)</span></tt>. Luego sucede <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,0)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">landLeft</span> <span class="pre">1</span></tt>. Como
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,0)</span></tt> es un valor <tt class="docutils literal"><span class="pre">Just</span></tt>, <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">1</span></tt> es aplicado a <tt class="docutils literal"><span class="pre">(0,</span> <span class="pre">0)</span></tt>,
obteniendo así <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1,</span> <span class="pre">0)</span></tt> ya que Pierre sigue manteniendo el equilibrio.
Luego nos encontramos con <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1,0)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">landRight</span> <span class="pre">4</span></tt> lo cual resulta en
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1,</span> <span class="pre">4)</span></tt> ya que Pierre sigue manteniendo el equilibrio, aunque
malamente. Se aplica <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">(-1)</span></tt> a <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1,</span> <span class="pre">4)</span></tt>, o dicho de otra
forma, se computa <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">(-1)</span> <span class="pre">(1,4)</span></tt>. Ahora, debido a como funciona
<tt class="docutils literal"><span class="pre">landLeft</span></tt>, esto devuelve <tt class="docutils literal"><span class="pre">Nothing</span></tt> porque nuestro esta volando por los
aires en este mismo momento. Ahora que tenemos <tt class="docutils literal"><span class="pre">Nothing</span></tt> como resultado,
éste se pasado a <tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">(-2),</span> <span class="pre">pero</span> <span class="pre">como</span> <span class="pre">es</span> <span class="pre">un</span> <span class="pre">valor</span> <span class="pre">``Nothing</span></tt>, el
resultado es automáticamente <tt class="docutils literal"><span class="pre">Nothing</span></tt> ya que no existe ningún valor que se
puede aplicar a <tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">(-2)</span></tt>.</p>
<p>No podíamos haber conseguido esto utilizando solo <tt class="docutils literal"><span class="pre">Maybe</span></tt> como funtor
aplicativo. Si lo intentas te quedarás atascado, porque los funtores
aplicativos no permiten que los valores aplicativos interactuen con los
otros lo sufiente. Pueden, como mucho, ser utilizados como parámetros de una
función utilizando el estilo aplicativo. Los operadores aplicativos tomarán
los resultados y se los pasarán a la función de forma apropiada para cada
funto aplicativo y luego obtendrán un valor aplicativo, pero no existe ninguna
interacción entre ellos. Aquí, sin embargo, cada paso depende del resultado
anterior. Por cada aterrizaje se examina el resultado anterior y se comprueba
que la barra está balanceada. Esto determina si el aterrizaje se completará
o fallará.</p>
<p>Podemos divisar una función que ignora el número de pájaros en la barra de
equilibrio y simplemente haga que Pierre caiga. La llamaremos <tt class="docutils literal"><span class="pre">banana</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">banana</span> <span class="ow">::</span> <span class="kt">Pole</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">banana</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>Ahora podemos encadenar esta función con los aterrizajes de las aves. Siempre
hara que Pierre se caiga ya que ignora cualquier cosa que se le pasa y
devuelve un fallo. Compruebalo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return (0,0) &gt;&gt;= landLeft 1 &gt;&gt;= banana &gt;&gt;= landRight 1</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>El valor <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(1,</span> <span class="pre">0)</span></tt> se le pasa a <tt class="docutils literal"><span class="pre">banana</span></tt>, pero este produce
<tt class="docutils literal"><span class="pre">Nothing</span></tt>, lo cual hace que el resultado final sea <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Menuda
suerte.</p>
<p>En lugar de crear funciones que ignoren el resultado y simplemente devuelvan
un valor monádico, podemos utilizar la función <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> cuya implementación por
defecto es esta:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">m</span> <span class="o">&gt;&gt;</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">n</span>
</pre></div>
</div>
<p>Normalmente, si pasamos un valor a una función que toma un parámetro y siempre
devuelve un mismo valor por defecto el resultado será este valor por defecto.
En cambio con la mónadas también debemos conseiderar el contexto y el
siguinificado de éstas. Aquí tienes un ejemplo de como funciona <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> con
<tt class="docutils literal"><span class="pre">Maybe</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Nothing &gt;&gt; Just 3</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; Just 3 &gt;&gt; Just 4</span>
<span class="go">Just 4</span>
<span class="go">ghci&gt; Just 3 &gt;&gt; Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Si reemplazamos <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> por <tt class="docutils literal"><span class="pre">&gt;&gt;=</span> <span class="pre">\_</span> <span class="pre">-&gt;</span></tt> es fácil de ver lo que realmente
sucede.</p>
<p>Podemos cambiar la función <tt class="docutils literal"><span class="pre">banana</span></tt> por <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> y luego un <tt class="docutils literal"><span class="pre">Nothing</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return (0,0) &gt;&gt;= landLeft 1 &gt;&gt; Nothing &gt;&gt;= landRight 1</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Ahí lo tienes, ¡garantizamos que Pierre se va ir al suelo!</p>
<p>También vale la pena echar un vistazo a como se veria esto si no hubiesemos
tratado los valores <tt class="docutils literal"><span class="pre">Maybe</span></tt> como valores en un contexto y no hubiersemos
pasado las parámetros a las funciones como hemos hecho. Así es como se vería
una serie de aterrizajes:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">routine</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">routine</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">landLeft</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="kr">of</span>
    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
    <span class="kt">Just</span> <span class="n">pole1</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">landRight</span> <span class="mi">4</span> <span class="n">pole1</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kt">Just</span> <span class="n">pole2</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">landLeft</span> <span class="mi">2</span> <span class="n">pole2</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="n">pole3</span> <span class="ow">-&gt;</span> <span class="n">landLeft</span> <span class="mi">1</span> <span class="n">pole3</span>
</pre></div>
</div>
<img alt="John Joe Glanton" class="align-right" src="../_images/centaur.png" />
<p>Aterrizamos un pájaro y comprobamos la posibiliadad de que que ocurra un fallo
o no. En caso de fallo devolvemos <tt class="docutils literal"><span class="pre">Nothing</span></tt>. En caso contrario aterrizamos
unos cuantos pájaros más a la derecha y volemos a comprobar lo mismo una y
otra vez. Convertir esto es un limpia concatenación de aplicaciones monádicas
con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es un ejemplo clásico de porque la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt> nos ahorra
mucho tiempo cuando tenemos una secuecnia de cómputos que dependen del
resultado de otros cómputos que pueden fallar.</p>
<p>Fíjate en como la implementación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para <tt class="docutils literal"><span class="pre">Maybe</span></tt> interpreta
exactamente la lógica de que en caso encontrarnos con un <tt class="docutils literal"><span class="pre">Nothing</span></tt>, lo
devolvemos como resultado y en caso contrario continuamos con lo que hay
dentro de <tt class="docutils literal"><span class="pre">Just</span></tt>.</p>
<p>En esta sección hemos tomado varias funciones que ya teniamos y hemos visto
que funcionan mejor si el valor que devuelven soporta fallos. Conviertiendo
estos valores en valores del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> y cambiando la aplicación de
funciones normal por <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> obtenemos un mecanismo para manejar fallos casi
de forma automática, ya que se supone <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> preserva el contexto del valor
que se aplica a una función. En este caso el contexto que tenían estos valores
era la posibiliadad de fallo de forma que cuando aplicábamos funciones sobre
estos valores, la posibilidad de fallo siempre era tomada en cuenta.</p>
</div>
<div class="section" id="la-notacion-do">
<h2>La notación Do<a class="headerlink" href="#la-notacion-do" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las mónadas son tan útiles en Haskell que tienen su propia sintaxis especial
llamada notación <tt class="docutils literal"><span class="pre">do</span></tt>. Ya nos hemos topado con la notación <tt class="docutils literal"><span class="pre">do</span></tt> cuando
reliazabamos acciones de E/S y dijimos que servia para unir varias de estas
acciones en una sola. Bueno, pues resulta que la notación <tt class="docutils literal"><span class="pre">do</span></tt> no solo
funciona con <tt class="docutils literal"><span class="pre">IO</span></tt> sino que puede ser utilizada para cualquier mónada. El
principio sigue siendo el mismo: unir varios valores monádicos en secuencia.
Vamos a ver como funiona la notación <tt class="docutils literal"><span class="pre">do</span></tt> y porque es útil.</p>
<p>Considera el siguiente ejemplo familiar de una aplicación monádica:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just (show x ++ &quot;!&quot;))</span>
<span class="go">Just &quot;3!&quot;</span>
</pre></div>
</div>
<p>Pasamos un valor monádico a una función que devuelve otro valor monádico. Nada
nuevo. Fíjate que en el ejemplo anterior, <tt class="docutils literal"><span class="pre">x</span></tt> se convierte en <tt class="docutils literal"><span class="pre">3</span></tt>, es
decir, una vez dentro de la función lambda, <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">3</span></tt> pasa a ser un valor
normal en vez de un valor monádico. Ahora, ¿qué pasaría si tuviésemos otro
<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> dentro de la función?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just &quot;!&quot; &gt;&gt;= (\y -&gt; Just (show x ++ y)))</span>
<span class="go">Just &quot;3!&quot;</span>
</pre></div>
</div>
<p>¡Wau, un <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> anidado! En la función lambda interior, simplemente pasamos
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">!</span></tt> a <tt class="docutils literal"><span class="pre">\y</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">(show</span> <span class="pre">x</span> <span class="pre">++</span> <span class="pre">y)</span></tt>. Dentro de esta lambda, <tt class="docutils literal"><span class="pre">y</span></tt> se
convierte en <tt class="docutils literal"><span class="pre">&quot;!&quot;</span></tt>. <tt class="docutils literal"><span class="pre">x</span></tt> sigue siendo el <tt class="docutils literal"><span class="pre">3</span></tt> que obtuvimos de la lambda
exterior. Esto se parece a la siguiente expresión:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let x = 3; y = &quot;!&quot; in show x ++ y</span>
<span class="go">&quot;3!&quot;</span>
</pre></div>
</div>
<p>La diferencia principal entre ambas es que los valores de la primera son
valores monádicos. Son valores con el contexto de un posible fallo. Podemos
remplazar cualquier valor por un fallo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Nothing &gt;&gt;= (\x -&gt; Just &quot;!&quot; &gt;&gt;= (\y -&gt; Just (show x ++ y)))</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Nothing &gt;&gt;= (\y -&gt; Just (show x ++ y)))</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; Just 3 &gt;&gt;= (\x -&gt; Just &quot;!&quot; &gt;&gt;= (\y -&gt; Nothing))</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>En la primera línea, pasamos <tt class="docutils literal"><span class="pre">Nothing</span></tt> a una función y naturalmente resulta
en <tt class="docutils literal"><span class="pre">Nothing</span></tt>. En la segunda línea pasamos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">3</span></tt> a la función de forma
que <tt class="docutils literal"><span class="pre">x</span></tt> se convierte en <tt class="docutils literal"><span class="pre">3</span></tt>, pero luego pasamos <tt class="docutils literal"><span class="pre">Nothing</span></tt> a la función
lambda interior así que el resultado es también <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Todo esto es
parecido a ligar nombres con ciertos valores utilizando las expresiones
<tt class="docutils literal"><span class="pre">let</span></tt>, solo que en lugar de valores normales son valores monádicos.</p>
<p>El siguiente ejemplo ilustra esta idea. Vamos a escribir lo mismo solo que
cada valor <tt class="docutils literal"><span class="pre">Maybe</span></tt> esté en una sola línea:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="mi">3</span>   <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span>
      <span class="kt">Just</span> <span class="s">&quot;!&quot;</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span>
      <span class="kt">Just</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)))</span>
</pre></div>
</div>
<p>En lugar de escribir todos estas funciones lambdas, Haskell nos proporciona
la sintaxis <tt class="docutils literal"><span class="pre">do</span></tt> que nos permite escribir el anterior trozo de código como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="nf">foo</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">3</span>
    <span class="n">y</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="s">&quot;!&quot;</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<img alt="Búo de los noventa." class="align-right" src="../_images/owld.png" />
<p>Puede parecer que hemos ganado la habilidad de cosas de valores <tt class="docutils literal"><span class="pre">Maybe</span></tt> sin
tener que preocuparnos por comprobar en cada paso si dichos valores son
valores <tt class="docutils literal"><span class="pre">Just</span></tt> o valores <tt class="docutils literal"><span class="pre">Nothing</span></tt> ¡Genial! Si alguno de los valores que
intentamos extraer es <tt class="docutils literal"><span class="pre">Nothing</span></tt>, la expresión <tt class="docutils literal"><span class="pre">do</span></tt> entera se reducirá a
<tt class="docutils literal"><span class="pre">Nothing</span></tt>. Estamos extrayendo sus (probablemente existentes) valores y
dejamos a <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> que se preocupe por el contexto de dichos valores. Es
importante recordar que la notación <tt class="docutils literal"><span class="pre">do</span></tt> es solo una sintaxis diferente para
encanedar valores monádicos.</p>
<p>En una expresión <tt class="docutils literal"><span class="pre">do</span></tt> cada línea es un valor monádico. Para inspecionar el
resultado de una línea utilizamos <tt class="docutils literal"><span class="pre">&lt;-</span></tt>. Si tenemos un <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></tt> y le
damos una variable utilizando <tt class="docutils literal"><span class="pre">&lt;-</span></tt>, esa variable será del tipo <tt class="docutils literal"><span class="pre">String</span></tt>,
del mismo modo que cuando utilizábamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasar valores monádicos a
las funciones lambda. El último valor monádico de una expresión, en este caso
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(show</span> <span class="pre">x</span> <span class="pre">++</span> <span class="pre">y)</span></tt>, no se puede utilizar junto a <tt class="docutils literal"><span class="pre">&lt;-</span></tt> porque no tendría
mucho sentido traducimos de nuevo la expresión <tt class="docutils literal"><span class="pre">do</span></tt> a una ecandención de
aplicaciones <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>. Esta última línea será el resultado de unir toda la
expresión <tt class="docutils literal"><span class="pre">do</span></tt> en un único valor monádico, teniendo en cuenta el hecho de
que puede ocurrir un fallo en cualquiera de los pasos anteriores.</p>
<p>Por ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just 9 &gt;&gt;= (\x -&gt; Just (x &gt; 8))</span>
<span class="go">Just True</span>
</pre></div>
</div>
<p>Como el parámetro a la izquierda de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es un valor <tt class="docutils literal"><span class="pre">Just</span></tt>, la función
lambda es aplicada a <tt class="docutils literal"><span class="pre">9</span></tt> y el resultado es <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">True</span></tt>. Si reescribimos
esto en notación <tt class="docutils literal"><span class="pre">do</span></tt> obtenemos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">marySue</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Bool</span>
<span class="nf">marySue</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="mi">9</span>
    <span class="kt">Just</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Si comparamos ambas es fácil deducir porque el resultado de toda la expresión
<tt class="docutils literal"><span class="pre">do</span></tt> es el último valor monádico.</p>
<p>La función <tt class="docutils literal"><span class="pre">routine</span></tt> que escribimos anteriormente también puede ser escrita
con una expresión <tt class="docutils literal"><span class="pre">do</span></tt>. <tt class="docutils literal"><span class="pre">landLeft</span></tt> y <tt class="docutils literal"><span class="pre">landRight</span></tt> toman el número de
pájaros y la barra para producir una nueva barra dentro de un valor <tt class="docutils literal"><span class="pre">Just</span></tt>,
a no ser que nuestro funambulista se caiga y produzca <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Utilizamos
<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> porque cada uno de los pasos depende del anterior y cada uno de ellos
tiene el contexto de un posible fallo. Aquí tienes dos pájaros posandose en
lado izquierdo, luego otros dos pájaros posandose en lado derecho y luego
otro más aterrizando en la izquierda:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">routine</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">routine</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">start</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">landLeft</span> <span class="mi">2</span> <span class="n">start</span>
    <span class="n">second</span> <span class="ow">&lt;-</span> <span class="n">landRight</span> <span class="mi">2</span> <span class="n">first</span>
    <span class="n">landLeft</span> <span class="mi">1</span> <span class="n">second</span>
</pre></div>
</div>
<p>Vamos a ver si funciona:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; routine</span>
<span class="go">Just (3,2)</span>
</pre></div>
</div>
<p>¡Lo hace! ¡Genial! Cuando creamos esta función utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>,
utilizábamos cosas como <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(0,0)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">landLeft</span> <span class="pre">2</span></tt>, porque <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span></tt>
es una función que devuelve un valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Sin embargo con las
expresiones <tt class="docutils literal"><span class="pre">do</span></tt>, cada línea debe representar un valor monádico. Así que
tenemos que pasar explícitamente cada <tt class="docutils literal"><span class="pre">Pole</span></tt> anterior a las funciones
<tt class="docutils literal"><span class="pre">landLeft</span></tt> y <tt class="docutils literal"><span class="pre">landRight</span></tt>. Si examinamos las variables a las que ligamos
los valores <tt class="docutils literal"><span class="pre">Maybe</span></tt>, <tt class="docutils literal"><span class="pre">start</span></tt> sería <tt class="docutils literal"><span class="pre">(0,0)</span></tt>, <tt class="docutils literal"><span class="pre">first</span></tt> sería <tt class="docutils literal"><span class="pre">(2,0)</span></tt> y
así sucesivamente.</p>
<p>Debido a que las expresiones <tt class="docutils literal"><span class="pre">do</span></tt> se escriben línea a línea, a mucha gente
le puede parecer código imperativo. Pero lo cierto es que son solo
secuenciales, de forma que cada línea depende del resultado de las líneas
anteriores, junto con sus contextos (en este caso, dependen de si las
anterioeres fallan o no).</p>
<p>De nuevo, vamos a volver a ver como sería este código si no tuvieramos en
cuenta los aspectos monádicos de <tt class="docutils literal"><span class="pre">Maybe</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">routine</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">routine</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="kt">Just</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
        <span class="kt">Just</span> <span class="n">start</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">landLeft</span> <span class="mi">2</span> <span class="n">start</span> <span class="kr">of</span>
            <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
            <span class="kt">Just</span> <span class="n">first</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">landRight</span> <span class="mi">2</span> <span class="n">first</span> <span class="kr">of</span>
                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
                <span class="kt">Just</span> <span class="n">second</span> <span class="ow">-&gt;</span> <span class="n">landLeft</span> <span class="mi">1</span> <span class="n">second</span>
</pre></div>
</div>
<p>Fíjate como en caso de no fallar, la tupla dentro de <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,0)</span></tt> se
convierte en <tt class="docutils literal"><span class="pre">start</span></tt>, el resultado de <tt class="docutils literal"><span class="pre">landLeft</span> <span class="pre">2</span> <span class="pre">start</span></tt> se convierte en
<tt class="docutils literal"><span class="pre">first</span></tt>, etc.</p>
<p>Si queremos lanzar a Pierre una piel de plátano en notación <tt class="docutils literal"><span class="pre">do</span></tt> solo
tenemos que hacer lo siguiente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">routine</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Pole</span>
<span class="nf">routine</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">start</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">landLeft</span> <span class="mi">2</span> <span class="n">start</span>
    <span class="kt">Nothing</span>
    <span class="n">second</span> <span class="ow">&lt;-</span> <span class="n">landRight</span> <span class="mi">2</span> <span class="n">first</span>
    <span class="n">landLeft</span> <span class="mi">1</span> <span class="n">second</span>
</pre></div>
</div>
<p>Cuando escribirmos una línea en la notación <tt class="docutils literal"><span class="pre">do</span></tt> sin ligar el valor monádico
con <tt class="docutils literal"><span class="pre">&lt;-</span></tt>, es como poner <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> después de ese valor monádico cuyo reulstado
queremos que ignore. Secuenciamos el valor monádico pero ignoramos su
resultado ya que no nos importa y es más cómodo que escribir <tt class="docutils literal"><span class="pre">_</span> <span class="pre">&lt;-</span> <span class="pre">Nothing</span></tt>,
que por cierto, es lo mismo.</p>
<p>Cuando utilizar la notación <tt class="docutils literal"><span class="pre">do</span></tt> y cuando utilizar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> depende de ti.
Creo que este ejemplo se expresa mejor escribiendo explícitamente los <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>
ya que cada paso depende específicamente del anterior. Con la notación <tt class="docutils literal"><span class="pre">do</span></tt>
tenemos que especificar en que barra van a aterrizar los pájaros incluso
aunque siempre aterrizen en la barra anterior.</p>
<p>En la notación <tt class="docutils literal"><span class="pre">do</span></tt>, cuando ligamos valore monádicos a variables, podemos
utilizar ajustes de patrones de la misma forma que los usábamos con las
expresiones <tt class="docutils literal"><span class="pre">let</span></tt> o con los parámetros de las funciones. Aquí tienes un
ejemplo de uso de ajuste de patrones dentro de una expresión <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">justH</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Char</span>
<span class="nf">justH</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="s">&quot;hello&quot;</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Hemos ajustado un patrón para obtener el primer carácter de la cadena
<tt class="docutils literal"><span class="pre">&quot;hello&quot;</span></tt> y luego lo devolvemos como resultado. Así que <tt class="docutils literal"><span class="pre">JustH</span></tt> se
evalua a <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">'h'</span></tt>.</p>
<p>¿Qué pasaria si este ajuste fallara? Cuando un ajuste de patrones falla en
una función se utiliza el siguiente ajuste. Si el ajuste falla en todos los
patrones de una función, se lanza un error y el programa podría terminar. Por
otra parte si el ajuste falla en una expresión <tt class="docutils literal"><span class="pre">let</span></tt>, se lanza un error
directamente ya que no existe ningún mecanismo que no lleve a otro patrón que
ajustar. Cuando un ajuste falla dentro de una expresión <tt class="docutils literal"><span class="pre">do</span></tt> se llama a la
función <tt class="docutils literal"><span class="pre">fail</span></tt>. Ésta es parte de la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt> y nos permite
ver este fallo como un fallo en el contexto del valor monádico en lugar de
hacer que el programa termine. Su implementación por defecto es:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fail</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">fail</span> <span class="n">msg</span> <span class="ow">=</span> <span class="ne">error</span> <span class="n">msg</span>
</pre></div>
</div>
<p>Así que por defecto hace que el programa termine, pero las mónadas que
incorporan un contexto para un posible fallo (como <tt class="docutils literal"><span class="pre">Maybe</span></tt>) normalmente
implementan el suyo propio. En <tt class="docutils literal"><span class="pre">Maybe</span></tt> se implementa así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>Ignora el mensaje de error y devuelve <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Así que cuando un ajuste
falla dentro de un valor <tt class="docutils literal"><span class="pre">Maybe</span></tt> que utiliza una expresión <tt class="docutils literal"><span class="pre">do</span></tt>, el valor
entero se reduce a <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Suele ser preferiable a que el programa
termine. Aquí tienes una expresión <tt class="docutils literal"><span class="pre">do</span></tt> con un patrón que no se ajustará y
por tanto fallará:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">wopwop</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Char</span>
<span class="nf">wopwop</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="s">&quot;&quot;</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>El ajuste falla, así que sería igual a remplazar toda la línea por
<tt class="docutils literal"><span class="pre">Nothing</span></tt>. Vamos a probarlo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; wopwop</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Este fallo en el ajuste de un patrón genera un fallo en el contexto de nuestra
mónada en lugar de generar un fallo en el programa, lo cual es muy elegante.</p>
</div>
<div class="section" id="la-monada-lista">
<span id="mlista"></span><h2>La mónada lista<a class="headerlink" href="#la-monada-lista" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Un gato muerto" class="align-left" src="../_images/deadcat.png" />
<p>Hasta ahora hemos visto como los valores del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> pueden verse como
valores en un contexto de un posible fallo y que podemos incorportar el
tratamiento de estos posibles fallos utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasar los
parámetros a las funciones. En esta sección vamos a echar un vistazo a como
podemos utilizar los aspectos monádicos de las listas llevanso así el no
determinsmo a nuestro código de forma legible.</p>
<p>Ya hemos hablado de como las listas representan valores no deterministas
cuando se utilizan como funtores aplicativos. Un valor como <tt class="docutils literal"><span class="pre">5</span></tt> es
determinista. Tiene un único valor y sabemos exactamente cual es. Por otra
parte, un valor como <tt class="docutils literal"><span class="pre">[3,8,9]</span></tt> consiste en varios resultados, así que lo
podemos ver como un valor que en realidad es varios valores al mismo tiempo.</p>
<p>Al utilizar las listas como funtores aplicativos vemos fácilmente este
no determinismo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (*) &lt;$&gt; [1,2,3] &lt;*&gt; [10,100,1000]</span>
<span class="go">[10,100,1000,20,200,2000,30,300,3000]</span>
</pre></div>
</div>
<p>Todas la posibles soluciones de multiplicar los elementos de la izquierda por
los elementos de la derecha aparecen en la lista resultado. Cuando trabajamos
con el no determinismo, exsiten varias opciones que podemos tomar, así que
básicamente probamos todas ellas y por lo tanto el resultado también otro
valor no determinista, solo que con unos cuantos valores más.</p>
<p>Este contexto de no determinismo se translada a las mónadas fácilmente. Vamos
a ver como luce la instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> para las listas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
    <span class="n">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">return</span></tt> es lo mismo que <tt class="docutils literal"><span class="pre">pure</span></tt>, así que ya estamos familiarizados con
ella. Toma un valor y lo introducie en el mínimo contexto por defecto que es
capaz de albergar ese valor. En otras palabras, crea una lista que contiene
como único elemento dicho valor. Resulta útil cuando necesitmos que un valor
determinista interactue con otros valores no deterministas.</p>
<p>Para entender mejor como funciona <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> con las listas veremos un ejemplo de
su uso. <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> toma un valor con un contexto (un valor monádico) y se lo pasa
a una función que toma valores normales y devuelve otro valor en el mismo
contexto. Si esta función devolviera un valor normal en luegar de un valor
monádico, <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> no sería muy útil ya que depués de usarlo perderíamos el
contexto. De cualquier modo, vamos vamos a intentar pasar un valor no
determinista a una función:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [3,4,5] &gt;&gt;= \x -&gt; [x,-x]</span>
<span class="go">[3,-3,4,-4,5,-5]</span>
</pre></div>
</div>
<p>Cuando utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> con <tt class="docutils literal"><span class="pre">Maybe</span></tt>, el valor monádico se pasaba a la
función teniendo en cuenta la existencia de un posible fallo. Aquí <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>
se preocupa del no determinismo por nosotros. <tt class="docutils literal"><span class="pre">[3,4,5]</span></tt> es un valor no
determinista y se lo hemos pasado a otra función que devuelve valores no
deterministas también. El resultado final también es no determinista y
contiene los posibles resultados de aplicar la función <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">[x,-x]</span></tt> a
todos los elementos de <tt class="docutils literal"><span class="pre">[3,4,5]</span></tt>. Esta función toma un número y produce dos
resultados: uno negado y otro igual que el original. De esta forma cuando
utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasar la lista a esta función todos los números son
negados pero también se mantienen los originales. La <tt class="docutils literal"><span class="pre">x</span></tt> de la función
lambda toma todos los posibles valores de la lista que pasamos como parámetro.</p>
<p>Para ver como se consigue este resultado solo tenemos que ver la
implementación. Primero, empezamos con la list <tt class="docutils literal"><span class="pre">[3,4,5]</span></tt>. Luego mapeamos
la función lambda sobre ella y obtenemos el siguiente resultado:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">]]</span>
</pre></div>
</div>
<p>La función lambda se aplica a cada elemento por lo que obtenemos una lista de
listas. Para terminar simplemente concatenamos las listas y punto final
¡Acabamos de aplicar un función no determinista a una valor no determinista!</p>
<p>El no determinismo también soporta la existencia de fallos. La lista vacía
<tt class="docutils literal"><span class="pre">[]</span></tt> es muy parecido a <tt class="docutils literal"><span class="pre">Nothing</span></tt> ya que ambos representan la ausencia de
un resultado. Por este motivo la función <tt class="docutils literal"><span class="pre">fail</span></tt> se define simplemente con
la lista vacía. El mensaje de error se ignora.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [] &gt;&gt;= \x -&gt; [&quot;bad&quot;,&quot;mad&quot;,&quot;rad&quot;]</span>
<span class="go">[]</span>
<span class="go">ghci&gt; [1,2,3] &gt;&gt;= \_ -&gt; []</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>En la primera línea se pasa una lista vacía a la función lambda. Como la lista
no tienen ningún elemento, no podemos pasar nada a la función así que el
resultado final es también la lista vacía. Es similiar a pasar <tt class="docutils literal"><span class="pre">Nothing</span></tt> a
una función. En la segunda línea, cada elemento de la lista se pasa a la
función, pero estos elementos son ignorados y la función simplemente devuelve
una lista vacía. Como la función falla para todos los elementos de la lista,
el resultado final es la lista vacía.</p>
<p>Del mismo modo que pasaba con los valores del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>, podemos
concatenar varios <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> propagando así el no deterministmo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [1,2] &gt;&gt;= \n -&gt; [&#39;a&#39;,&#39;b&#39;] &gt;&gt;= \ch -&gt; return (n,ch)</span>
<span class="go">[(1,&#39;a&#39;),(1,&#39;b&#39;),(2,&#39;a&#39;),(2,&#39;b&#39;)]</span>
</pre></div>
</div>
<img alt="concat . map" class="align-left" src="../_images/concatmap.png" />
<p>Los elemenots de lista <tt class="docutils literal"><span class="pre">[1,2]</span></tt> se ligan a <tt class="docutils literal"><span class="pre">n</span></tt> y los elementos de
<tt class="docutils literal"><span class="pre">['a','b']</span></tt> se ligan a <tt class="docutils literal"><span class="pre">ch</span></tt>. Luego, hacemos <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(n,ch)</span></tt> (o
<tt class="docutils literal"><span class="pre">[(n,ch)]</span></tt>), lo que significa que tomamos una dupla <tt class="docutils literal"><span class="pre">(n,ch)</span></tt> y la
introducimos en el contexto mínimo por defecto. En este caso, se crea la lista
más pequeña posible que pueda albergar <tt class="docutils literal"><span class="pre">(n,ch)</span></tt> como resultado de forma que
posea tan poco no determinismo como sea posible. Dicho de otro modo, el efecto
del contexto es mínimo. Lo que estamos implementando es: para cada elemento
en <tt class="docutils literal"><span class="pre">[1,2]</span></tt> y para cada elemento de <tt class="docutils literal"><span class="pre">['a','b']</span></tt> producimos una dupla para
combinación posible.</p>
<p>En términos generales, como <tt class="docutils literal"><span class="pre">return</span></tt> lo único que hace es introducir un
valor en el contexto mínimo, no posee ningún efecto extra (como devolver un
fallo en <tt class="docutils literal"><span class="pre">Maybe</span></tt> o devolver en un valor aún menos determinista en caso de
las listas) sino que sólamete toma un valor como resultado.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Cuando tenemos varios valores no deterministas interactuando,
podemos ver su cómputo como un árbol donde cada posible resultado
representa una rama del árbol.</p>
</div>
<p>Aquí tienes la expresión anterior escrita con notación <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">listOfTuples</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Char</span><span class="p">)]</span>
<span class="nf">listOfTuples</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ch</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">]</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">ch</span><span class="p">)</span>
</pre></div>
</div>
<p>Así parece más obvio que <tt class="docutils literal"><span class="pre">n</span></tt> toma cada posible valor de <tt class="docutils literal"><span class="pre">[1,2]</span></tt> y que
<tt class="docutils literal"><span class="pre">ch</span></tt> toma cada posible valor de <tt class="docutils literal"><span class="pre">['a','b']</span></tt>. Del mismo modo que con
<tt class="docutils literal"><span class="pre">Maybe</span></tt>, estamos extrayendo valores normales de un valor monádico y dejamos
que <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> se preocupe por el contexto. El contexto en este caso es el
no determinismo.</p>
<p>Cuando vemos las listas utilizando la notación <tt class="docutils literal"><span class="pre">do</span></tt> puede que nos recuerde
a algo que ya hemos visto. Mira esto:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [ (n,ch) | n &lt;- [1,2], ch &lt;- [&#39;a&#39;,&#39;b&#39;] ]</span>
<span class="go">[(1,&#39;a&#39;),(1,&#39;b&#39;),(2,&#39;a&#39;),(2,&#39;b&#39;)]</span>
</pre></div>
</div>
<p>¡Sí! ¡Listas por comprensión! Cuando utilizábamos la notación <tt class="docutils literal"><span class="pre">do</span></tt>, <tt class="docutils literal"><span class="pre">n</span></tt>
tomaba cada posible elemento de <tt class="docutils literal"><span class="pre">[1,2]</span></tt> y <tt class="docutils literal"><span class="pre">ch</span></tt> tomaba cada posible
elemento de <tt class="docutils literal"><span class="pre">['a','b']</span></tt> y luego introducíamos <tt class="docutils literal"><span class="pre">(n,ch)</span></tt> en el contexto por
defecto (una lista unitaria) para devolverlo como resultado final sin tener
que introducir ningún tipo de no determinismo adicional. En esta lista por
comprensión hacemos exactamente lo mismo, solo que no tenemos que escribir
<tt class="docutils literal"><span class="pre">return</span></tt> al final para dar como resultado <tt class="docutils literal"><span class="pre">(n,ch)</span></tt> ya que la lista por
comprensión se encarga de hacerlo.</p>
<p>De hecho, las listas por comprensión no son más que una alternativa sintáctica
al uso de listas como mónadas. Al final, tanto las listas por comprensión como
la notación <tt class="docutils literal"><span class="pre">do</span></tt> se traduce a una concatenación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> que representan
el no determinismo.</p>
<p>Las listas por comprensión nos perminten filtrar la lista. Por ejemplo,
podemos filtrar una lista de número para quedarnos únicamente con los números
que contengan el dígito <tt class="docutils literal"><span class="pre">7</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [ x | x &lt;- [1..50], &#39;7&#39; `elem` show x ]</span>
<span class="go">[7,17,27,37,47]</span>
</pre></div>
</div>
<p>Aplicamos <tt class="docutils literal"><span class="pre">show</span></tt> a <tt class="docutils literal"><span class="pre">x</span></tt> para convertir el número en una cadena y luego
comprobamos si el carácter <tt class="docutils literal"><span class="pre">'7'</span></tt> froma parte de en esa cadena. Muy
ingenioso. Para comprender como se traduce estos filtros de las listas por
comprensión a la mónada lista tenemos que ver la función <tt class="docutils literal"><span class="pre">guard</span></tt> y la clase
de tipos <tt class="docutils literal"><span class="pre">MonadPlus</span></tt>. La clase de tipos <tt class="docutils literal"><span class="pre">MonadPlus</span></tt> representa mónadas
que son también monoides. Aquí tienes la definición:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadPlus</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">mzero</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span>
    <span class="n">mplus</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">mzero</span></tt> es un sinónimo del <tt class="docutils literal"><span class="pre">mempty</span></tt> que nos encontramos en la clase
<tt class="docutils literal"><span class="pre">Monoid</span></tt> y <tt class="docutils literal"><span class="pre">mplus</span></tt> correponde con <tt class="docutils literal"><span class="pre">mappend</span></tt>. Como las listas también
son monoides a la vez que mónadas podemos crear una isntancia para esta
clase de tipos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">MonadPlus</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">mzero</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="n">mplus</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>
</pre></div>
</div>
<p>Para las listas <tt class="docutils literal"><span class="pre">mzero</span></tt> representa un cómputo no determinista que no
devuelve ningún resultado, es decir un cómputo que falla. <tt class="docutils literal"><span class="pre">mplus</span></tt> une dos
valores no deterministas en uno. La función <tt class="docutils literal"><span class="pre">guard</span></tt> se define así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">guard</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">True</span> <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">False</span> <span class="ow">=</span> <span class="n">mzero</span>
</pre></div>
</div>
<p>Toma un valor booleano y si es <tt class="xref docutils literal"><span class="pre">True</span></tt>, introduce <tt class="docutils literal"><span class="pre">()</span></tt> en el mínimo
contexto por defecto. En caso contrario devuleve un valor monádico que
representa un fallo. Aquí la tienes en acción:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; guard (5 &gt; 2) :: Maybe ()</span>
<span class="go">Just ()</span>
<span class="go">ghci&gt; guard (1 &gt; 2) :: Maybe ()</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; guard (5 &gt; 2) :: [()]</span>
<span class="go">[()]</span>
<span class="go">ghci&gt; guard (1 &gt; 2) :: [()]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Parece interesante pero, ¿es útil? En la mónada lista utilizamos esta función
para filtrar una series de cómputos no deterministas. Observa:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [1..50] &gt;&gt;= (\x -&gt; guard (&#39;7&#39; `elem` show x) &gt;&gt; return x)</span>
<span class="go">[7,17,27,37,47]</span>
</pre></div>
</div>
<p>El resultado es el mismo que la lista por comprensión anterior. ¿Cómo
consigue <tt class="docutils literal"><span class="pre">guard</span></tt> este resultado? Primero vamos a ver se utiliza <tt class="docutils literal"><span class="pre">guard</span></tt>
junto a <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; guard (5 &gt; 2) &gt;&gt; return &quot;cool&quot; :: [String]</span>
<span class="go">[&quot;cool&quot;]</span>
<span class="go">ghci&gt; guard (1 &gt; 2) &gt;&gt; return &quot;cool&quot; :: [String]</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>Si el predicado de <tt class="docutils literal"><span class="pre">guard</span></tt> se satisface, el resultado es una lista con una
tupla vacía. Luego utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> para ignorar esta tupla vacía y devolver
otra cosa como resultado. Sin embargo, si <tt class="docutils literal"><span class="pre">guard</span></tt> falla, no alcanzaremos
el <tt class="docutils literal"><span class="pre">return</span></tt> ya que si pasamos una lista vacía a una funcón con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> el
resultado siempre será una lista vacía. <tt class="docutils literal"><span class="pre">guard</span></tt> simplemente dice: si el
predicado es <tt class="xref docutils literal"><span class="pre">False</span></tt> entonces devolvemos un fallo, en caso contrario
devolvemos un valor que contiene un resultado ficticio <tt class="docutils literal"><span class="pre">()</span></tt>. Esto permite
que el encadenamiento continue.</p>
<p>Así sería el ejemplo anterior utilizando la notación <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">sevensOnly</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">sevensOnly</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">50</span><span class="p">]</span>
    <span class="n">guard</span> <span class="p">(</span><span class="sc">&#39;7&#39;</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">show</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Si hubiéramos olvidado devolver <tt class="docutils literal"><span class="pre">x</span></tt> como resultado final con <tt class="docutils literal"><span class="pre">return</span></tt>, la
lista resultante sería una lista de tuplas vacías en lugar de una lista de
enteros. Aquí tienes de nuevo la lista por comprensión para que compares:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [ x | x &lt;- [1..50], &#39;7&#39; `elem` show x ]</span>
<span class="go">[7,17,27,37,47]</span>
</pre></div>
</div>
<p>Filtrar una lista por comprensión es igual que usar <tt class="docutils literal"><span class="pre">guard</span></tt>.</p>
<div class="section" id="el-salto-del-caballo">
<h3>El salto del caballo<a class="headerlink" href="#el-salto-del-caballo" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Vamos a ver un problema que tiende a resolverse utilizando no determinismo.
Digamos que tenemos un tablero de ajedrez y como única pieza un caballo.
Queremos saber si el caballo peude alcanzar una determinada posición en tres
movimientos. Utilizaremos una dupla de números para representar la posición
del caballo en el tablero. El primer número representará la columna en la que
está el caballo y el segundo representará la fila.</p>
<img alt="¡Soy un caballo!" class="align-center" src="../_images/chess.png" />
<p>Vamos a crear un sinónimo de tipo para representar la posición actual del
caballo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">KnightPos</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span>
</pre></div>
</div>
<p>Digamos que el caballo empieza en <tt class="docutils literal"><span class="pre">(6,2)</span></tt> ¿Puede alcanzar <tt class="docutils literal"><span class="pre">(6,1)</span></tt> en solo
tres movimientos? Vamos a ver. Si empezamos en <tt class="docutils literal"><span class="pre">(6,2)</span></tt>, ¿cuál sería el mejor
movimiento a realizar? Ya se, ¡Todos! Tenemos el no determinismo a nuestra
disposición, así que en lugar de decidirnos por un movimiento, hagámoslos
todos. Aquí tienes una función que toma la posición del caballo y devuelve
todos las posibles posiciones en las que se encontrará depués de moverse.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">moveKnight</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">KnightPos</span><span class="p">]</span>
<span class="nf">moveKnight</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">c&#39;</span><span class="p">,</span><span class="n">r&#39;</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">[(</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
               <span class="p">,(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
               <span class="p">]</span>
    <span class="n">guard</span> <span class="p">(</span><span class="n">c&#39;</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">r&#39;</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">])</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">c&#39;</span><span class="p">,</span><span class="n">r&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>El caballo puede tomar un paso en horizontal o vertical y otros dos pasos
en horizontal o vertical pero siempre haciendo un movimiento horizontal y otro
vertical. <tt class="docutils literal"><span class="pre">(c',r')</span></tt> toma todos los valores de los elementos de la lista y
luego <tt class="docutils literal"><span class="pre">guard</span></tt> se encarga de comprobar que la nueva posicion permanece dentro
del tablero. Si no lo está, produce una lista vacía y por lo tanto no se
alcanza <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(c',r')</span></tt> para esa posición.</p>
<p>También se puede escribir esta función sin hacer uso de la mónada lista,
aunque lo acabamos de hacer solo por diversión. Aquí tienes la misma función
utilizando <tt class="docutils literal"><span class="pre">filter</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">moveKnight</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">KnightPos</span><span class="p">]</span>
<span class="nf">moveKnight</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">onBoard</span>
    <span class="p">[(</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">,(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">-</span><span class="mi">2</span><span class="p">),(</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="kr">where</span> <span class="n">onBoard</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p>Ambas son iguales, así que elige la que creas mejor. Vamos a probarla:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; moveKnight (6,2)</span>
<span class="go">[(8,1),(8,3),(4,1),(4,3),(7,4),(5,4)]</span>
<span class="go">ghci&gt; moveKnight (8,1)</span>
<span class="go">[(6,2),(7,3)]</span>
</pre></div>
</div>
<p>¡Funciona perfectamente! Toma una posición y devuelve todas las siguientes
posiciones de golpe. Así que ahora que tenemos la siguiente
posición de forma no determinista, solo tenemos que aplicar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para
pasársela a <tt class="docutils literal"><span class="pre">moveKnight</span></tt>. Aquí tienes una función que toma una posición y
devuelve todas las posiciones que se pueden alcanzar en tres movimientos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">in3</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">KnightPos</span><span class="p">]</span>
<span class="nf">in3</span> <span class="n">start</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">moveKnight</span> <span class="n">start</span>
    <span class="n">second</span> <span class="ow">&lt;-</span> <span class="n">moveKnight</span> <span class="n">first</span>
    <span class="n">moveKnight</span> <span class="n">second</span>
</pre></div>
</div>
<p>Si le pasamos <tt class="docutils literal"><span class="pre">(6,2)</span></tt>, el resultado será un poco grande porque si existe
varias formas de llegar a la misma posición en tres movimientos, tendremos
varios elementos repetidos. A continuación sin usar la notación <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">in3</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">start</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span>
</pre></div>
</div>
<p>Al utiliza <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> obtenemos todos los posibles movimientos desde el inicio y
luego cuando utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> por segunda vez, para cada posible primer
movimiento calculamos cada posible siguiente movimiento. Lo mismo sucede para
el tercer movimiento.</p>
<p>Introducir un valor en el contexto por defecto utilizando <tt class="docutils literal"><span class="pre">return</span></tt> para
luego pasarlo como parámetro utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es lo mismo que aplicar
normalemente la función a dicho valor, aunque aquí lo hemos hecho de todas
formas.</p>
<p>Ahora vamos a crear una función que tome dos posiciones y nos diga si la
última posición puede ser alcanzada con exáctamente tres pasos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">canReachIn3</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">canReachIn3</span> <span class="n">start</span> <span class="n">end</span> <span class="ow">=</span> <span class="n">end</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">in3</span> <span class="n">start</span>
</pre></div>
</div>
<p>Generamos todas las posibles soluciones que se pueden generar con tres pasos
y luego comprobamos si la posición destino se encuentra dentro de estas
posibles soluciones. Vamos a ver si podemos alcanzar <tt class="docutils literal"><span class="pre">(6,1)</span></tt> desde <tt class="docutils literal"><span class="pre">(6,2)</span></tt>
en tres movimientos:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (6,2) `canReachIn3` (6,1)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>¡Sí! ¿Y de <tt class="docutils literal"><span class="pre">(6,2)</span></tt> a <tt class="docutils literal"><span class="pre">(7,3)</span></tt>?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (6,2) `canReachIn3` (7,3)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>¡No! Como ejercicio, puedes intentar modificar esta función para que cuando
se pueda alcanzar esta posición te diga que pasos debes seguir. Luego, veremos
como modificar esta función de forma que también pasemos como parámetro el
número de pasos.</p>
</div>
</div>
<div class="section" id="las-leyes-de-las-monadas">
<h2>Las leyes de las mónadas<a class="headerlink" href="#las-leyes-de-las-monadas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="El jurado te declara culpable de mearte por todas partes." class="align-right" src="../_images/judgedog.png" />
<p>De la misma forma que lo funtores aplicativos, a la vez que lo funtores
normales, las mónadas vienen con una serie de leyes que todas las mónadas que
se precien deben cumplir. Solo porque algo tenga una instancia de la clase
<tt class="docutils literal"><span class="pre">Monad</span></tt> no significa que sea una mónada, solo significa que ese algo tiene
una instancia para la clase <tt class="docutils literal"><span class="pre">Monad</span></tt>. Para que un tipo sea realmente una
mónada debe satisfacer las leyes. Estas leyes nos permiten asumir muchas cosas
acerca del comportamiento del tipo.</p>
<p>Haskell permite que cualquier tipo tenga una instancia de cualquier clase de
tipos siempre que los tipos concuerden. No puede comprobar si las leyes de las
mónadas se cumplen o no, así que si estamos creando una instancia para la
clase <tt class="docutils literal"><span class="pre">Monad</span></tt>, tenemos que estar lo suficientemente seguros de que la mónada
satisface las leyes para ese tipo. Los estar seguros de que los tipos que
vienen en la biblioteca estándar cumplen estas leyes, pero luego, cuando
creemos nuestras própias mónadas, tendremos que comprobar manualmente si se
cumplen las leyes o no. No te asuste, no son complicadas.</p>
<div class="section" id="identidad-por-la-izquierda">
<h3>Identidad por la izquierda<a class="headerlink" href="#identidad-por-la-izquierda" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La primera ley establece que tomamos un valor, lo introducimos en el contexto
por defecto utilizando <tt class="docutils literal"><span class="pre">return</span></tt> y luego pasamos el resultado a una función
utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, el resultado debe ser igual que aplicar la función
directamente a ese valor. Informalmente:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref js js-data docutils literal"><span class="pre">return</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></tt> es exactamente lo mismo que <tt class="xref js js-data docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>.</li>
</ul>
</div></blockquote>
<p>Si vemos los valores monádicos como valores con un cierto contexto y
<tt class="docutils literal"><span class="pre">return</span></tt> toma un valor y lo introduce en el contexto mínimo por defecto que
puede albergar ese valor, tiene sentido que, como ese contexto en realidad es
mínimo, al pasar el valor monádico a una función no debe haber mucha
diferencia con aplicar la función a un valor normal, y de hecho, es
exactamente lo mismo.</p>
<p>Para la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt>, <tt class="docutils literal"><span class="pre">return</span></tt> se define como <tt class="docutils literal"><span class="pre">Just</span></tt>. La mónada
<tt class="docutils literal"><span class="pre">Maybe</span></tt> trata acerca de posibles fallos, así que si tenemos un valor y lo
introducimos en dicho contexto, tiene sentido tratar este valor como
cómputo correcto, ya que, bueno, sabemos cual es ese valor. Aquí tienes un par
de usos de <tt class="docutils literal"><span class="pre">return</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return 3 &gt;&gt;= (\x -&gt; Just (x+100000))</span>
<span class="go">Just 100003</span>
<span class="go">ghci&gt; (\x -&gt; Just (x+100000)) 3</span>
<span class="go">Just 100003</span>
</pre></div>
</div>
<p>En cambio para la mónada lista, <tt class="docutils literal"><span class="pre">return</span></tt> intruce un valor en una lista
unitaria. La implementación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para las listas recorre todos los
elementos de la lista y les aplica una función, pero como solo hay un elemento
en la lista, es lo mismo que aplicar la función a ese valor:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return &quot;WoM&quot; &gt;&gt;= (\x -&gt; [x,x,x])</span>
<span class="go">[&quot;WoM&quot;,&quot;WoM&quot;,&quot;WoM&quot;]</span>
<span class="go">ghci&gt; (\x -&gt; [x,x,x]) &quot;WoM&quot;</span>
<span class="go">[&quot;WoM&quot;,&quot;WoM&quot;,&quot;WoM&quot;]</span>
</pre></div>
</div>
<p>Dijimos que para la mónada <tt class="docutils literal"><span class="pre">IO</span></tt>, <tt class="docutils literal"><span class="pre">return</span></tt> simplemente creaba una acción
que no tenia ningún efecto secundario y solo albergaba el valor que pasábamos
como parámetro. Así que también cumple esta ley.</p>
</div>
<div class="section" id="identidad-por-la-derecha">
<h3>Identidad por la derecha<a class="headerlink" href="#identidad-por-la-derecha" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La segunda ley establece que si tenemos un valor monádico y utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>
para pasarselo a <tt class="docutils literal"><span class="pre">return</span></tt>, el resultado debe ser el valor monádico original.
Formalemente:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref js js-data docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span></tt> es igual que <tt class="xref js js-data docutils literal"><span class="pre">m</span></tt>.</li>
</ul>
</div></blockquote>
<p>Esta ley puede parecer un poco menos obvia que la primera, pero vamos a echar
un vistazo para ver porque se debe cumplir. Pasamos valores monádicos a las
funciones utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>. Estas funciones toman valores normales y
devuelven valores monádicos. <tt class="docutils literal"><span class="pre">return</span></tt> es una también es una de estas
funciones. Como ya sabemos, <tt class="docutils literal"><span class="pre">return</span></tt> introduce un valor en el contexto
mínimo que pueda albergar dicho valor. Esto quiere decir que, por ejemplo
para <tt class="docutils literal"><span class="pre">Maybe</span></tt>, no introduce ningún fallo; para las listas, no introduce
ningún no determinismo adicional. Aqui tienes una prueba con algunas mónadas:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just &quot;move on up&quot; &gt;&gt;= (\x -&gt; return x)</span>
<span class="go">Just &quot;move on up&quot;</span>
<span class="go">ghci&gt; [1,2,3,4] &gt;&gt;= (\x -&gt; return x)</span>
<span class="go">[1,2,3,4]</span>
<span class="go">ghci&gt; putStrLn &quot;Wah!&quot; &gt;&gt;= (\x -&gt; return x)</span>
<span class="go">Wah!</span>
</pre></div>
</div>
<p>Si echamos un vistazo más de cerca al ejemplo de las listas, la implementación
de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para las listas es:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que cuando pasamos <tt class="docutils literal"><span class="pre">[1,2,3,4]</span></tt> a <tt class="docutils literal"><span class="pre">return</span></tt>, primero <tt class="docutils literal"><span class="pre">return</span></tt> se
mapea sobre <tt class="docutils literal"><span class="pre">[1,2,3,4]</span></tt>, devolviendo <tt class="docutils literal"><span class="pre">[[1],[2],[3],[4]]</span></tt> y luego se
concatena esta lista obteniendo así la original.</p>
<p>La identida por la izquierda y la identadad por la derecha son leyes que
establecen el comportamiento de <tt class="docutils literal"><span class="pre">return</span></tt>. Es una función importante para
convertir valores normales en valores monádicos y no sería tan útil si el
valor monádico que produciera hicera mucha más cosas.</p>
</div>
<div class="section" id="asociatividad">
<h3>Asociatividad<a class="headerlink" href="#asociatividad" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La última ley de las mónadas dice que cuando tenemos una cadena de
aplicaciones funciones monádicas con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, no importa el orden en el que
estén anidadas. Escrito formalmente:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref js js-data docutils literal"><span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">g</span></tt> es igual a <tt class="xref js js-data docutils literal"><span class="pre">&gt;&gt;=</span> <span class="pre">(x</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">g)</span></tt>.</li>
</ul>
</div></blockquote>
<p>Mmm... ¿Qué esta pasando aquí? Tenemos un valor monádico, <tt class="docutils literal"><span class="pre">m</span></tt> y dos
funciones monádica <tt class="docutils literal"><span class="pre">f</span></tt> y <tt class="docutils literal"><span class="pre">g</span></tt>. Hacemos <tt class="docutils literal"><span class="pre">(m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f)</span> <span class="pre">&gt;&gt;=</span> <span class="pre">g</span></tt>, es decir,
pasamos <tt class="docutils literal"><span class="pre">m</span></tt> a <tt class="docutils literal"><span class="pre">f</span></tt>, lo cual devuelve un valor monádico. Luego pasamos ese
valor monádico a <tt class="docutils literal"><span class="pre">g</span></tt>. En la expresión <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">(\x</span> <span class="pre">-&gt;</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">g)</span></tt> tomamos
un valor monádico y se lo pasamos a una función que pasa el resultado de
<tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt> a <tt class="docutils literal"><span class="pre">g</span></tt>. Quizá no es fácil ver como ambas expresiones son iguales, así
que vamos a ver un ejemplo para aclarár las dudas.</p>
<p>¿Recuerdas cuando el funambulista Pierra caminaba sobre una cuerda con ayuda
de una barra de equilibrio? Para simular el aterrizaje de los pájaros sobre
esta barra de equilibrio utilizábamos una cadena de funciones que podían
fallar:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; return (0,0) &gt;&gt;= landRight 2 &gt;&gt;= landLeft 2 &gt;&gt;= landRight 2</span>
<span class="go">Just (2,4)</span>
</pre></div>
</div>
<p>Empezábamos con <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,0)</span></tt> y luego pasábamos este valor a la siguiente
función monádica, <tt class="docutils literal"><span class="pre">landRight</span> <span class="pre">2</span></tt>. El resultado de ésta era otro valor
monádico que pasábamos a la siguiente función de la cadena y así
sucesivamente. Si mostramos la asociatividad de forma explícita, la expresión
quedaría así:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; ((return (0,0) &gt;&gt;= landRight 2) &gt;&gt;= landLeft 2) &gt;&gt;= landRight 2</span>
<span class="go">Just (2,4)</span>
</pre></div>
</div>
<p>Pero también podemos esxpresarlo así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span>
<span class="nf">landRight</span> <span class="mi">2</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span>
<span class="nf">landLeft</span> <span class="mi">2</span> <span class="n">y</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">z</span> <span class="ow">-&gt;</span>
<span class="nf">landRight</span> <span class="mi">2</span> <span class="n">z</span><span class="p">)))</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">return</span> <span class="pre">(0,0)</span></tt> es lo mismo que <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,0)</span></tt> y cuando se lo pasamos a la
función lambda, <tt class="docutils literal"><span class="pre">x</span></tt> se convierte en <tt class="docutils literal"><span class="pre">(0,0)</span></tt>. <tt class="docutils literal"><span class="pre">landRight</span></tt> toma un número
de pájaros y una barra (una dupla de números) y eso es lo que le pasamos.
Devuelve <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(0,2)</span></tt> y cuando se lo pasamos a la siguiente función lambda,
<tt class="docutils literal"><span class="pre">y</span></tt> es <tt class="docutils literal"><span class="pre">(0,2)</span></tt>. Continua hasta el último aterrizaje de pájaros que produce
<tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(2,4)</span></tt>, que de hecho es el resultado final de la expresión.</p>
<p>Resumiendo, no importa como anides el paso de valores monádicos, lo que
importa es su significado. Otra forma de ver esta ley sería: consideremos la
composición de dos funciones, <tt class="docutils literal"><span class="pre">f</span></tt> y <tt class="docutils literal"><span class="pre">g</span></tt>. La composición de funciones se
implementa como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">f</span> <span class="o">.</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>El tipo de <tt class="docutils literal"><span class="pre">g</span></tt> es <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> y el de <tt class="docutils literal"><span class="pre">f</span></tt> es <tt class="docutils literal"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">c</span></tt>, y las unimos en
una nueva función con tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">c</span></tt> cuyo parámetro será pasado entre las
funciones anteriores. Y ahora, ¿qué pasaria si estas dos funciones fueran
monádicas? es decir ¿qué pasaria si estas funciones devolvieran valores
monádicos? Si tuvieramos una función del tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></tt>, no podríamos pasar
su resultado directamente a una función del tipo <tt class="docutils literal"><span class="pre">b</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">c</span></tt>, ya que esta
función solo acepta valores normales y no monádicos. Sin embargo podemos
utilizar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para poder permitirlo. Así que si utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, podemos
definir la composición de dos funciones monádicas como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&lt;=&lt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">f</span> <span class="o">&lt;=&lt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Ahora podemos componer nuevas funciones monádicas a partir de otras:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let f x = [x,-x]</span>
<span class="go">ghci&gt; let g x = [x*3,x*2]</span>
<span class="go">ghci&gt; let h = f &lt;=&lt; g</span>
<span class="go">ghci&gt; h 3</span>
<span class="go">[9,-9,6,-6]</span>
</pre></div>
</div>
<p>Genial ¿Y qué tiene que ver esto con la ley de asociatividad? Bueno, cuando
vemos la ley como una ley de composiciones, ésta dice que
<tt class="xref js js-data docutils literal"><span class="pre">f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">(g</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h)</span></tt> debe ser igual a <tt class="xref js js-data docutils literal"><span class="pre">(f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">g)</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h</span></tt>. Es
otra forma de decir que para las mónadas, no importa el orden del anidamiento.</p>
<p>Si traducimos las dos primeras leyes para que utilicen <tt class="docutils literal"><span class="pre">&lt;=&lt;</span></tt>, entonces, la
primera ley dice que para cada función monádica <tt class="docutils literal"><span class="pre">f</span></tt>, <tt class="xref js js-data docutils literal"><span class="pre">f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">return</span></tt>
es lo mismo que <tt class="xref js js-data docutils literal"><span class="pre">f</span></tt> y la ley de identidad por la derecha dice que
<tt class="xref js js-data docutils literal"><span class="pre">return</span> <span class="pre">&lt;=&lt;</span> <span class="pre">f</span></tt> es también igual a <tt class="xref js js-data docutils literal"><span class="pre">f</span></tt>.</p>
<p>Es parecido a lo que ocurre con las funciones normales, <tt class="docutils literal"><span class="pre">(f</span> <span class="pre">.</span> <span class="pre">g)</span> <span class="pre">.</span> <span class="pre">h</span></tt> es lo
mismo que <tt class="docutils literal"><span class="pre">f</span> <span class="pre">.</span> <span class="pre">(g</span> <span class="pre">.</span> <span class="pre">h)</span></tt>, <tt class="docutils literal"><span class="pre">f</span> <span class="pre">.</span> <span class="pre">id</span></tt> es igual a <tt class="docutils literal"><span class="pre">f</span></tt> y <tt class="docutils literal"><span class="pre">id</span> <span class="pre">.</span> <span class="pre">f</span></tt> es también
igual a <tt class="docutils literal"><span class="pre">f</span></tt>.</p>
<p>En este capítulo hemos visto las bases de la mónadas y hemos aprendido a
utilizar las mónadas <tt class="docutils literal"><span class="pre">Maybe</span></tt> y las listas. En el siguiente capítulo,
echaremos un vistazo a un puñado más de mónadas y también aprenderemos como
crear nuestras propias mónadas.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="MasMonadas.html" title="Unas cuantas mónadas más"
             >siguiente</a></li>
        <li class="right" >
          <a href="Funtores.html" title="Funtores, funtores aplicativos y monoides"
             >anterior</a> |</li>
        <li><a href="../main.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>