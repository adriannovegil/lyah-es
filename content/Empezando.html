
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Empezando &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Tipos y clases de tipos" href="Tipos.html" />
    <link rel="prev" title="Introducción" href="Introduccion.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Tipos.html" title="Tipos y clases de tipos"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="Introduccion.html" title="Introducción"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="empezando">
<h1>Empezando<a class="headerlink" href="#empezando" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="section" id="preparados-listos-ya">
<h2>¡Preparados, listos, ya!<a class="headerlink" href="#preparados-listos-ya" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Empezando" class="align-right" src="../_images/startingout.png" />
<p>Muy bien ¡Vamos a empezar! Si eres esa clase de persona horrible que no lee las
introducciones y te la has saltado, quizás quieras leer la última
sección de la introducción de todos modos porque explica lo que necesitas para
seguir esta guía y como vamos a cargar funciones. La primera cosa que vamos
a hacer es ejecutar GHC en modo interactivo y llamar algunas funciones para ir
acostumbrándonos un poco. Abre tu terminal y escribe <tt class="docutils literal"><span class="pre">ghci</span></tt>. Serás recibido
con un saldo como este.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">GHCi</span><span class="p">,</span> <span class="n">version</span> <span class="mf">6.8</span><span class="o">.</span><span class="mi">2</span><span class="kt">:</span> <span class="n">http</span><span class="kt">://</span><span class="n">www</span><span class="o">.</span><span class="n">haskell</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">ghc</span><span class="o">/</span>  <span class="kt">:?</span> <span class="n">for</span> <span class="n">help</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">base</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Prelude</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>¡Enhorabuena, estás dentro de GHCi! El prompt aquí es <tt class="docutils literal"><span class="pre">Prelude&gt;</span></tt> pero debido a
que éste puede hacerse más largo cuando cargas cosas dentro de la sesión,
nosotros vamos a usar <tt class="docutils literal"><span class="pre">ghci&gt;</span></tt>. Si quieres tener el mismo prompt, simplemente
teclea <tt class="docutils literal"><span class="pre">:set</span> <span class="pre">prompt</span> <span class="pre">&quot;ghci&gt;</span> <span class="pre">&quot;</span></tt>.</p>
<p>Aquí va algo de aritmética simple.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">15</span>
<span class="mi">17</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">49</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">4900</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1892</span> <span class="o">-</span> <span class="mi">1472</span>
<span class="mi">420</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">2.5</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Esto se explica por si solo. Podemos también usar varias operaciones en una
misma línea y todas las reglas de precedencia usuales serán obedecidas. Podemos
usar paréntesis para hacer la precedencia explícita o cambiarla.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span><span class="p">)</span>
<span class="o">-</span><span class="mi">244950</span>
</pre></div>
</div>
<p>¿Muy interesante, eh? Sí, se que no pero ten paciencia. Una pequeña dificultad
a tener en cuenta aquí ocurre al negar los números, siempre será mejor rodearlo
con paréntesis. Hacer algo como <tt class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">-3</span></tt> hará que GHCi te grite pero hacer
<tt class="docutils literal"><span class="pre">5</span> <span class="pre">*</span> <span class="pre">(-3)</span></tt> simplemente funcionará.</p>
<p>La álgebra booleana es también bastante simple. Como seguramente sabrás, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>
representa <em>Y</em> booleano mientras que <tt class="docutils literal"><span class="pre">||</span></tt> representa <em>O</em> booleano. <tt class="docutils literal"><span class="pre">not</span></tt>
niega <tt class="xref docutils literal"><span class="pre">True</span></tt> a <tt class="xref docutils literal"><span class="pre">False</span></tt>.:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>La comprobación de igualdad se hace así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">4</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>¿Qué pasa si realizamos un <tt class="docutils literal"><span class="pre">5</span> <span class="pre">+</span> <span class="pre">&quot;llama&quot;</span></tt> o <tt class="docutils literal"><span class="pre">5</span> <span class="pre">==</span> <span class="pre">True</span></tt>? Bueno, si probamos
el primer fragmento obtendremos un terrorífico mensaje de error.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Num</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="o">+</span><span class="sc">&#39; at &lt;interactive&gt;:1:0-9</span>
<span class="sc">Possible fix: add an instance declaration for (Num [Char])</span>
<span class="sc">In the expression: 5 + &quot;llama&quot;</span>
<span class="sc">In the definition of `it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="mi">5</span> <span class="o">+</span> <span class="s">&quot;llama&quot;</span>
</pre></div>
</div>
<p>¡Ay! Lo que GHCi nos está diciendo es que <tt class="docutils literal"><span class="pre">&quot;llama&quot;</span></tt> no es un número y por lo
tanto no sabe como sumarlo a 5. Incluso si no fuera <tt class="docutils literal"><span class="pre">&quot;llama&quot;</span></tt> sino <tt class="docutils literal"><span class="pre">&quot;four&quot;</span></tt>
o <tt class="docutils literal"><span class="pre">&quot;4&quot;</span></tt>, Haskell aún no lo consideraría como un número. <tt class="docutils literal"><span class="pre">+</span></tt> espera que su
parte derecha e izquierda sean números. Si intentamos realizar <tt class="docutils literal"><span class="pre">True</span> <span class="pre">==</span> <span class="pre">5</span></tt>,
GHCi nos diría que los tipos no coinciden. Mientras que <tt class="docutils literal"><span class="pre">+</span></tt> funciona solo
con cosas que son consideradas números, <tt class="docutils literal"><span class="pre">==</span></tt> funciona con cualquiera cosa que
pueda ser comparada. El truco está en que ambas cosas tienen que ser iguales. No
puedes comparar manzanas con naranjas. Daremos un vistazo más detallado sobre
los tipos más adelante. Nota: puedes hacer <tt class="docutils literal"><span class="pre">5</span> <span class="pre">+</span> <span class="pre">4.0</span></tt> porque <tt class="docutils literal"><span class="pre">5</span></tt> es amorfo y
puede actuar como un entero o como un número en coma flotante. <tt class="docutils literal"><span class="pre">4.0</span></tt> no puede
actuar como un entero, así que <tt class="docutils literal"><span class="pre">5</span></tt> es el único que se puede adaptar.</p>
<p>Puede que no lo sepas, pero hemos estado usando funciones durante todo este
tiempo. Por ejemplo, <tt class="docutils literal"><span class="pre">*</span></tt> es una función que toma dos números y los
multiplica. Como ya has visto, lo llamamos haciendo un sándwich sobre él. Esto
es lo que nosotros llamamos funciones infijas. Muchas funciones que no son
usadas con números son prefijas. Vamos a ver alguna de ellas.</p>
<img alt="Ring Ring!" class="align-right" src="../_images/ringring.png" />
<p>Las funciones son prefijas normalmente así que de ahora en adelante no vamos ha
declarar explícitamente que una función está en forma prefija, simplemente lo
asumiremos. En muchos lenguajes imperativos las funciones son llamadas
escribiendo su nombre y luego escribiendo sus parámetros entre paréntesis,
normalmente separados por comas. En Haskell, las funciones son llamadas
escribiendo su nombre, un espacio y sus parámetros, separados por espacios.
Para empezar, vamos a intentar llamar una de las funciones más aburridas de
Haskell.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">8</span>
<span class="mi">9</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">succ</span></tt> toma cualquier cosa que tenga definido un sucesor y
devuelve ese sucesor. Como puedes ver, simplemente hemos separado el nombre de
la función y su parámetro por un espacio. Llamar a una función con varios
parámetros es igual de sencillo. Las funciones <tt class="docutils literal"><span class="pre">min</span></tt> y <tt class="docutils literal"><span class="pre">max</span></tt> toman dos cosas
que puedan ponerse en orden (¡Cómo los números!) y devuelven uno de ellos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mf">3.4</span> <span class="mf">3.2</span>
<span class="mf">3.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">100</span> <span class="mi">101</span>
<span class="mi">101</span>
</pre></div>
</div>
<p>La aplicación de funciones (Llamar a una función poniendo un espacio después de
ella y luego escribir sus parámetros) tiene la máxima prioridad. Lo que esto
significa para nosotros es que estas dos sentencias son equivalentes.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">succ</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
</pre></div>
</div>
<p>Sin embargo, si hubiésemos querido obtener el sucesor del producto de los
números 9 y 10, no podríamos haber escrito <tt class="docutils literal"><span class="pre">succ</span> <span class="pre">9</span> <span class="pre">*</span> <span class="pre">10</span></tt> porque hubiésemos
obtenido el sucesor de 9, el cual hubiese sido multiplicado por 10.
Obtendríamos 100. Tenemos que escribir <tt class="docutils literal"><span class="pre">succ</span> <span class="pre">(9</span> <span class="pre">*</span> <span class="pre">10)</span></tt> para obtener 91.</p>
<p>Si una función toma dos parámetros también podemos llamarla como una función
infija rodeándola con acentos abiertos. Por ejemplo, la función <tt class="docutils literal"><span class="pre">div</span></tt> toma dos
enteros y realiza una división integral entre ellos. Haciendo <tt class="docutils literal"><span class="pre">div</span> <span class="pre">92</span> <span class="pre">10</span></tt>
obtendríamos 9. Pero cuando la llamamos así, puede haber alguna confusión como
que número está haciendo la división y cual está siendo dividido. De manera que
nosotros la llamamos como una función infija haciendo <tt class="docutils literal"><span class="pre">92</span> <span class="pre">`div`</span> <span class="pre">10</span></tt> y de
repente es mucho más claro.</p>
<p>Un montón de gente que viene de los lenguajes imperativos tienden a aferrarse
a la idea de que los paréntesis indican la aplicación de funciones. Por ejemplo,
en C, usas los paréntesis para llamar a las funciones como <tt class="docutils literal"><span class="pre">foo()</span></tt>,
<tt class="docutils literal"><span class="pre">bar(1)</span></tt>, o <tt class="docutils literal"><span class="pre">baz(3,</span> <span class="pre">&quot;haha&quot;)</span></tt>. Como hemos dicho, los espacios son usados para
la aplicación de funciones en Haskell. Así que estas funciones en Haskell serían
<tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">1</span></tt> y  <tt class="docutils literal"><span class="pre">baz</span> <span class="pre">3</span> <span class="pre">&quot;haha&quot;</span></tt>. Si ves algo como <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">(bar</span> <span class="pre">3)</span></tt> no
significa que <tt class="docutils literal"><span class="pre">bar</span></tt> es llamado con <tt class="docutils literal"><span class="pre">bar</span></tt> y <tt class="docutils literal"><span class="pre">3</span></tt> como parámetros. Significa
que primero llamamos a la función <tt class="docutils literal"><span class="pre">bar</span></tt> con <tt class="docutils literal"><span class="pre">3</span></tt> como parámetro para obtener
un número y luego volver a llamar <tt class="docutils literal"><span class="pre">bar</span></tt> otra vez con ese número. En C, esto
sería algo como <tt class="docutils literal"><span class="pre">bar(bar(3))</span></tt>.</p>
</div>
<div class="section" id="las-primeras-pequenas-funciones">
<h2>Las primeras pequeñas funciones<a class="headerlink" href="#las-primeras-pequenas-funciones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En la sección anterior obtuvimos una idea básica para llamar a las funciones.
¡Ahora vamos a intentar hacer las nuestras! Abre tu editor de textos favorito y
pega esta función que toma un número y lo multiplica por dos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">doubleMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</pre></div>
</div>
<p>Las funciones son definidas de forma similar a como son llamadas. El nombre de
la función es seguido por los parámetros separados por espacios. Pero, cuando
estamos definiendo funciones, hay un <tt class="docutils literal"><span class="pre">=</span></tt> y luego definimos lo que hace la
función. Guarda esto como <tt class="docutils literal"><span class="pre">baby.hs</span></tt> o como tú quieras. Ahora navega hasta
donde lo guardaste y ejecuta <tt class="docutils literal"><span class="pre">ghci</span></tt> desde ahí. Una vez dentro de GHCi, haz
<tt class="docutils literal"><span class="pre">:l</span> <span class="pre">baby</span></tt>. Ahora que nuestro script está cargado, podemos jugar con la función
que hemos definido.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">baby</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">baby</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mi">9</span>
<span class="mi">18</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mf">8.3</span>
<span class="mf">16.6</span>
</pre></div>
</div>
<p>Como <tt class="docutils literal"><span class="pre">+</span></tt> funciona con los enteros igual de bien que con los número en coma
flotante (en realidad con cualquier cosa que pueda ser considerada un número),
nuestra función también funciona con cualquier número. Vamos a hacer una
función que tome dos números, multiplique por dos cada uno de ellos y luego sume
ambos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<p>Simple. La podríamos haber definido también como
<tt class="docutils literal"><span class="pre">doubleUs</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">y</span></tt>. Al ponerla a prueba produce resultandos
bastante predecibles (recuerda añadir esta función en el fichero <tt class="docutils literal"><span class="pre">baby.hs</span></tt>,
guardarlo y luego <tt class="docutils literal"><span class="pre">:l</span> <span class="pre">baby</span></tt> dentro de GHCi).</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">4</span> <span class="mi">9</span>
<span class="mi">26</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mf">2.3</span> <span class="mf">34.2</span>
<span class="mf">73.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">28</span> <span class="mi">88</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="mi">123</span>
<span class="mi">478</span>
</pre></div>
</div>
<p>Como podrás deducir, puedes llamar tus propias funciones dentro de las funciones
que hagas. Con esto en mente, podríamos redefinir <tt class="docutils literal"><span class="pre">doubleUs</span></tt> como esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">doubleMe</span> <span class="n">x</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="n">y</span>
</pre></div>
</div>
<p>Esto es un simple ejemplo de un patrón normal que verás por todo Haskell. Crear
pequeñas funciones que son obviamente correctas y luego combinarlas en funciones
más complejas. De esta forma también evitarás repetirte. ¿Qué pasa si algunos
matemáticos descubren que 2 es en realidad 3 y tienes que cambiar tu programa?
Puedes simplemente redefinir <tt class="docutils literal"><span class="pre">doubleMe</span></tt> para que sea <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">x</span></tt> y como
<tt class="docutils literal"><span class="pre">doubleUs</span></tt> llama a <tt class="docutils literal"><span class="pre">doubleMe</span></tt> automáticamente funcionara en este extraño
mundo en el que 2 es 3.</p>
<p>Las funciones en Haskell no tienen que estar en ningún orden en particular, así
que no importa si defines antes <tt class="docutils literal"><span class="pre">doubleMe</span></tt> y luego <tt class="docutils literal"><span class="pre">doubleUs</span></tt> o si lo haces
en algún otro lugar.</p>
<p>Ahora vamos a crear una función que multiplique un número por 2 pero solo si ese
número es menor o igual que 100 porque los número mayores 100 ya son
suficientemente grandes por si solos.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">doubleSmallNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
                        <span class="kr">then</span> <span class="n">x</span>
                        <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span>
</pre></div>
</div>
<img alt="Bebe" class="align-left" src="../_images/baby.png" />
<p>Aquí hemos introducido la sentencia if de Haskell. Probablemente ya estés
familiarizado con la sentencia if de otros lenguajes. La diferencia entre la
sentencia if de Haskell y la de los lenguajes imperativos es que la para else
de la sentencia es obligatoria en Haskell. En los lenguajes imperativos puede
saltarte un par de pasos si una condición no se ha satisfecho pero en Haskell
cada expresión y función debe devolver algo. También podríamos haber definido
la sentencia if en una línea pero encuentro esta forma más legible. Otro tema
acerca de la sentencia if en Haskell es que es una expresión. Básicamente una
expresión es un trozo de código que devuelve un valor. <tt class="docutils literal"><span class="pre">5</span></tt> es una expresión
porque devuelve 5, <tt class="docutils literal"><span class="pre">4</span> <span class="pre">+</span> <span class="pre">8</span></tt> es una expresión, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt> es una expresión porque
devuelve la suma de <tt class="docutils literal"><span class="pre">x</span></tt> e <tt class="docutils literal"><span class="pre">y</span></tt>. Como la parte else es obligatoria, una
sentencia if siempre debe devolver algo y ese es el porque de que es una
expresión. Si queremos añadir uno a cada número que es producido por nuestra
función anterior, podemos escribir su cuerpo así.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">doubleSmallNumber&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Si hubiésemos omitido los paréntesis, sólo hubiese añadido uno si <tt class="docutils literal"><span class="pre">x</span></tt> no fuera
mayor que 100. Fíjate en el <tt class="docutils literal"><span class="pre">'</span></tt> al final del nombre de la función. Ese
apostrofare no tiene ningún significado especial en la sintaxis de Haskell. Es
un carácter valido para ser usado en el nombre de una función. Normalmente
usamos <tt class="docutils literal"><span class="pre">'</span></tt> para denotar la versión estricta de una función (una que no es
perezosa) o una pequeña versión modificada de una función o variable. Como <tt class="docutils literal"><span class="pre">'</span></tt>
es un carácter válido para la funciones, podemos hacer cosas como esta.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">conanO&#39;Brien</span> <span class="ow">=</span> <span class="s">&quot;It&#39;s a-me, Conan O&#39;Brien!&quot;</span>
</pre></div>
</div>
<p>Hay dos cosas que destacar aquí. La primera es que en esta función no
capitalizamos el nombre de Conan. Esto es porque las funciones no pueden empezar
con una letra en mayúsculas. Veremos el porqué un poco más tarde. La segunda es
que esta función no toma ningún parámetro, normalmente lo llamamos una
definición (o un nombre). Como no podemos cambiar los nombres (y las funciones)
después de que las hayamos definido, <tt class="docutils literal"><span class="pre">conanO'Brien</span></tt> y la cadena <tt class="docutils literal"><span class="pre">&quot;It's</span> <span class="pre">a-me,</span>
<span class="pre">Conan</span> <span class="pre">O'Brien!&quot;</span></tt> se pueden utilizar indistintamente.</p>
</div>
<div class="section" id="una-introduccion-a-las-listas">
<h2>Una introducción a las listas<a class="headerlink" href="#una-introduccion-a-las-listas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Lista" class="align-left" src="../_images/list.png" />
<p>Al igual que las listas de compra en la vida real, las listas en Haskell son muy
útiles. Es la estructura de datos más utilizada y pueden ser utilizadas de
múltiples formas diferentes para modelar y resolver un montón de problemas. Las
listas son MUY impresionantes. En esta sección daremos un vistazo a las bases
sobre las listas, cadenas (las cuales son listas) y listas por compresión.</p>
<p>En Haskell, las listas son una estructura de datos <strong>homogénea</strong>. Almacena
varios elementos del mismo tipo. Esto significa que podemos tener una lista de
enteros o una lista de caracteres pero no podemos tener una lista que tenga unos
cuantos enteros y otros cuantos más caracteres. Y ahora, ¡una lista!</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Podemos usar la palabra reservada <tt class="docutils literal"><span class="pre">let</span></tt> para definir un nombre en GHCi.
Hacer <tt class="docutils literal"><span class="pre">let</span> <span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></tt> dentro de GHCi es equivalente ha escribir <tt class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">1</span></tt> en
un script y luego cargarlo.</p>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">lostNumbers</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lostNumbers</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div>
</div>
<p>Como puedes ver, las listas se indican mediante corchetes y sus valores se
separan por comas. Si hemos intentado crear una lista como esta
<tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">'a',</span> <span class="pre">3,</span> <span class="pre">'b','c',4]</span></tt>, Haskell nos avisaría que los caracteres (que son,
por cierto, declarados como un carácter entre comillas simples) no son números.
Hablando sobre caracteres, las cadenas son simplemente cadenas de caracteres.
<tt class="docutils literal"><span class="pre">&quot;hello&quot;</span></tt> es solo <a class="reference external" href="http://es.wikipedia.org/wiki/Azúcar_sintáctica">azúcar sintáctica</a>
para <tt class="docutils literal"><span class="pre">['h','e','l','l','o']</span></tt>. Como las cadenas son listas, podemos usar las
funciones de listas sobre ellas, lo cual es realmente útil.</p>
<p>Una tarea común es concatenar dos listas. Cosa que conseguimos con el operador
<tt class="docutils literal"><span class="pre">++</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="s">&quot;world&quot;</span>
<span class="s">&quot;hello world&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;w&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">]</span>
<span class="s">&quot;woot&quot;</span>
</pre></div>
</div>
<p>Cuidado cuando usas el operador <tt class="docutils literal"><span class="pre">++</span></tt> repetidas veces en una cadena larga.
Cuando concatenas dos listas (incluso si añades una lista de un elemento a otra
lista, por ejemplo <tt class="docutils literal"><span class="pre">[1,2,3]</span> <span class="pre">++</span> <span class="pre">[4]</span></tt>, internamente, Haskell tiene que recorrer
la lista entera desde la parte izquierda del operador <tt class="docutils literal"><span class="pre">++</span></tt>. Esto no es un
problema cuando tratamos con listas que no son demasiado grandes. Pero
concatenar algo al final de una lista que tiene cincuenta millones de elementos
llevará un rato. Sin embargo, concatenar algo al principio de una lista
utilizando el operador <tt class="docutils literal"><span class="pre">:</span></tt> (También llamado operador cons) es instantáneo.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;A&#39;</span><span class="kt">:</span><span class="s">&quot; SMALL CAT&quot;</span>
<span class="s">&quot;A SMALL CAT&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>Fíjate que <tt class="docutils literal"><span class="pre">:</span></tt> toma un número y una lista de números o un carácter y una lista
de caracteres, mientras que <tt class="docutils literal"><span class="pre">++</span></tt> toma dos listas. Incluso si añades un
elemento al final de las lista con <tt class="docutils literal"><span class="pre">++</span></tt>, hay que rodearlo con corchetes por lo
que se convierte en una lista de un solo elemento.</p>
<p><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt> es solo azúcar sintáctico para <tt class="docutils literal"><span class="pre">1:2:3:[]</span></tt>. <tt class="docutils literal"><span class="pre">[]</span></tt> es una lista
vacía. Si anteponemos 3 a ella con <tt class="docutils literal"><span class="pre">:</span></tt>, obtenemos <tt class="docutils literal"><span class="pre">[3]</span></tt>, y si anteponemos 2
a esto obtenemos <tt class="docutils literal"><span class="pre">[2,3]</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last"><tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">[[]]</span></tt> y <tt class="docutils literal"><span class="pre">[[],[],[]]</span></tt> son todas cosas diferentes. La primera es
una lista vacía, la segunda es una lista que contiene un elemento (otra
lista vacía) y la tercera es una lista que contiene tres elementos.</p>
</div>
<p>Si quieres obtener un elemento de la lista sabiendo su índice, utiliza <tt class="docutils literal"><span class="pre">!!</span></tt>.
Los índices empiezan con 0.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Steve Buscemi&quot;</span> <span class="o">!!</span> <span class="mi">6</span>
<span class="sc">&#39;B&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">9.4</span><span class="p">,</span><span class="mf">33.2</span><span class="p">,</span><span class="mf">96.2</span><span class="p">,</span><span class="mf">11.2</span><span class="p">,</span><span class="mf">23.25</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">1</span>
<span class="mf">33.2</span>
</pre></div>
</div>
<p>Pero si intentas obtener el sexto elemento de una lista que solo tiene cuatro
elementos, obtendrás un error, así que ves con cuidado.</p>
<p>Las listas también pueden contener listas. Estas también pueden contener listas
que contengan listas que contengas listas...</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">++</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="kt">:</span><span class="n">b</span>
<span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>Las listas de dentro de las listas pueden tener diferentes tamaños pero no
pueden tener diferentes tipos. De la misma forma que no se pueden tener listas
que contengan caracteres y algunos números, tampoco se pueden tener listas que
contengan listas de caracteres y listas de números.</p>
<p>Las listas pueden ser comparadas si los elementos que contienen pueden ser
comparados. Cuando usamos <tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">&lt;=</span></tt>, <tt class="docutils literal"><span class="pre">&gt;</span></tt>, y <tt class="docutils literal"><span class="pre">&gt;=</span></tt> para comparar listas,
son comparadas en orden lexicográfico. Primero son comparadas las cabezas. Luego
son comparados los segundos y así sucesivamente.</p>
<p>¿Qué mas puedes hacer con las listas? Aquí tienes algunas funciones básicas que
pueden operar con las listas.</p>
<blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">head</span></tt> toma una lista y devuelve su cabeza. La cabeza de una lista es
básicamente el primer elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">tail</span></tt> toma una lista y devuelve su cola. En otros palabras, corta la
cabeza de la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">last</span></tt> toma una lista y devuelve su último elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">init</span></tt> toma una lista y devuelve toda la lista excepto su último elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">init</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ul>
</blockquote>
<p>Si pensamos en las listas como en un monstruo, esto es lo que pasa.</p>
<img alt="Monstruo" class="align-center" src="../_images/listmonster.png" />
<p>¿Pero que pasa si intentamos obtener la cabeza de una lista vacía?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">head</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
</pre></div>
</div>
<p>¡Oh, explotó delante de nuestros ojos! Si no hay ningún monstruo, no tiene
cabeza. Cuando usamos <tt class="docutils literal"><span class="pre">head</span></tt>, <tt class="docutils literal"><span class="pre">tail</span></tt>, <tt class="docutils literal"><span class="pre">last</span></tt> e <tt class="docutils literal"><span class="pre">init</span></tt>, debemos tener
precaución de no usar con ellas listas vacías. Este error no puede ser capturado
en tiempo de compilación así que siempre es una buena práctica tomar
precauciones antes de decir a Haskell que te devuelva algunos elementos de una
lista vacía.</p>
<blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">length</span></tt> toma una lista y obviamente devuelve su tamaño.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">null</span></tt> comprueba si una lista está vacía. Si lo está, devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt>, en
caso contrario devuelve <tt class="xref docutils literal"><span class="pre">False</span></tt>. Usa esta función en lugar de <tt class="docutils literal"><span class="pre">xs</span> <span class="pre">==</span> <span class="pre">[]</span></tt>
(si tienes una lista que se llame xs).</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="kt">True</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">reverse</span></tt> da la vuelta a lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">take</span></tt> toma un número y una lista. Extrae dicho número de elementos de una
lista. Observa.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div>
</div>
<p>Fíjate que si intentamos tomar más elementos de los que hay en una lista,
simplemente devuelve la lista. Si tomamos 0 elementos, obtenemos una lista
vacía.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">drop</span></tt> funciona de forma similar, solo que quita un número de elementos del
comienzo de la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">maximum</span></tt> toma una lista de cosas que se pueden poner en algún tipo de
orden y devuelve el elemento más grande.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">minimum</span></tt> devuelve el más pequeño.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">9</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">sum</span></tt> toma una lista de números y devuelve su suma.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">product</span></tt> toma una lista de números y devuelve su producto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">31</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">24</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">0</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">elem</span></tt> toma una cosa y una lista de cosas y nos dice si dicha cosa es un
elemento de la lista. Normalmente esta función es llamada en forma infija
porque es más fácil de leer de esta forma.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div>
</div>
</li>
</ul>
</blockquote>
<p>Estas fueron unas cuantas pocas funciones básicas que operan con las listas.
Veremos más funciones de listas más adelante.</p>
</div>
<div class="section" id="texas-rangos">
<h2>Texas Rangos<a class="headerlink" href="#texas-rangos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Cowboy" class="align-right" src="../_images/cowboy.png" />
<p>¿Qué pasa si queremos una lista con todos los números entre el 1 y el 20? Claro,
podríamos simplemente escribirlos pero obviamente hacer esto no es una solución
para los señores que demandan la excelencia de sus lenguajes de programación.
En su lugar, usaremos rangos. Los rangos son una manera de crear listas que
contengan una secuencia aritmética de elementos numerables. Los números pueden
ser enumerados. Uno, dos, tres, cuatro, etc. Los caracteres también pueden ser
enumerados. El alfabeto es una enumeración de caracteres desde la A hasta la Z.
Los nombres no son numerables. ¿Qué viene después de &#8220;John&#8221;? No lo se.</p>
<p>Para crear una lista que contenga todos los números naturales desde el 1 hasta
el 20 simplemente escribimos <tt class="docutils literal"><span class="pre">[1..20]</span></tt>. Esto es equivalente ha escribir
<tt class="docutils literal"><span class="pre">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</span></tt> y no hay ninguna
diferencia entre escribir uno u otro salvo que escribir una secuencia numerable
larga manualmente es estúpido.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;K&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]</span>
<span class="s">&quot;KLMNOPQRSTUVWXYZ&quot;</span>
</pre></div>
</div>
<p>Los rangos son buenos porque también podemos especificar un paso. ¿Qué pasa si
queremos todos los números pares desde el 1 hasta el 20, o cada tercer número?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</pre></div>
</div>
<p>Es simplemente cuestión de separar los primeros dos elementos con una coma y
luego especificar el límite superior. Aunque son muy inteligentes, los rangos
con pasos no son tan inteligentes como algunas personas esperan que sean. No
puedes escribir <tt class="docutils literal"><span class="pre">[1,2,4,8,16..100]</span></tt> y esperar obtener todas las potencias de
2. Primero porque solo se puede especificar un paso. Y segundo porque las
secuencias que no son aritméticas son ambiguas si solo damos unos pocos
elementos iniciales.</p>
<p>Para obtener una lista con todos los números desde el 20 hasta el 1 no puedes
hacer solo <tt class="docutils literal"><span class="pre">[20..1]</span></tt>, tienes que hacer <tt class="docutils literal"><span class="pre">[20,19..1]</span></tt>.</p>
<p>¡Cuidado cuando uses números en coma flotantes con los rangos! Porque éstos no
son del todo precisos (por definición), y su uso con los rangos puede dar
algunos resultados no muy esperados.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.8999999999999999</span><span class="p">,</span><span class="mf">1.0999999999999999</span><span class="p">]</span>
</pre></div>
</div>
<p>Mi consejo es no usarlos en los rangos.</p>
<p>También puedes utilizar los rangos para crear listas infinitas simplemente no
especificando un límite superior. Más tarde nos centraremos más en las listas
infinitas. Por ahora, vamos a examinar como obtendríamos los primeros 24
múltiplos de 13. Sí, podemos utilizar <tt class="docutils literal"><span class="pre">[13,26..24*13]</span></tt>. Pero hay una forma
mejor: <tt class="docutils literal"><span class="pre">take</span> <span class="pre">13</span> <span class="pre">[13,26..]</span></tt>. Como Haskell es perezoso, no intentará evaluar la
lista infinita inmediatamente porque no terminaría nunca. Él espera a ver que
es lo que quieres obtener de la lista infinita. Y aquí ve que solo queremos los
primeros 24 elementos y los evalúa con mucho gusto.</p>
<p>Ahora, un puñado de funciones que generan listas infinitas:</p>
<blockquote>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">cycle</span></tt> toma una lista y crea un ciclo de listas iguales infinito. Si
intentáramos mostrar el resultado, nunca terminaría así que hay que cortarlo
en alguna parte.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">12</span> <span class="p">(</span><span class="n">cycle</span> <span class="s">&quot;LOL &quot;</span><span class="p">)</span>
<span class="s">&quot;LOL LOL LOL &quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">repeat</span></tt> toma un elemento y produce una lista infinita que contiene ese
único elemento. Es como hacer un ciclo de una lista con un solo elemento.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>Aunque aquí sería más simple usar la función <tt class="docutils literal"><span class="pre">replicate</span></tt> si sabes el número
de elementos de antemano. <tt class="docutils literal"><span class="pre">replicate</span> <span class="pre">3</span> <span class="pre">10</span></tt> devuelve <tt class="docutils literal"><span class="pre">[10,10,10]</span></tt>.</p>
</li>
</ul>
</blockquote>
</div>
<div class="section" id="soy-una-lista-por-comprension">
<h2>Soy una lista por comprensión<a class="headerlink" href="#soy-una-lista-por-comprension" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Kermit" class="align-left" src="../_images/kermit.png" />
<p>Si alguna vez tuviste clases de matemáticas, probablemente te toparas con los
conjuntos por comprensión. Normalmente son utilizados para construir conjuntos
más específicos a partir de otros más generales. Un conjunto por comprensión
que contenga los diez primeros números naturales pares sería
<img class="math" src="../_images/math/3507873edf12a9d2269271876dbc11944cb69732.png" alt="\mathrm{\mathsf{\mathrm{S=\{2\cdot x\left|\: x\in\mathbb{N},\: x\leq10\right.\}}}}"/>.
La parte anterior al separador se llama la función de salida,
<img class="math" src="../_images/math/c3960a2f7a4ca653275125c3a39cd1ae6436ee98.png" alt="\mathrm{\mathsf{\mathrm{x}}}"/> es la variable,
<img class="math" src="../_images/math/02ba68b5a771d6994066f84bdaa1827ec275fcce.png" alt="\mathrm{\mathsf{\mathrm{\mathbb{N}}}}"/> es el conjunto de entrada y
<img class="math" src="../_images/math/6c038624e63d0c51c57e538dc4f8894ad6ee7a2b.png" alt="\mathrm{\mathsf{\mathrm{x\leq10}}}"/> es el predicado. Esto significa que
el conjunto contiene todos los dobles de los número naturales que cumplen el
predicado.</p>
<p>Si quisiéramos escribir esto en Haskell, podríamos usar algo como
<tt class="docutils literal"><span class="pre">take</span> <span class="pre">10</span> <span class="pre">[2,4..]</span></tt>. Pero, ¿y si no quisiéramos los dobles de los diez primeros
número naturales, sino algún tipo de función más compleja?  Para ello podemos
utilizar las listas por comprensión. Las listas por comprensión son muy
similares a los conjuntos por comprensión. En este caso, la lista por
comprensión que deberíamos usar sería <tt class="docutils literal"><span class="pre">[x*2</span> <span class="pre">|</span> <span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">[1..10]]</span></tt>. <tt class="docutils literal"><span class="pre">x</span></tt> es
extraído de <tt class="docutils literal"><span class="pre">[1..10]</span></tt> y para cada elemento de <tt class="docutils literal"><span class="pre">[1..10]</span></tt> (que hemos ligado
a <tt class="docutils literal"><span class="pre">x</span></tt>) obtenemos ese elemento doblado. Esta comprensión en acción seria:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>Como podemos ver, obtenemos los resultados deseados. Ahora vamos a añadir una
condición (o un predicado) a esta comprensión. Los predicados van después la
parte donde enlazamos las variables, separado por una coma. Digamos que solo
queremos los elementos que su doble sea mayor o igual a doce:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>Guay, funciona. ¿Cómo sería si quisiéramos todos los números del 50 al 100 cuyo
resto al dividir por 7 fuera 3? Fácil:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">50</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">94</span><span class="p">]</span>
</pre></div>
</div>
<p>¡Todo un éxito! Ten en cuenta que eliminar elementos de la lista utilizando
predicados también se conoce como <strong>filtrado</strong>. Tomamos una lista de números
y la filtramos usando predicados. Ahora otro ejemplo. Digamos que queremos
una comprensión que reemplace cada número impar mayor que diez por &#8220;BANG!&#8221; y
cada número impar menor que diez por &#8220;BOOM!&#8221;. Si un número no es impar, lo
dejamos fuera de la lista. Para mayor comodidad, ponemos la comprensión dentro
de una función para que sea fácilmente reusable.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">boomBangs</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">&quot;BOOM!&quot;</span> <span class="kr">else</span> <span class="s">&quot;BANG!&quot;</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>La última parte de la comprensión es el predicado. La función <tt class="docutils literal"><span class="pre">odd</span></tt> devuelve
<tt class="xref docutils literal"><span class="pre">True</span></tt> si le pasamos un número impar y <tt class="xref docutils literal"><span class="pre">False</span></tt> con uno par. El elemento es
incluido en la lista solo si todos los predicados se evalúan a <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boomBangs</span> <span class="p">[</span><span class="mi">7</span><span class="o">..</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Podemos incluir varios predicados. Si quisiéramos todos los elementos del 10 al
20 que no fueran 13, 15 ni 19, haríamos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">19</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>No solo podemos tener varios predicados en una lista por comprensión (un
elemento debe satisfacer todos los predicados para ser incluido en la lista),
sino que también podemos extraer los elementos de varias listas. Cuando
extraemos elementos de varias listas, la comprensión produce todas las
combinaciones posibles de dichas listas y las une para la función de salida que
suministremos. Una lista producida por una comprensión que extrae elementos
de dos listas cuyas longitudes son de 4, tendrá una longitud de 16 elementos
siempre y cuando no los filtremos. Si tenemos dos listas, <tt class="docutils literal"><span class="pre">[2,5,10]</span></tt> y
<tt class="docutils literal"><span class="pre">[8,10,11]</span></tt> y queremos que el producto de todas las combinaciones posibles
entre ambas, usaremos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div>
</div>
<p>Como era de esperar, la longitud de la nueva lista es de 9. ¿Y si quisiéramos
todos los posibles productos cuyo valor sea mayor que 50?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div>
</div>
<p>¿Qué tal una lista por comprensión que combine una lista de adjetivos con una
lista de nombres? Solo para quedarnos tranquilos...</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nouns</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;hobo&quot;</span><span class="p">,</span><span class="s">&quot;frog&quot;</span><span class="p">,</span><span class="s">&quot;pope&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adjectives</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="s">&quot;grouchy&quot;</span><span class="p">,</span><span class="s">&quot;scheming&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">adjective</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">noun</span> <span class="o">|</span> <span class="n">adjective</span> <span class="ow">&lt;-</span> <span class="n">adjectives</span><span class="p">,</span> <span class="n">noun</span> <span class="ow">&lt;-</span> <span class="n">nouns</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;lazy hobo&quot;</span><span class="p">,</span><span class="s">&quot;lazy frog&quot;</span><span class="p">,</span><span class="s">&quot;lazy pope&quot;</span><span class="p">,</span><span class="s">&quot;grouchy hobo&quot;</span><span class="p">,</span><span class="s">&quot;grouchy frog&quot;</span><span class="p">,</span>
<span class="s">&quot;grouchy pope&quot;</span><span class="p">,</span><span class="s">&quot;scheming hobo&quot;</span><span class="p">,</span><span class="s">&quot;scheming frog&quot;</span><span class="p">,</span><span class="s">&quot;scheming pope&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>¡Ya se! Vamos a escribir nuestra propia versión de <tt class="docutils literal"><span class="pre">length</span></tt>. La llamaremos
<tt class="docutils literal"><span class="pre">length'</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">length&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span> <span class="o">|</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">_</span></tt> significa que no nos importa lo que vayamos a extraer de la lista, así que
en vez de escribir el nombre de una variable que nunca usaríamos, simplemente
escribimos <tt class="docutils literal"><span class="pre">_</span></tt>. La función reemplaza cada elemento de la lista original por
1 y luego los suma. Esto significa que la suma resultante será el tamaño de
nuestra lista.</p>
<p>Solo un recordatorio: como las cadenas son listas, podemos usar las listas por
comprensión para procesar y producir cadenas. Por ejemplo, una función que toma
cadenas y elimina de ellas todo excepto las letras mayúsculas sería algo así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div>
</div>
<p>Unas pruebas rápidas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;Hahaha! Ahahaha!&quot;</span>
<span class="s">&quot;HA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;IdontLIKEFROGS&quot;</span>
<span class="s">&quot;ILIKEFROGS&quot;</span>
</pre></div>
</div>
<p>En este caso el predicado hace todo el trabajo. Dice que el elemento será
incluido en la lista solo si es un elemento de <tt class="docutils literal"><span class="pre">[A..Z]</span></tt>. Las listas por
comprensión anidadas son también posibles si estás trabajando con listas
que contienen listas. Por ejemplo, dada una lista de listas de números, vamos
eliminar los números impares sin aplanar la lista:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xxs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span> <span class="p">]</span> <span class="o">|</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">xxs</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</pre></div>
</div>
<p>Puedes escribir listas por comprensión en varias líneas. Así que si no estás
en GHCi, es mejor dividir las listas por comprensión en varias líneas,
especialmente si están anidadas.</p>
</div>
<div class="section" id="tuplas">
<h2>Tuplas<a class="headerlink" href="#tuplas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Tupla" class="align-right" src="../_images/tuple.png" />
<p>De alguna forma, las tuplas son parecidas a las listas. Ambas son una forma de
almacenar varios valores en un solo valor. Sin embargo, hay unas pocas
diferencias fundamentales. Una lista de números es una lista de números. Ese es
su tipo y no importa si tiene un sólo elemento o una cantidad infinita de ellos.
Las tuplas sin embargo, son utilizadas cuando sabes exactamente cuantos valores
tienen que se combinados y su tipo depende de cuantos componentes y el tipo de
estos componentes. Las tuplas se denotan con paréntesis y sus valores se separan
con comas.</p>
<p>Otra diferencia clave es que no tienen que ser homogéneas. Al contrario que las
listas, las tuplas pueden contener una combinación de varios tipos.</p>
<p>Piensa en como representaríamos un vector bi-dimensional en Haskell. Una forma
sería utilizando listas. Podría funcionar. Entonces, ¿si quisiéramos poner varios
vectores dentro de una lista que representa los puntos de una figura
bi-dimensional? Podríamos hacer algo como <tt class="docutils literal"><span class="pre">[[1,2],[8,11],[4,5]]</span></tt>. El problema
con este método es que también podríamos hacer cosas como
<tt class="docutils literal"><span class="pre">[[1,2],[8,11,5],[4,5]]</span></tt> ya que Haskell no tiene problemas con ello, sigue
siendo una lista de listas de números pero no tiene ningún tipo de sentido. Pero
una tupla de tamaño 2 (también llamado par) tiene su propio tipo, lo que
significa que no puedes tener varios duplas y un triple (una tupla de tamaño 3)
en una lista, así que vamos a usar estas. En lugar de usar corchetes rodeando
los vectores utilizamos paréntesis: <tt class="docutils literal"><span class="pre">[(1,2),(8,11),(4,5)]</span></tt>. ¿Qué pasaría si
intentamos crear una forma como <tt class="docutils literal"><span class="pre">[(1,2),(8,11,5),(4,5)]</span></tt>? Bueno, obtendríamos
este error:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Couldn&#39;t</span> <span class="n">match</span> <span class="n">expected</span> <span class="kr">type</span> <span class="p">`(</span><span class="n">t</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span><span class="sc">&#39;</span>
<span class="sc">against inferred type `(t2, t3, t4)&#39;</span>
<span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="kt">In</span> <span class="n">the</span> <span class="n">definition</span> <span class="kr">of</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
<p>Nos está diciendo que hemos intentado usar un par y un triple en la misma lista,
lo cual no esta permitido ya que las listas son homogéneas y un par tiene un
tipo diferente al de un triple (aunque contengan el mismo tipo de valores).
Tampoco podemos hacer algo como <tt class="docutils literal"><span class="pre">[(1,2),(&quot;One&quot;,2)]</span></tt> ya que el primer elemento
de la lista es un par de números y el segundo es un par de una cadena y un
número. Las tuplas pueden ser usadas para representar una gran variedad de
datos. Por ejemplo, si queremos representar el nombre y la edad de alguien en
Haskell, podemos utilizar un triple: <tt class="docutils literal"><span class="pre">(&quot;Christopher&quot;,</span> <span class="pre">&quot;Walken&quot;,</span> <span class="pre">55)</span></tt>. Como
hemos visto en este ejemplo las tuplas también pueden contener listas.</p>
<p>Utiliza la tuplas cuando sepas de antemano cuantos componentes de algún dato
debes tener. Las tuplas son mucho más rígidas que las listas ya que para cada
tamaño tienen su propio tipo, así que no puedes escribir una función general
que añada un elemento a una tupla: tiene que escribir una función para añadir
duplas, otra función para añadir triplas, otra función para añadir 4-tuplas,
etc.</p>
<p>Mientras que existen listas unitarias, no existen tuplas unitarias. Realmente no
tiene mucho sentido cuando lo piensas. Una tupla unitaria sería simplemente el
valor que contiene y no nos aportaría ningún beneficio.</p>
<p>Como las listas, las tuplas pueden ser comparadas si sus elementos pueden ser
comparados. Únicamente no puedes comparar dos tuplas de diferentes tamaños
mientras que si puedes comparar dos listas de diferentes tamaños. Dos funciones
útiles para operar con tuplas son:</p>
<blockquote>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">fst</span></tt> toma un par y devuelve su primer componente. ::</dt>
<dd><p class="first last">ghci&gt; fst (8,11)
8
ghci&gt; fst (&#8220;Wow&#8221;, False)
&#8220;Wow&#8221;</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">snd</span></tt> toma un par y devuelve su segundo componente. ¡Sorpresa! ::</dt>
<dd><p class="first last">ghci&gt; snd (8,11)
11
ghci&gt; snd (&#8220;Wow&#8221;, False)
False</p>
</dd>
</dl>
</li>
</ul>
</blockquote>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Estas funciones operan solo sobre duplas. No funcionaran sobre triplas,
4-tuplas, 5-tuplas, etc. Veremos más formas de extraer datos de la tuplas
un poco más tarde.</p>
</div>
<p>Ahora una función interesante que produce listas de duplas <tt class="docutils literal"><span class="pre">zip</span></tt>. Esta toma dos
listas y las une en un lista uniendo sus elementos en un par. Es una función
realmente simple pero tiene montones de usos. Es especialmente útil cuando
quieres combinar dos listas de alguna forma o recorrer dos listas
simultáneamente. Aquí tienes una demostración:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">,</span> <span class="s">&quot;five&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;three&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;four&quot;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;five&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>Como vemos, se emparejan los elementos produciendo una nueva lista. El primer
elemento va el primero, el segundo el segundo, etc. Ten en cuenta que como las
duplas pueden tener diferentes tipos, <tt class="docutils literal"><span class="pre">zip</span></tt> puede tomar dos listas que
contengan diferentes tipos y combinarlas. ¿Qué pasa si el tamaño de las listas
no coincide?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;im&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;im&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>La lista más larga simplemente se recorta para que coincida con el tamaño de
la más corta. Como Haskell es perezoso, podemos usar <tt class="docutils literal"><span class="pre">zip</span></tt> usando listas
finitas e infinitas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;cherry&quot;</span><span class="p">,</span> <span class="s">&quot;mango&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;apple&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;orange&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;cherry&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;mango&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<img alt="Pythag" class="align-center" src="../_images/pythag.png" />
<p>He aquí un problema que combina las tuplas con las listas por comprensión: ¿Qué
triángulo recto cuyos lados miden enteros menores que 10 tienen un perímetro
igual a 24? Primero, vamos a intentar generar todos los triángulos con lados
iguales o menores que 10:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">triangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>Simplemente estamos extrayendo valores de estas tres listas y nuestra función de
salida las esta combinando en un triple. Si evalúas esto escribiendo
<tt class="docutils literal"><span class="pre">triangles</span></tt> en GHCi, obtendrás una lista con todos los posibles triangulos
cuyos lados son menores o iguales que 10. Ahora, debemos añadir una condición
que nos filtre únicamente los triangulos rectos. Vamos a modificar esta función
teniendo en consideración que el lado b no es mas largo que la hipotenusa y que
el lado a no es más largo que el lado b.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Ya casi hemos acabado. Ahora, simplemente modificaremos la función diciendo
que solo queremos aquellos que su perímetro es 24.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles&#39;</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">24</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">rightTriangles&#39;</span>
<span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
<p>¡Y ahí está nuestra respuesta! Esto es un patrón muy común en la programación
funcional. Empiezas tomando un conjunto de soluciones y vas aplicando
transformaciones para ir obteniendo soluciones, filtrándolas una y otra vez
hasta obtener las soluciones correctas.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Tipos.html" title="Tipos y clases de tipos"
             >siguiente</a></li>
        <li class="right" >
          <a href="Introduccion.html" title="Introducción"
             >anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright Miran Lipovača.
      Creado con <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.4.
    </div>
  </body>
</html>