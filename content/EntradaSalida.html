
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Entrada y salida &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Resolviendo problemas de forma funcional" href="Problemas.html" />
    <link rel="prev" title="Creando nuestros propios tipos y clases de tipos" href="ClasesDeTipos.html" />
    <script type="text/javascript" src="../_static/cms.js"></script> 

  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Problemas.html" title="Resolviendo problemas de forma funcional"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="ClasesDeTipos.html" title="Creando nuestros propios tipos y clases de tipos"
             accesskey="P">anterior</a> |</li>
        <li><a href="../main.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="entrada-y-salida">
<h1>Entrada y salida<a class="headerlink" href="#entrada-y-salida" title="Enlazar permanentemente con este título">¶</a></h1>
<img alt="Secuestrador de perros" class="align-right" src="../_images/dognap.png" />
<p>Ya hemos mencionado que Haskell es un lenguaje de programación puramente
funcional. Mientras que en un lenguaje imperativo normalmente consigues
resultados dando al computador una serie de pasos ha ejecutar, la programación
funcional es más como definir que son las cosas. En Haskell, una función no
puede cambiar un estado, como cambiar el contenido de una variable (cuando una
función cambia de estado, decimos que tiene <em>efectos secundarios</em>). La única
cosa que una función de Haskell puede hacer es devolvernos algún resultado
basándose en los parámetros que le demos. Si una función es llamada dos veces
con los mismo parámetros, tiene que devolver el mismo resultado. Mientras esto
puede parecer un poco restrictivo desde el punto de vista de un mundo
imperativo, ya hemos visto como en realidad es algo genial. En un lenguaje
imperativo no tienes ninguna garantía de que una función que solo debe jugar
con unos números no vaya a quemar tu casa, secuestrar a tu perro o rallar tu
coche con una patata mientras juega con esos números. Por ejemplo, cuando
hacemos una búsqueda binaria con un árbol, no insertamos ningún elemento en
el árbol modificando algún nodo. Nuestra función para insertar un elemento en
un árbol en realidad devuelve un nuevo árbol, ya que no puede modificar el
árbol anterior.</p>
<p>Como el hecho de que las funciones no sean capaces de cambiar el estado es
algo bueno, ya que nos ayuda a razonar acerca de nuestros programas, existe un
problema con esto. Si una función no puede cambiar nada en el mundo ¿Cómo se
supone que nos va a decir el resultado que ha calculado? Para conseguir que
nos diga lo que ha calculado, tiene que cambiar el estado de un dispositivo
de salida (normalmente el estado de la pantalla), lo cual emitirá fotones que
viajaran por nuestro cerebro para cambiar el estado de nuestra mente,
impresionante.</p>
<p>No te desesperes, no está todo perdido. Haskell en realidad tiene un sistema
muy inteligente para tratar con funciones que tienen efectos secundarios de
forma que separa la parte de nuestro programa que es pura de la parte de
nuestro programa que es impura, la cual hace todo el trabajo sucio de hablar
con el teclado y la pantalla. Con estas partes bien separadas, podemos seguir
razonando acerca de nuestro programa puro y tomar ventaja de todo lo que nos
ofrece la pureza, como la evaluación perezosa, seguridad y modularidad
mientras nos comunicamos con el mundo exterior.</p>
<div class="section" id="hola-mundo">
<h2>¡Hola mundo!<a class="headerlink" href="#hola-mundo" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="¡Hola mundo!" class="align-left" src="../_images/helloworld.png" />
<p>Hasta ahora, siempre hemos cargado nuestras funciones en GHCi para probarlas y
jugar con ellas. También hemos explorado las funciones de la librería estándar
de esta forma. Pero ahora, después de ocho capítulos, por fin vamos a escribir
nuestro primer programa de Haskell real ¡Wau! Y por supuesto, vamos a crear
el mítico <tt class="docutils literal"><span class="pre">&quot;¡hola,</span> <span class="pre">mundo!&quot;</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">A efectos de este capítulo, voy a asumir que estás utilizando un
sistema <em>unix</em> para aprender Haskell. Si estás en <em>Windows</em>, te
sugiero que bajes <a class="reference external" href="http://www.cygwin.com/">cygwin</a>, el cual es un
entorno <em>Linux</em> para <em>Windows</em>, o dicho de otra forma, justo lo que
necesitas.</p>
</div>
<p>Así que para empezar, pega lo siguiente en tu editor de texto favorito:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;hello, world&quot;</span>
</pre></div>
</div>
<p>Acabamos de definir la función <tt class="docutils literal"><span class="pre">main</span></tt> y dentro de ella llamamos a una
función <tt class="docutils literal"><span class="pre">putStrLn</span></tt> con el parámetro <tt class="docutils literal"><span class="pre">&quot;hello,</span> <span class="pre">world&quot;</span></tt>. Parece algo
corriente, pero no lo es, como veremos dentro de un momento. Guarda el fichero
como <tt class="docutils literal"><span class="pre">helloworld.hs</span></tt>.</p>
<p>Y ahora vamos a hacer algo que no hemos hecho nunca antes ¡Vamos a compilar un
programa! ¿No estás nervioso? Abre un terminal y navega hasta el directorio
donde se encuentra <tt class="docutils literal"><span class="pre">helloworld.hs</span></tt> y haz lo siguiente:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ghc --make helloworld
<span class="go">[1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )</span>
<span class="go">Linking helloworld ...</span>
</pre></div>
</div>
<p>¡Vale! Con un poco de suerte habrás obtenido algo similar y podrás ejecutar
el programa haciendo <tt class="docutils literal"><span class="pre">./helloworld</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ./helloworld
<span class="go">hello, world</span>
</pre></div>
</div>
<p>Ahí lo tienes, nuestro primer programa compilado que muestra un mensaje por la
terminal ¡Extraordinariamente aburrido!</p>
<p>Vamos a examinar lo que hemos escrito. Primero, vamos a ver el tipo de la
función <tt class="docutils literal"><span class="pre">putStrLn</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; :t putStrLn</span>
<span class="go">putStrLn :: String -&gt; IO ()</span>
<span class="go">ghci&gt; :t putStrLn &quot;hello, world&quot;</span>
<span class="go">putStrLn &quot;hello, world&quot; :: IO ()</span>
</pre></div>
</div>
<p>Podemos leer el tipo de <tt class="docutils literal"><span class="pre">putStrLn</span></tt> como: <tt class="docutils literal"><span class="pre">putStrLn</span></tt> toma una cadena y
devuelve una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que devuelve un tipo <tt class="docutils literal"><span class="pre">()</span></tt> (es decir, la tupla
vacía, también conocida como unidad). Una acción <tt class="docutils literal"><span class="pre">IO</span></tt> es algo que cuando
se realiza, cargará con una acción con algún efecto secundario (como leer
desde la entrada o mostrar cosas por pantalla) y contendrá algún tipo de de
valor dentro de él. Mostrar algo por pantalla realmente no tiene ningún tipo
de valor resultado, así que se utiliza el valor ficticio <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">La tupla vacía tiene el valor de <tt class="docutils literal"><span class="pre">()</span></tt> y también tiene el tipo
<tt class="docutils literal"><span class="pre">()</span></tt>. Algo como <tt class="docutils literal"><span class="pre">data</span> <span class="pre">Nada</span> <span class="pre">=</span> <span class="pre">Nada</span></tt>.</p>
</div>
<p>Y ¿Cuándo se ejecuta una acción <tt class="docutils literal"><span class="pre">IO</span></tt>? Bueno, aquí es donde entra en juego
<tt class="docutils literal"><span class="pre">main</span></tt>. Una acción <tt class="docutils literal"><span class="pre">IO</span></tt> se ejecuta cuando le damos el nombre` <tt class="docutils literal"><span class="pre">main</span></tt> y
ejecutamos nuestro programa.</p>
<p>Tener todo tu programa en una sola acción <tt class="docutils literal"><span class="pre">IO</span></tt> puede parecer un poco
restringido. Por este motivo podemos usar la sintaxis <tt class="docutils literal"><span class="pre">do</span></tt> para juntar
varias acciones <tt class="docutils literal"><span class="pre">IO</span></tt> en una. Echa un vistazo al siguiente ejemplo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Hey &quot;</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">&quot;, you rock!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Ah... Interesante ¡Sintaxis nueva! Se lee de forma similar a la de un programa
imperativo. Si lo compilas y lo ejecutas, probablemente se comportará como
esperas. Fíjate que hemos utilizado un <tt class="docutils literal"><span class="pre">do</span></tt> y luego hemos puesto una serie
de pasos, exactamente igual que en un programa imperativo. Cada uno de estos
pasos es una acción <tt class="docutils literal"><span class="pre">IO</span></tt>. Poniéndolas todas ellas juntas en un mismo bloque
<tt class="docutils literal"><span class="pre">do</span></tt> conseguimos una sola acción <tt class="docutils literal"><span class="pre">IO</span></tt>. La acción que obtenemos tiene el
tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></tt> porque ese es el tipo de la última acción dentro del bloque.</p>
<p>Por este motivo, <tt class="docutils literal"><span class="pre">main</span></tt> siempre tiene que tener el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">algo</span></tt>, donde
<tt class="docutils literal"><span class="pre">algo</span></tt> es algún tipo concreto. Por convenio, no se suele especificar la
declaración de tipo de <tt class="docutils literal"><span class="pre">main</span></tt>.</p>
<p>Una cosa interesante que no hemos visto antes está en la tercera línea, la
cual es <tt class="docutils literal"><span class="pre">name</span> <span class="pre">&lt;-</span> <span class="pre">getLine</span></tt>.  Parece como si leyera una línea de texto y la
guardara en una variable llamada <tt class="docutils literal"><span class="pre">name</span></tt> ¿De verdad? Bueno, vamos a examinar
el tipo de <tt class="docutils literal"><span class="pre">getLine</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; :t getLine</span>
<span class="go">getLine :: IO String</span>
</pre></div>
</div>
<img alt="Caja con patas" class="align-left" src="../_images/luggage.png" />
<p>Vale. <tt class="docutils literal"><span class="pre">getLine</span></tt> es una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que contiene un resultado del tipo
<tt class="docutils literal"><span class="pre">String</span></tt>. Parece que tiene sentido ya que esperará a que el usuario escriba
algo en la terminal y luego ese algo será representado con una cadena.
Entonces ¿Qué pasa con <tt class="docutils literal"><span class="pre">name</span> <span class="pre">&lt;-</span> <span class="pre">getLine</span></tt>? Puedes leer ese trozo de código
como: realiza la acción <tt class="docutils literal"><span class="pre">getLine</span></tt> y luego liga el resultado al valor
<tt class="docutils literal"><span class="pre">name</span></tt>. <tt class="docutils literal"><span class="pre">getLine</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt>, así que <tt class="docutils literal"><span class="pre">name</span></tt> tendrá el
tipo <tt class="docutils literal"><span class="pre">String</span></tt>. Puedes imaginar una acción <tt class="docutils literal"><span class="pre">IO</span></tt> como una caja con patas que
saldrá al mundo real y hará algo allí (como pintar un grafiti en una pared) y
quizá vuelva con algún dato dentro. Una vez se ha traído ese dato, la única
forma de abrir la caja y tomar el dato de su interior es utilizando la
construcción <tt class="docutils literal"><span class="pre">&lt;-</span></tt>. Y si estamos extrayendo datos de una acción <tt class="docutils literal"><span class="pre">IO</span></tt>, solo
podemos sacarlos cuando estemos dentro de alguna acción <tt class="docutils literal"><span class="pre">IO</span></tt>. Así es como
Haskell gestiona y separa las partes puras e impuras de nuestro código.
En ese sentido <tt class="docutils literal"><span class="pre">getLine</span></tt> es impuro ya que el resultado no está garantizado
que sea el mismo cuando se llamada dos veces. Este es el porqué su resultado
está <em>contaminado</em> con constructor de tipos <tt class="docutils literal"><span class="pre">IO</span></tt> y solo podemos extraer
estos datos dentro de un código <tt class="docutils literal"><span class="pre">IO</span></tt>. Y como el código <tt class="docutils literal"><span class="pre">IO</span></tt> está
contaminado también, cada cálculo que dependa en un dato contaminado con
<tt class="docutils literal"><span class="pre">IO</span></tt> tendrá un resultado contaminado también.</p>
<p>Cuando decimos <em>contaminado</em>, no lo decimos en el sentido de que nunca más
podremos usar el resultado contenido en una acción <tt class="docutils literal"><span class="pre">IO</span></tt> en nuestro código
puro. No, cuando ligamos un valor contenido en una acción <tt class="docutils literal"><span class="pre">IO</span></tt> a un nombre
lo <em>descontaminamos</em> temporalmente. Cuando hacemos <tt class="docutils literal"><span class="pre">nombre</span> <span class="pre">&lt;-</span> <span class="pre">getLine</span></tt>,
<tt class="docutils literal"><span class="pre">nombre</span></tt> es una cadena normal, ya que representa lo que hay dentro de la
caja. Podemos tener un función realmente complicada que, digamos, toma tu
nombre (una cade normal) como parámetro y predice tu suerte y todo tu futuro
basándose únicamente en tu nombre. Podría ser algo así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Read this carefully, because this is your future: &quot;</span> <span class="o">++</span> <span class="n">tellFortune</span> <span class="n">name</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">tellFortune</span></tt> (o cualquier otra función a la que se le pase <tt class="docutils literal"><span class="pre">name</span></tt>) no
tiene porque saber nada acerca de <tt class="docutils literal"><span class="pre">IO</span></tt>, es simplemente una función normal de
tipo <tt class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span></tt>.</p>
<p>Mira este trozo de código ¿Es válido?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">nameTag</span> <span class="ow">=</span> <span class="s">&quot;Hello, my name is &quot;</span> <span class="o">++</span> <span class="n">getLine</span>
</pre></div>
</div>
<p>Si has dicho que no, puedes ir a por una galletita. Si haz dicho que sí, ves
olvidándote de caprichos. La razón por la que esto no funciona es que <tt class="docutils literal"><span class="pre">++</span></tt>
requiere que sus dos parámetros sean del mismo tipo lista. El parámetro de la
izquierda tiene el tipo <tt class="docutils literal"><span class="pre">String</span></tt> (o <tt class="docutils literal"><span class="pre">[Char]</span></tt> si lo prefieres), mientras
que <tt class="docutils literal"><span class="pre">getLine</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt>. No podemos concatenar una cadena
con una acción <tt class="docutils literal"><span class="pre">IO</span></tt>. Primero debemos extraer el resultado de la acción
<tt class="docutils literal"><span class="pre">IO</span></tt> para obtener un valor del tipo <tt class="docutils literal"><span class="pre">String</span></tt> y la única forma de
conseguirlo es haciendo algo como <tt class="docutils literal"><span class="pre">name</span> <span class="pre">&lt;-</span> <span class="pre">getLine</span></tt> dentro de una acción
<tt class="docutils literal"><span class="pre">IO</span></tt>. Si queremos tratar con datos impuros tenemos que hacerlo en un entorno
impuro. La mancha de la impureza se propaga al igual que una plaga por nuestro
código y es nuestro deber mantener las partes <tt class="docutils literal"><span class="pre">IO</span></tt> tan pequeñas como sean
posibles.</p>
<p>Cada acción <tt class="docutils literal"><span class="pre">IO</span></tt> que es ejecutada tiene un resultado encapsulado con él.
Por este motivo podríamos haber escrito el código anterior como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">foo</span> <span class="ow">&lt;-</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Hey &quot;</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">&quot;, you rock!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Sin embargo, <tt class="docutils literal"><span class="pre">foo</span></tt> simplemente tendría el valor <tt class="docutils literal"><span class="pre">()</span></tt> lo cual no es de
mucha utilidad. Fíjate que no hemos ligado el último <tt class="docutils literal"><span class="pre">putStrLn</span></tt> a ningún
nombre. Esto es debido a que en un bloque <tt class="docutils literal"><span class="pre">do</span></tt>, <strong>la última acción no puede
ser ligada</strong> como las dos primeras. Cuando nos aventuremos en el mundo de las
mónadas veremos el motivo concreto de esta restricción. Por ahora, puedes
pensar que un bloque <tt class="docutils literal"><span class="pre">do</span></tt> extrae automáticamente el valor de la última
acción y lo liga a su propio resultado.</p>
<p>Excepto para la última línea, cada línea de un bloque <tt class="docutils literal"><span class="pre">do</span></tt> que no se liga
puede también escribirse como una ligadura. Así que <tt class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">&quot;Blah&quot;</span></tt> se
puede escribir como <tt class="docutils literal"><span class="pre">_</span> <span class="pre">&lt;-</span> <span class="pre">putStrLn</span> <span class="pre">&quot;Blah&quot;</span></tt>. Sin embargo es algo inútil, por
lo que no usamos <tt class="docutils literal"><span class="pre">&lt;-</span></tt> para acciones que no contienen un resultado
importante, como <tt class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">algo</span></tt>.</p>
<p>Los principiantes a veces piensan que hacer cosas como <tt class="docutils literal"><span class="pre">name</span> <span class="pre">=</span> <span class="pre">getLine</span></tt>
leerá una línea por la entrada y la ligará a <tt class="docutils literal"><span class="pre">name</span></tt>. Bueno, pues no, lo que
hace esto es darle a la acción <tt class="docutils literal"><span class="pre">getLine</span></tt> un nuevo nombre, llamado <tt class="docutils literal"><span class="pre">name</span></tt>.
Recuerda que para obtener el valor contenido dentro de una acción <tt class="docutils literal"><span class="pre">IO</span></tt>,
tienes que ligarlo a un nombre con <tt class="docutils literal"><span class="pre">&lt;-</span></tt> dentro de otra acción <tt class="docutils literal"><span class="pre">IO</span></tt>.</p>
<p>Las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> solo son ejecutadas cuando se les dan el nombre de
<tt class="docutils literal"><span class="pre">main</span></tt> o cuando están dentro de una acción <tt class="docutils literal"><span class="pre">IO</span></tt> más grande que hemos
compuesto con un bloque <tt class="docutils literal"><span class="pre">do</span></tt>. Podemos usar un bloque <tt class="docutils literal"><span class="pre">do</span></tt> para juntar
algunas acciones <tt class="docutils literal"><span class="pre">IO</span></tt> y luego usar esa acción <tt class="docutils literal"><span class="pre">IO</span></tt> dentro de otro bloque
<tt class="docutils literal"><span class="pre">do</span></tt> y así sucesivamente. De cualquier modo, al final solo se ejecutarán
cuando sean alcanzadas por <tt class="docutils literal"><span class="pre">main</span></tt>.</p>
<p>Oh, cierto, también hay otro caso en el que las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> son
ejecutadas. Cuando escribimos una acción <tt class="docutils literal"><span class="pre">IO</span></tt> en GHCi y pulsamos intro.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; putStrLn &quot;HEEY&quot;</span>
<span class="go">HEEY</span>
</pre></div>
</div>
<p>Incluso cuando escribimos un número o una llamada a una función en GHCi, éste
lo evaluará (tanto como necesite) y luego llamará a <tt class="docutils literal"><span class="pre">show</span></tt> para mostrar esa
cadena en la terminal utilizando <tt class="docutils literal"><span class="pre">putStrLn</span></tt> de forma implícita.</p>
<p>¿Recuerdas las secciones <tt class="docutils literal"><span class="pre">let</span></tt>? Si no, refresca tu memoria leyendo esta
<a class="reference internal" href="Funciones.html#leitbe"><em>sección</em></a>. Tienen la forma <tt class="docutils literal"><span class="pre">let</span> <span class="pre">ligaduras</span> <span class="pre">in</span> <span class="pre">expresión</span></tt>, donde
<tt class="docutils literal"><span class="pre">ligaduras</span></tt> son los nombres que se les dan a las expresiones y <tt class="docutils literal"><span class="pre">expresión</span></tt>
será la expresión donde serán evaluadas. También dijimos que las listas por
comprensión no era necesaria la parte <tt class="docutils literal"><span class="pre">in</span></tt>. Bueno, puedes usarlas en un
bloque <tt class="docutils literal"><span class="pre">do</span></tt> prácticamente igual que en las listas por comprensión. Mira
esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">mport</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Char</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;What&#39;s your first name?&quot;</span>
    <span class="n">firstName</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="s">&quot;What&#39;s your last name?&quot;</span>
    <span class="n">lastName</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="kr">let</span> <span class="n">bigFirstName</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">firstName</span>
        <span class="n">bigLastName</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">lastName</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;hey &quot;</span> <span class="o">++</span> <span class="n">bigFirstName</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">bigLastName</span> <span class="o">++</span> <span class="s">&quot;, how are you?&quot;</span>
</pre></div>
</div>
<p>¿Ves como las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> dentro del bloque <tt class="docutils literal"><span class="pre">do</span></tt> están alineadas? Fíjate
también en como la sección <tt class="docutils literal"><span class="pre">let</span></tt> está alineada con las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> y los
nombres de <tt class="docutils literal"><span class="pre">let</span></tt> están alineados entre ellos. Es una buena práctica hacer
esto, ya que el sangrando es importante en Haskell. Hemos hecho <tt class="docutils literal"><span class="pre">map</span> <span class="pre">toUpper</span>
<span class="pre">firstName</span></tt>, lo cual convierte algo como <tt class="docutils literal"><span class="pre">&quot;john&quot;</span></tt> en la cadena <tt class="docutils literal"><span class="pre">&quot;JOHN&quot;</span></tt>.
Hemos ligado esa cadena en mayúsculas a un nombre y luego la hemos utilizado
en una cadena para mostrarla por la terminal.</p>
<p>Puedes estar preguntándote cuando utilizar <tt class="docutils literal"><span class="pre">&lt;-</span></tt> y cuando utilizar <tt class="docutils literal"><span class="pre">let</span></tt>.
Bueno, recuerda que <tt class="docutils literal"><span class="pre">&lt;-</span></tt> es (por ahora) para ejecutar acciones <tt class="docutils literal"><span class="pre">IO</span></tt> y
ligar sus resultados. Sin embargo, <tt class="docutils literal"><span class="pre">map</span> <span class="pre">toUpper</span> <span class="pre">firstName</span></tt> no es una acción
<tt class="docutils literal"><span class="pre">IO</span></tt>. Es una expresión pura de Haskell. Así que utilizamos <tt class="docutils literal"><span class="pre">&lt;-</span></tt> cuando
queremos ligar los resultados de una acción <tt class="docutils literal"><span class="pre">IO</span></tt> mientras que usamos <tt class="docutils literal"><span class="pre">let</span></tt>
para ligar expresiones puras. Si hubiéramos hecho algo como <tt class="docutils literal"><span class="pre">let</span> <span class="pre">firstName</span> <span class="pre">=</span>
<span class="pre">getLine</span></tt>, simplemente hubiéramos dado un nuevo nombre a la acción <tt class="docutils literal"><span class="pre">getLine</span></tt>
y seguiríamos necesitado utilizar <tt class="docutils literal"><span class="pre">&lt;-</span></tt> para ejecutar la acción.</p>
<p>Ahora vamos a crear un programa que lee continuamente una línea y muestra esa
línea con sus palabras al revés. La ejecución del programa se detendrá cuando
encuentre una línea vacía. Aquí tienes el programa.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="kr">if</span> <span class="n">null</span> <span class="n">line</span>
        <span class="kr">then</span> <span class="n">return</span> <span class="nb">()</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">reverseWords</span> <span class="n">line</span>
            <span class="n">main</span>

<span class="nf">reverseWords</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">reverseWords</span> <span class="ow">=</span> <span class="n">unwords</span> <span class="o">.</span> <span class="n">map</span> <span class="n">reverse</span> <span class="o">.</span> <span class="n">words</span>
</pre></div>
</div>
<p>Para entender como funciona, puedes ejecutar el programa antes de leer el
código.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Para ejecutar un programa puedes o bien compilarlo produciendo un
ejecutable y luego ejecutarlo usando <tt class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span> <span class="pre">helloworld</span></tt> y
luego <tt class="docutils literal"><span class="pre">./helloworld</span></tt> o bien puedes usar el comando <tt class="docutils literal"><span class="pre">runhaskell</span></tt>
así: <tt class="docutils literal"><span class="pre">runhaskell</span> <span class="pre">helloworld.hs</span></tt> y tu programa será ejecutado al
vuelo.</p>
</div>
<p>Primero vamos a echar un vistazo a la función <tt class="docutils literal"><span class="pre">reverseWords</span></tt>. Es solo una
función normal que toma una cadena como <tt class="docutils literal"><span class="pre">&quot;hey</span> <span class="pre">there</span> <span class="pre">man&quot;</span></tt> y luego llama
a <tt class="docutils literal"><span class="pre">words</span></tt> lo cual produce una lista de palabras como
<tt class="docutils literal"><span class="pre">[&quot;hey&quot;,&quot;there&quot;,&quot;man&quot;]</span></tt>. Luego mapeamos <tt class="docutils literal"><span class="pre">reverse</span></tt> sobre la lista,
obteniendo <tt class="docutils literal"><span class="pre">[&quot;yeh&quot;,&quot;ereht&quot;,&quot;nam&quot;]</span></tt>, luego volvemos a tener una sola cadena
utilizando <tt class="docutils literal"><span class="pre">unwords</span></tt> y el resultado final es <tt class="docutils literal"><span class="pre">&quot;yeh</span> <span class="pre">ereht</span> <span class="pre">nam&quot;</span></tt>. Fíjate en
como hemos utilizado la composición de funciones. Sin la composición de
funciones tendríamos que haber escrito algo como <tt class="docutils literal"><span class="pre">reverseWords</span> <span class="pre">st</span> <span class="pre">=</span> <span class="pre">unwords</span>
<span class="pre">(map</span> <span class="pre">reverse</span> <span class="pre">(words</span> <span class="pre">st))</span></tt>.</p>
<p>¿Qué pasa con <tt class="docutils literal"><span class="pre">main</span></tt>? Primero, obtenemos una línea del terminal ejecutando
<tt class="docutils literal"><span class="pre">getLine</span></tt> y la llamamos <tt class="docutils literal"><span class="pre">line</span></tt>. Y ahora tenemos una expresión condicional.
Recuerda que en Haskell, cada <tt class="docutils literal"><span class="pre">if</span></tt> debe tener su <tt class="docutils literal"><span class="pre">else</span></tt> ya que toda
expresión debe tener algún tipo de valor. Usamos la condición de forma que
cuando sea cierta (en nuestro caso, para cuando la línea esté vacía)
realicemos una acción <tt class="docutils literal"><span class="pre">IO</span></tt> y cuando no lo es, realizamos la acción ubicada
en el <tt class="docutils literal"><span class="pre">else</span></tt>. Por este motivo las condiciones dentro de una acción <tt class="docutils literal"><span class="pre">IO</span></tt>
tienen la forma <tt class="docutils literal"><span class="pre">if</span> <span class="pre">condición</span> <span class="pre">then</span> <span class="pre">acción</span> <span class="pre">else</span> <span class="pre">acción</span></tt>.</p>
<p>Vamos a echar un vistazo a lo que pasa bajo la cláusula <tt class="docutils literal"><span class="pre">else</span></tt>. Como debemos
tener exactamente una sola acción <tt class="docutils literal"><span class="pre">IO</span></tt> después del <tt class="docutils literal"><span class="pre">else</span></tt> tenemos que usar
un bloque <tt class="docutils literal"><span class="pre">do</span></tt> para juntar todas la acciones en una. También podía ser
escrito así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">else</span> <span class="p">(</span><span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">reverseWords</span> <span class="n">line</span>
    <span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>Esto hace más explícito el hecho de que un bloque <tt class="docutils literal"><span class="pre">do</span></tt> sea visto como una
sola acción <tt class="docutils literal"><span class="pre">IO</span></tt>, pero es más feo. De cualquier modo, dentro del bloque
<tt class="docutils literal"><span class="pre">do</span></tt> llamamos a <tt class="docutils literal"><span class="pre">reverseWords</span></tt> sobre la línea que obtuvimos de <tt class="docutils literal"><span class="pre">getLine</span></tt>
y luego mostramos el resultado por la terminal. Luego de esto, simplemente
ejecutamos <tt class="docutils literal"><span class="pre">main</span></tt>. Es llamado de forma recursiva y no hay ningún problema
ya que <tt class="docutils literal"><span class="pre">main</span></tt> es por si mismo una acción <tt class="docutils literal"><span class="pre">IO</span></tt>. De cierto modo es como
si volviéramos al inicio del programa.</p>
<p>Ahora ¿Qué sucede cuando <tt class="docutils literal"><span class="pre">null</span> <span class="pre">line</span></tt> se evalúa a cierto? Se ejecuta la
acción que está después del <tt class="docutils literal"><span class="pre">then</span></tt>. Si buscamos veremos que pone <tt class="docutils literal"><span class="pre">then`</span>
<span class="pre">return</span> <span class="pre">()</span></tt>. Si conoces algún lenguaje imperativo como <em>C</em>, <em>Java</em>
<em>Python</em>, probablemente estés pensando que ya sabes lo que es <tt class="docutils literal"><span class="pre">return</span></tt> y
que puedes saltarte este párrafo tan largo. Bueno, pues <strong>el</strong> <tt class="docutils literal"><span class="pre">return</span></tt> <strong>de
Haskell no tiene nada que ver con el</strong> <tt class="docutils literal"><span class="pre">return</span></tt> <strong>de la mayoría de los otros
lenguajes</strong>. Tiene el mismo nombre, lo cual confunde a mucha a gente, pero en
realidad es muy diferente. En los lenguajes imperativos, <tt class="docutils literal"><span class="pre">return</span></tt>
normalmente termina la ejecución de un método o una subrutina y devuelve algún
tipo de valor a quien quiera que lo llamó. En Haskell (dentro de la acciones
<tt class="docutils literal"><span class="pre">IO</span></tt> concretamente), lo que hace es convertir un valor puro en una acción
<tt class="docutils literal"><span class="pre">IO</span></tt>. Si lo piensas como en la analogía de la caja que vimos, <tt class="docutils literal"><span class="pre">return</span></tt>
toma un valor y lo pone dentro de una caja. La acción <tt class="docutils literal"><span class="pre">IO</span></tt> resultante
realmente no hace nada, simplemente tiene dicho valor como resultado. Así que
en un contexto <tt class="docutils literal"><span class="pre">IO</span></tt>, <tt class="docutils literal"><span class="pre">return</span> <span class="pre">&quot;haha&quot;</span></tt> tendrá el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt> ¿Cuál es
el motivo de transformar un valor puro en una acción que realmente no hace
nada? ¿Por qué contaminar más nuestro programa con <tt class="docutils literal"><span class="pre">IO</span></tt>? Bueno, necesitamos
alguna acción <tt class="docutils literal"><span class="pre">IO</span></tt> en caso de que encontremos una línea vacía. Por este
motivo hemos creado una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que realmente no hace nada con <tt class="docutils literal"><span class="pre">return</span>
<span class="pre">()</span></tt>.</p>
<p>Al utilizar <tt class="docutils literal"><span class="pre">return</span></tt> no causamos que un bloque <tt class="docutils literal"><span class="pre">do</span></tt> termine su ejecución
ni nada parecido. Por ejemplo, este programa ejecutará hasta la última línea
sin ningún problema.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">return</span> <span class="nb">()</span>
    <span class="n">return</span> <span class="s">&quot;HAHAHA&quot;</span>
    <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">return</span> <span class="s">&quot;BLAH BLAH BLAH&quot;</span>
    <span class="n">return</span> <span class="mi">4</span>
    <span class="n">putStrLn</span> <span class="n">line</span>
</pre></div>
</div>
<p>Todo lo que estos <tt class="docutils literal"><span class="pre">return</span></tt> hacen es crear acciones <tt class="docutils literal"><span class="pre">IO</span></tt> que en realidad
no hacen nada excepto contener un valor, el cual es desperdiciado ya que no
se liga a ningún nombre. Podemos utilizar <tt class="docutils literal"><span class="pre">return</span></tt> en combinación con <tt class="docutils literal"><span class="pre">&lt;-</span></tt>
para ligar cosas a nombres.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="s">&quot;hell&quot;</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">return</span> <span class="s">&quot;yeah!&quot;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">b</span>
</pre></div>
</div>
<p>Como puedes ver, <tt class="docutils literal"><span class="pre">return</span></tt> es en cierto modo lo opuesto de <tt class="docutils literal"><span class="pre">&lt;-</span></tt>. Mientras
que <tt class="docutils literal"><span class="pre">return</span></tt> toma valores y los mete en una caja, <tt class="docutils literal"><span class="pre">&lt;-</span></tt> toma una caja (y
la ejecuta) y saca el valor que contiene, enlazándolo a un nombre. Sin embargo
hacer estas cosas es un poco redundante, ya que puedes utilizar secciones
<tt class="docutils literal"><span class="pre">let</span></tt> para conseguir lo mismo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="s">&quot;hell&quot;</span>
        <span class="n">b</span> <span class="ow">=</span> <span class="s">&quot;yeah&quot;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">b</span>
</pre></div>
</div>
<p>Cuando tratemos con bloques <tt class="docutils literal"><span class="pre">do</span></tt> <tt class="docutils literal"><span class="pre">IO</span></tt>, normalmente utilizamos <tt class="docutils literal"><span class="pre">return</span></tt> o
bien porque queremos crear una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que no haga nada o bien porque
queremos que el resultado que albergue la acción <tt class="docutils literal"><span class="pre">IO</span></tt> resultante de un
bloque <tt class="docutils literal"><span class="pre">do</span></tt> no sea el valor de la última acción.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Un bloque <tt class="docutils literal"><span class="pre">do</span></tt> puede contener una sola acción <tt class="docutils literal"><span class="pre">IO</span></tt>. En ese caso,
es lo mismo que escribir solo dicha acción. Hay gente que prefiere
escribir <tt class="docutils literal"><span class="pre">then</span> <span class="pre">do</span> <span class="pre">return</span> <span class="pre">()</span></tt> en este caso ya que el <tt class="docutils literal"><span class="pre">else</span></tt>
también tiene un <tt class="docutils literal"><span class="pre">do</span></tt>.</p>
</div>
<p>Antes de que veamos como tratar con ficheros, vamos a echar un vistazo a
algunas funciones que son útiles a la hora de trabajar con <tt class="docutils literal"><span class="pre">IO</span></tt>.</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">putStr</span></tt> es muy parecido a <tt class="docutils literal"><span class="pre">putStrLn</span></tt> en el sentido de que toma una
cadena y devuelve una acción que imprimirá esa cadena por la terminal, solo
que <tt class="docutils literal"><span class="pre">putStr</span></tt> no salta a una nueva línea después de imprimir la cadena tal
y como <tt class="docutils literal"><span class="pre">putStrLn</span></tt> hace.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>   <span class="n">putStr</span> <span class="s">&quot;Hey, &quot;</span>
            <span class="n">putStr</span> <span class="s">&quot;I&#39;m &quot;</span>
            <span class="n">putStrLn</span> <span class="s">&quot;Andy!&quot;</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell putstr_test.hs
<span class="go">Hey, I&#39;m Andy!</span>
</pre></div>
</div>
<p>Su tipo es <tt class="docutils literal"><span class="pre">putStr</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></tt>, así que el resultado contenido en
la acción <tt class="docutils literal"><span class="pre">IO</span></tt> es la unidad. Un valor inútil, por lo que no tiene sentido
ligarlo a nada.</p>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">putChar</span></tt> toma un carácter y devuelve una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que lo imprimirá
por la terminal.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>   <span class="n">putChar</span> <span class="sc">&#39;t&#39;</span>
            <span class="n">putChar</span> <span class="sc">&#39;e&#39;</span>
            <span class="n">putChar</span> <span class="sc">&#39;h&#39;</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell putchar_test.hs
<span class="go">teh</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">putStr</span></tt> en realidad está definido recursivamente con ayuda de
<tt class="docutils literal"><span class="pre">putChar</span></tt>. El caso base es la cadena vacía, así que si estamos
imprimiendo la cadena vacía, simplemente devolvemos una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que
no haga nada utilizando <tt class="docutils literal"><span class="pre">return</span> <span class="pre">()</span></tt>. Si no esta vacía, imprimimos el
primer carácter de la cadena utilizando <tt class="docutils literal"><span class="pre">putChar</span></tt> y luego imprimimos el
resto de la cadena usando <tt class="docutils literal"><span class="pre">putStr</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">putStr</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">putStr</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">putStr</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putChar</span> <span class="n">x</span>
    <span class="n">putStr</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Fíjate en que podemos utilizar la recursión en <tt class="docutils literal"><span class="pre">IO</span></tt> de la misma forma que
lo hacemos en el código puro. Al igual que en el código puro, definimos el
caso base y luego pensamos que es realmente el resultado. Es una acción que
primero imprime el primer carácter y luego imprime el resto de la cadena.</p>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">print</span></tt> toma un valor de cualquier tipo que sea miembro de la clase
<tt class="docutils literal"><span class="pre">Show</span></tt> (por lo que sabemos que se puede representar como una cadena),
llama a <tt class="docutils literal"><span class="pre">show</span></tt> con ese valor para obtener su representación y luego
muestra esa cadena por la terminal. Básicamente es <tt class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">.</span> <span class="pre">show</span></tt>.
Primero ejecuta <tt class="docutils literal"><span class="pre">show</span></tt> con un valor y luego alimenta <tt class="docutils literal"><span class="pre">putStrLn</span></tt> con
ese valor, lo cual devuelve una acción que imprimirá nuestro valor.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>   <span class="n">print</span> <span class="kt">True</span>
            <span class="n">print</span> <span class="mi">2</span>
            <span class="n">print</span> <span class="s">&quot;haha&quot;</span>
            <span class="n">print</span> <span class="mf">3.2</span>
            <span class="n">print</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell print_test.hs
<span class="go">True</span>
<span class="go">2</span>
<span class="go">&quot;haha&quot;</span>
<span class="go">3.2</span>
<span class="go">[3,4,3]</span>
</pre></div>
</div>
<p>Como puedes ver, es una función muy útil ¿Recuerdas cuando hablamos de que
las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> se ejecutan solo cuando son alcanzadas por <tt class="docutils literal"><span class="pre">main</span></tt> o
cuando intentamos evaluarlas en GHCi? Cuando escribimos un valor (como
<tt class="docutils literal"><span class="pre">3</span></tt> o <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>) y pulsamos intro, GHCi en realidad utiliza <tt class="docutils literal"><span class="pre">print</span></tt>
con ese valor para mostrarlo por la terminal.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; 3</span>
<span class="go">3</span>
<span class="go">ghci&gt; print 3</span>
<span class="go">3</span>
<span class="go">ghci&gt; map (++&quot;!&quot;) [&quot;hey&quot;,&quot;ho&quot;,&quot;woo&quot;]</span>
<span class="go">[&quot;hey!&quot;,&quot;ho!&quot;,&quot;woo!&quot;]</span>
<span class="go">ghci&gt; print (map (++&quot;!&quot;) [&quot;hey&quot;,&quot;ho&quot;,&quot;woo&quot;])</span>
<span class="go">[&quot;hey!&quot;,&quot;ho!&quot;,&quot;woo!&quot;]</span>
</pre></div>
</div>
<p>Cuando queremos imprimir cadenas normalmente utilizamos <tt class="docutils literal"><span class="pre">putStrLn</span></tt> ya que
solemos querer las dobles comillas que rodean la representación de una
cadena, pero para mostrar valores de cualquier otro tipo se suele utilizar
<tt class="docutils literal"><span class="pre">print</span></tt>.</p>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">getChar</span></tt> es una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que lee un carácter por la entrada
estándar (teclado). Por ello, su tipo es <tt class="docutils literal"><span class="pre">getChar</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">Char</span></tt>, ya que
el resultado contenido dentro de la acción <tt class="docutils literal"><span class="pre">IO</span></tt> es un carácter. Ten en
cuenta que debido al <em>buffering</em>, la acción de leer un carácter no se
ejecuta hasta que el usuario pulsa la tecla intro.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>
    <span class="kr">if</span> <span class="n">c</span> <span class="o">/=</span> <span class="sc">&#39; &#39;</span>
        <span class="kr">then</span> <span class="kr">do</span>
            <span class="n">putChar</span> <span class="n">c</span>
            <span class="n">main</span>
        <span class="kr">else</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Este programa parece que debe leer un carácter y comprobar si es un
espacio. Si lo es, detiene la ejecución del programa y si no lo es, lo
imprime por la terminal y luego repite su ejecución. Bueno, parece que
hace esto, pero no lo hace de la forma que esperamos. Compruébalo.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell getchar_test.hs
<span class="go">hello sir</span>
<span class="go">hello</span>
</pre></div>
</div>
<p>La segunda línea es la salida. Hemos escrito <tt class="docutils literal"><span class="pre">hello</span> <span class="pre">sir</span></tt> y luego hemos
pulsado intro. Debido al <em>buffering</em>, la ejecución del programa solo
empieza después de ejecutar intro y no después de cada carácter pulsado.
Una vez pulsamos intro, actúa como si hubiéramos escrito esos caracteres
desde el principio. Intenta jugar un poco con este programa para entender
como funciona.</p>
</li>
<li><p class="first">La función <tt class="xref cpp cpp-member docutils literal"><span class="pre">when</span></tt> se encuentra en el módulo <tt class="docutils literal"><span class="pre">Control.Monad</span></tt> (para
acceder a ella haz <tt class="docutils literal"><span class="pre">import</span> <span class="pre">Control.Monad</span></tt>). Es interesante ya que dentro
de un bloque <tt class="docutils literal"><span class="pre">do</span></tt> parece como si fuese una sentencia de control de flujo,
pero en realidad es una función normal. Toma un valor booleano y una acción
<tt class="docutils literal"><span class="pre">IO</span></tt> de forma que si el valor booleano es <tt class="xref docutils literal"><span class="pre">True</span></tt>, devolverá la misma
acción que le suministremos. Sin embargo, si es falso, nos devolverá una
acción <tt class="docutils literal"><span class="pre">return</span> <span class="pre">()</span></tt>, acción que no hace absolutamente nada. Aquí tienes
como podríamos haber escrito el trozo de código anterior que mostraba el
uso de <tt class="docutils literal"><span class="pre">getChar</span></tt> utilizando <tt class="docutils literal"><span class="pre">when</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">getChar</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">c</span> <span class="o">/=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="n">putChar</span> <span class="n">c</span>
        <span class="n">main</span>
</pre></div>
</div>
<p>Como puedes ver, es útil para encapsular el patrón <cite>ìf algo then do acción
else return ()`</cite>. También existe la función <tt class="docutils literal"><span class="pre">unless</span></tt> que es exactamete
igual a <tt class="docutils literal"><span class="pre">when</span></tt> solo que devuleve la acción original cuando ecuentra
<tt class="xref docutils literal"><span class="pre">False</span></tt> en lugar de <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">sequence</span></tt> toma una lista de acciones <tt class="docutils literal"><span class="pre">IO</span></tt> y devuevle una acción que
realizará todas esas acciones una detrás de otra. El resultado contenido en
la acción <tt class="docutils literal"><span class="pre">IO</span></tt> será una lista con todos los resultados de todas las
acciones <tt class="docutils literal"><span class="pre">IO</span></tt> que fueron ejecutadas. Su tipo es <tt class="docutils literal"><span class="pre">sequence</span> <span class="pre">::</span> <span class="pre">[IO</span> <span class="pre">a]</span> <span class="pre">-&gt;`</span>
<span class="pre">IO</span> <span class="pre">[a]</span></tt>. Hacer esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">print</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span>
</pre></div>
</div>
<p>Es exactamente lo mismo que hacer:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">rs</span> <span class="ow">&lt;-</span> <span class="n">sequence</span> <span class="p">[</span><span class="n">getLine</span><span class="p">,</span> <span class="n">getLine</span><span class="p">,</span> <span class="n">getLine</span><span class="p">]</span>
    <span class="n">print</span> <span class="n">rs</span>
</pre></div>
</div>
<p>Así que <tt class="docutils literal"><span class="pre">sequence</span> <span class="pre">[getLine,</span> <span class="pre">getLine,</span> <span class="pre">getLine]</span></tt> crea una acción <tt class="docutils literal"><span class="pre">IO</span></tt> que
ejecutará <tt class="docutils literal"><span class="pre">getLine</span></tt> tres veces. Si ligamos esa acción a un nombre, el
resultado será una lista que contendrá todos los resultados, en nuestro
caso, una lista con tres líneas que haya introducido el usuario.</p>
<p>Un uso común de <tt class="docutils literal"><span class="pre">sequence</span></tt> es cuando mapeamos funciones como <tt class="docutils literal"><span class="pre">print</span></tt> o
<tt class="docutils literal"><span class="pre">putStrLn</span></tt> sobre listas. Al hacer <tt class="docutils literal"><span class="pre">map</span> <span class="pre">print</span> <span class="pre">[1,2,3,4]</span></tt> no creamos
una acción <tt class="docutils literal"><span class="pre">IO</span></tt>. Creará una lista de acciones <tt class="docutils literal"><span class="pre">IO</span></tt>, ya que es lo mismo
que si escribiéramos <tt class="docutils literal"><span class="pre">[print</span> <span class="pre">1,</span> <span class="pre">print</span> <span class="pre">2,</span> <span class="pre">print</span> <span class="pre">3,</span> <span class="pre">print</span> <span class="pre">4]</span></tt>. Si queremos
transformar esa lista de acciones en una única acción IO, tenemos que
secuenciarla.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; sequence (map print [1,2,3,4,5])</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">5</span>
<span class="go">[(),(),(),(),()]</span>
</pre></div>
</div>
<p>¿Qué es eso de <tt class="docutils literal"><span class="pre">[(),(),(),(),()]</span></tt>? Bueno, cuando evaluamos una acción
<tt class="docutils literal"><span class="pre">IO</span></tt> en GHCi es ejecutada y su resultado se muestra por pantalla, a no
ser que el resultado sea <tt class="docutils literal"><span class="pre">()</span></tt>, en cuyo caso no se muestra. Por este
motivo al evaluar <tt class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">&quot;hehe&quot;</span></tt> GHCi solo imprime <tt class="docutils literal"><span class="pre">&quot;hehe&quot;</span></tt> (ya que
el resultado contenido en la acción <tt class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">&quot;hehe&quot;</span></tt> es <tt class="docutils literal"><span class="pre">()</span></tt>). Sin
embargo cuando utilizamos <tt class="docutils literal"><span class="pre">getLine</span></tt> en GHCi, el resultado de esa acción
si es impreso por pantalla, ya que <tt class="docutils literal"><span class="pre">getLine</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt>.</p>
</li>
<li><p class="first">Como mapear una función que devuelve una acción <tt class="docutils literal"><span class="pre">IO</span></tt> sobre una lista y
luego secuenciarla es algo muy común, se introducieron las funciones
auxiliares <tt class="xref cpp cpp-member docutils literal"><span class="pre">mapM</span></tt> y <tt class="xref cpp cpp-member docutils literal"><span class="pre">mapM_</span></tt>. <tt class="docutils literal"><span class="pre">mapM</span></tt> toma una función y una lista,
mapea la función sobre la lista y luego la secuencia. <tt class="docutils literal"><span class="pre">mapM_</span></tt> hace lo
mismo, solo que después se deshace del resultado. Normalmente utilizamos
<tt class="docutils literal"><span class="pre">mapM_</span></tt> cuando no nos importa el resultado de las acciones secuenciadas.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM print [1,2,3]</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">[(),(),()]</span>
<span class="go">ghci&gt; mapM_ print [1,2,3]</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">forever</span></tt> toma una acción <tt class="docutils literal"><span class="pre">IO</span></tt> y devuelve otra acción <tt class="docutils literal"><span class="pre">IO</span></tt> que
simplemente repetirá la primera acción indefinidamente. Está situada en
<tt class="docutils literal"><span class="pre">Control.Monad</span></tt>. Este pequeño programa preguntará al usuario por una
cadena y luego la devolverá en mayúsculas, indefinidamente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">putStr</span> <span class="s">&quot;Give me some input: &quot;</span>
    <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">l</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">forM</span></tt> (situado en <tt class="docutils literal"><span class="pre">Control.Monad</span></tt>) es como <tt class="docutils literal"><span class="pre">mapM</span></tt> solo que tiene
sus parámetros cambiados de sitio. El primer parámetro es la lista y el
segundo la función a mapear sobre la lista, la cual luego será secuenciada
¿Para qué es útil? Bueno, con un uso creativo de funciones lambda y la
notación <tt class="docutils literal"><span class="pre">do</span></tt> podemos hacer cosas como estas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">colors</span> <span class="ow">&lt;-</span> <span class="n">forM</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Which color do you associate with the number &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;?&quot;</span>
        <span class="n">color</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
        <span class="n">return</span> <span class="n">color</span><span class="p">)</span>
    <span class="n">putStrLn</span> <span class="s">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>
    <span class="n">mapM</span> <span class="n">putStrLn</span> <span class="n">colors</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">(\a</span> <span class="pre">-&gt;</span> <span class="pre">do</span> <span class="pre">...</span> <span class="pre">)</span></tt> es una función que toma un número y devuelve una acción
<tt class="docutils literal"><span class="pre">IO</span></tt>. Tenemos que rodearla con paréntesis, ya que de otro modo la función
lambda pensaría que las dos últimas líneas le pertenecen. Fíjate que usamos
<tt class="docutils literal"><span class="pre">return</span> <span class="pre">color</span></tt> dentro del bloque <tt class="docutils literal"><span class="pre">do</span></tt>. Lo hacemos así para que la
acción <tt class="docutils literal"><span class="pre">IO</span></tt> que define el bloque <tt class="docutils literal"><span class="pre">do</span></tt> tenga como resultado el color
que deseamos. Realmente no tenemos que hacerlos porque <tt class="docutils literal"><span class="pre">getLine</span></tt> ya
lo tienen contenido. Hacer <tt class="docutils literal"><span class="pre">color</span> <span class="pre">&lt;-</span> <span class="pre">getLine</span></tt> para luego hacer <tt class="docutils literal"><span class="pre">return</span>
<span class="pre">color</span></tt> es simplemente extraer  el resultado de <tt class="docutils literal"><span class="pre">getLine</span></tt> para luego
volver a insertarlo otra vez, así que es lo mismo que hacer solo
<tt class="docutils literal"><span class="pre">getLine</span></tt>.``forM`` (llamado con sus dos parámetros) produce una acción
<tt class="docutils literal"><span class="pre">IO</span></tt>, cuyo resultado ligaremos a <tt class="docutils literal"><span class="pre">colors</span></tt>. <tt class="docutils literal"><span class="pre">colors</span></tt> es una simple
lista que contiene cadenas. Al final, imprimimos todos esos colores
haciendo <tt class="docutils literal"><span class="pre">mapM</span> <span class="pre">putStrLn</span> <span class="pre">colors</span></tt>.</p>
<p>Puedes verlo en el sentido de que <tt class="docutils literal"><span class="pre">forM</span></tt> crea una acción <tt class="docutils literal"><span class="pre">IO</span></tt> para
cada elemento de una lista. Lo que haga cada acción dependerá del elemento
que haya sido utilizado para crear la acción. Al final, realiza todas
esas acciones y liga todos los resultados a algo. No tenemos porque
ligarlo, podemos simplemente desecharlo.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell form_test.hs
<span class="go">Which color do you associate with the number 1?</span>
<span class="go">white</span>
<span class="go">Which color do you associate with the number 2?</span>
<span class="go">blue</span>
<span class="go">Which color do you associate with the number 3?</span>
<span class="go">red</span>
<span class="go">Which color do you associate with the number 4?</span>
<span class="go">orange</span>
<span class="go">The colors that you associate with 1, 2, 3 and 4 are:</span>
<span class="go">white</span>
<span class="go">blue</span>
<span class="go">red</span>
<span class="go">orange</span>
</pre></div>
</div>
<p>En realidad podríamos haber hecho lo mismo sin <tt class="docutils literal"><span class="pre">forM</span></tt>, solo que con
<tt class="docutils literal"><span class="pre">forM</span></tt> es más legible. Normalmente usamos <tt class="docutils literal"><span class="pre">forM</span></tt> cuando queremos
mapear y secuenciar algunas acciones que hemos definido utilizando la
notación <tt class="docutils literal"><span class="pre">do</span></tt>. Del mismo modo, podríamos haber remplazado la última línea
por <tt class="docutils literal"><span class="pre">forM</span> <span class="pre">colors</span> <span class="pre">putStrLn</span></tt>.</p>
</li>
</ul>
</div></blockquote>
<p>En esta sección hemos aprendido las bases de la entrada y salida. También
hemos visto que son las acciones <tt class="docutils literal"><span class="pre">IO</span></tt>, como nos permiten realizar acciones
de entrada y salida y cuando son realmente ejecutadas. Las acciones <tt class="docutils literal"><span class="pre">IO</span></tt> son
valores al igual que cualquier otro valor en Haskell. Podemos pasarlas como
parámetros en las funciones y las funciones pueden devolver acciones como
resultados. Lo que tiene de especial es cuando son alcanzadas por <tt class="docutils literal"><span class="pre">main</span></tt>
(o son el resultado de una sentencia en GHCi), son ejecutadas. Y es en ese
momento cuando pueden escribir cosas en tu pantalla o reproducir
<a class="reference external" href="http://www.youtube.com/watch?v=ZnHmskwqCCQ">Yakety Sax</a>
por tus altavoces. Cada acción <tt class="docutils literal"><span class="pre">IO</span></tt> también puede contener un resultado que
nos dirá que ha podido obtener del mundo real.</p>
<p>No pienses en la función <tt class="docutils literal"><span class="pre">putStrLn</span></tt> como una función que toma una cadena y
la imprime por pantalla. Piensa que es una función que toma una cadena y
devuelve una ación <tt class="docutils literal"><span class="pre">IO</span></tt>. Esa acción <tt class="docutils literal"><span class="pre">IO</span></tt>, cuando sea ejecutada, imprimirá
por pantalla dicha cadena.</p>
</div>
<div class="section" id="ficheros-y-flujos-de-datos">
<h2>Ficheros y flujos de datos<a class="headerlink" href="#ficheros-y-flujos-de-datos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Corrientes" class="align-right" src="../_images/streams.png" />
<p><tt class="docutils literal"><span class="pre">getChar</span></tt> es una acción de E/S que lee un solo carácter desde la terminal.
<tt class="docutils literal"><span class="pre">getLine</span></tt> es una acción de E/S que lee una línea desde la terminal. Estas
funciones son bastante sencillas y la mayoría de lenguajes tienen funciones
o sentencias similares. Pero ahora vamos a ver <tt class="xref cpp cpp-member docutils literal"><span class="pre">getContents</span></tt>.
<tt class="docutils literal"><span class="pre">getContents</span></tt> es una acción de E/S que lee cualquier cosa de la entrada
estándar hasta que encuentre un carácter de fin de fichero. Su tipo es
<tt class="docutils literal"><span class="pre">getContents</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">String</span></tt>. Lo bueno de <tt class="docutils literal"><span class="pre">getContents</span></tt> es que realiza una
E/S perezosa. Cuando hacemos <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">&lt;-</span> <span class="pre">getContents</span></tt>, no lee todos los datos de
entrada de golpe, los almacena en memoria y luego los liga a <tt class="docutils literal"><span class="pre">foo</span></tt>. No ¡Es
perezoso! Dirá &#8220;Sí, sí, ya leeré la entrada de la terminal luego, cuando
de verdad lo necesites&#8221;.</p>
<p><tt class="docutils literal"><span class="pre">getContents</span></tt> es realmente útil cuando estamos redirigiendo la salida de un
programa a la entrada de otro programa. En caso de que no sepas como funciona
la redirección en sistemas <em>unix</em>, aquí tienes una pequeña introducción. Vamos
a crear un fichero de texto que contenga este pequeño
<a class="reference external" href="http://es.wikipedia.org/wiki/Haiku">haiku</a>:</p>
<div class="highlight-none"><div class="highlight"><pre>I&#39;m a lil&#39; teapot
What&#39;s with that airplane food, huh?
It&#39;s so small, tasteless
</pre></div>
</div>
<p>Sí, tienes razón, este haiku apesta. Si conoces alguna buena guía sobre haikus
házmelo saber.</p>
<p>Ahora recuerda aquel pequeño programa que escribimos cuando explicamos la
función <tt class="docutils literal"><span class="pre">forever</span></tt>. Le pedía al usuario una línea y la devolvía en
mayúsculas, luego volvía a hace lo mismo indefinidamente. Solo para que no
tengas que desplazarte hacia atrás, aquí tienes el código de nuevo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">forever</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">putStr</span> <span class="s">&quot;Give me some input: &quot;</span>
    <span class="n">l</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">l</span>
</pre></div>
</div>
<p>Vamos a guardar este programa como <tt class="docutils literal"><span class="pre">capslocker.hs</span></tt> o algo parecido y lo
compilamos. Y ahora, vamos a utilizar redirecciones <em>unix</em> para suministrar
nuestro fichero de texto directamente a nuestro pequeño programa. Nos vamos
a ayudar del uso del programa GNU <tt class="docutils literal"><span class="pre">cat</span></tt>, el cual muestra por la terminal el
contenido del fichero que le pasemos como parámetro ¡Mira!</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ghc --make capslocker
<span class="go">[1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )</span>
<span class="go">Linking capslocker ...</span>
<span class="gp">$</span> cat haiku.txt
<span class="go">I&#39;m a lil&#39; teapot</span>
<span class="go">What&#39;s with that airplane food, huh?</span>
<span class="go">It&#39;s so small, tasteless</span>
<span class="gp">$</span> cat haiku.txt | ./capslocker
<span class="go">I&#39;M A LIL&#39; TEAPOT</span>
<span class="go">WHAT&#39;S WITH THAT AIRPLANE FOOD, HUH?</span>
<span class="go">IT&#39;S SO SMALL, TASTELESS</span>
<span class="go">capslocker &lt;stdin&gt;: hGetLine: end of file</span>
</pre></div>
</div>
<p>Como puedes ver, para redireccionar la salida de un programa (en nuestro caso
<tt class="docutils literal"><span class="pre">cat</span></tt>) a la entrada de otro (<tt class="docutils literal"><span class="pre">capslocker</span></tt>) se consigue con el carácter
<tt class="docutils literal"><span class="pre">|</span></tt>. Lo que acabamos de hacer sería equivalente a ejecutar <tt class="docutils literal"><span class="pre">capslocker</span></tt>,
escribir nuestro haiku en la terminal y luego introducir el carácter de fin
de fichero (normalmente esto se consigue pulsando <em>Ctrl+D</em>). Es como ejecutar
<tt class="docutils literal"><span class="pre">cat</span> <span class="pre">haiku.txt</span></tt> y decir: &#8220;Alto espera, no muestres esto por pantalla,
pásaselo a <tt class="docutils literal"><span class="pre">capslocker</span></tt>&#8221;.</p>
<p>Así que lo que estamos haciendo al utilizar <tt class="docutils literal"><span class="pre">forever</span></tt> es básicamente tomar
la entrada y transformarla en algún tipo de salida. Por este motivo podemos
utilizar <tt class="docutils literal"><span class="pre">getContents</span></tt> para hacer nuestro programa mejor e incluso más
corto.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
    <span class="n">putStr</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span> <span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<p>Ejecutamos la acción de E/S <tt class="docutils literal"><span class="pre">getContents</span></tt> y nombramos la cadena que produce
como <tt class="docutils literal"><span class="pre">contents</span></tt>. Luego, trazamos <tt class="docutils literal"><span class="pre">toUpper</span></tt> sobre la cadena y mostramos
el resultado por la terminal. Ten en cuenta que las cadenas son básicamente
listas, las cuales son perezosas, y <tt class="docutils literal"><span class="pre">getContents</span></tt> es una acción de E/S
perezosa. Por lo tanto no intentará leer todo el contenido de golpe para
guardarlo en memoria antes de mostrarlo en mayúsculas por la terminal. En
realidad mostrará la versión en mayúsculas conforme vaya leyendo, ya que solo
lee una línea de la entrada cuando realmente lo necesita.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> cat haiku.txt | ./capslocker
<span class="go">I&#39;M A LIL&#39; TEAPOT</span>
<span class="go">WHAT&#39;S WITH THAT AIRPLANE FOOD, HUH?</span>
<span class="go">IT&#39;S SO SMALL, TASTELESS</span>
</pre></div>
</div>
<p>Genial, funciona ¿Qué pasaría si ejecutamos <tt class="docutils literal"><span class="pre">capslocker</span></tt> e intentamos
escribir líneas de texto nosotros mismos?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ./capslocker
<span class="go">hey ho</span>
<span class="go">HEY HO</span>
<span class="go">lets go</span>
<span class="go">LETS GO</span>
</pre></div>
</div>
<p>Salimos pulsando <em>Ctrl+D</em>. Como ves, muestra nuestra entrada en mayúsculas
línea por línea. Cuando el resultado de <tt class="docutils literal"><span class="pre">getContents</span></tt> se liga a
<tt class="docutils literal"><span class="pre">contents</span></tt>, no se representa en memoria como una cadena real, si no más bien
como una promesa de que al final producirá una cadena. Cuando trazamos
<tt class="docutils literal"><span class="pre">toUpper</span></tt> sobre <tt class="docutils literal"><span class="pre">contents</span></tt>, también es una promesa de que se trazará esa
función sobre el contenido final. Por último, cuando se ejecuta <tt class="docutils literal"><span class="pre">putStr</span></tt> le
dice a la promesa anterior: &#8220;Hey ¡Necesito una línea en mayúsculas!&#8221;. Entonces
es cuando en realidad <tt class="docutils literal"><span class="pre">getContents</span></tt> lee la entrada y le pasa una línea al
código que le ha pedido que produzca algo tangible. Ese código traza
<tt class="docutils literal"><span class="pre">toUpper</span></tt> sobre esa línea y le pasa el resultado a <tt class="docutils literal"><span class="pre">putStr</span></tt>, y ésta se
encarga de mostrarla. Luego <tt class="docutils literal"><span class="pre">putStr</span></tt> dice: &#8220;Hey, necesito la siguiente
línea ¡Vamos!&#8221; y se repite hasta que no hay mas datos en la entrada, lo cual
se representa con el carácter de fin de fichero.</p>
<p>Vamos a crear un programa que tome algunas líneas y luego solo muestre
aquellas que tengan una longitud menor de 10 caracteres. Observa:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
    <span class="n">putStr</span> <span class="p">(</span><span class="n">shortLinesOnly</span> <span class="n">contents</span><span class="p">)</span>

<span class="nf">shortLinesOnly</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">shortLinesOnly</span> <span class="n">input</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">allLines</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">input</span>
        <span class="n">shortLines</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">line</span> <span class="ow">-&gt;</span> <span class="n">length</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="n">allLines</span>
        <span class="n">result</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="n">shortLines</span>
    <span class="kr">in</span>  <span class="n">result</span>
</pre></div>
</div>
<p>Hemos hecho la parte de nuestro programa dedicada a E/S tan pequeña como a
sido posible. Ya que nuestro programa se supone que toma una entrada y muestra
una salida basándose en la entrada, podemos implementarlo leyendo los
contenidos de la entrada, ejecutando una función sobre ellos y luego mostramos
lo que nos devuelve esa función.</p>
<p>La función <tt class="docutils literal"><span class="pre">shortLinesOnly</span></tt> funciona así: toma una cadena, como
<tt class="docutils literal"><span class="pre">&quot;short\nlooooooooooooooong\nshort</span> <span class="pre">again&quot;</span></tt>. Esta cadena tiene tres líneas,
dos de ellas son cortas y la del medio es larga. Ejecuta la función <tt class="docutils literal"><span class="pre">lines</span></tt>
sobre esa cadena, de forma que obtenemos <tt class="docutils literal"><span class="pre">[&quot;short&quot;,</span> <span class="pre">&quot;looooooooooooooong&quot;,`</span>
<span class="pre">`&quot;short</span> <span class="pre">again&quot;]</span></tt> que luego ligamos a <tt class="docutils literal"><span class="pre">allLines</span></tt>. Luego esta lista de
cadenas es filtrada de forma que solo las líneas que sean menores de 10
caracteres de longitud permanecen en la lista, produciendo <tt class="docutils literal"><span class="pre">[&quot;short&quot;,</span>
<span class="pre">&quot;short</span> <span class="pre">again&quot;]</span></tt>. Finalmente <tt class="docutils literal"><span class="pre">unlines</span></tt> concatena la lista en una única
cadena, devolviendo <tt class="docutils literal"><span class="pre">&quot;short\nshort</span> <span class="pre">again&quot;</span></tt>. Vamos a probarlo.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">i&#39;m short</span>
<span class="go">so am i</span>
<span class="go">i am a loooooooooong line!!!</span>
<span class="go">yeah i&#39;m long so what hahahaha!!!!!!</span>
<span class="go">short line</span>
<span class="go">loooooooooooooooooooooooooooong</span>
<span class="go">short</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ghc --make shortlinesonly
<span class="go">[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )</span>
<span class="go">Linking shortlinesonly ...</span>
<span class="gp">$</span> cat shortlines.txt | ./shortlinesonly
<span class="go">i&#39;m short</span>
<span class="go">so am i</span>
<span class="go">short</span>
</pre></div>
</div>
<p>Redireccionamos los contenidos de <tt class="docutils literal"><span class="pre">shortlines.txt</span></tt> a la entrada de
<tt class="docutils literal"><span class="pre">shortlinesonly</span></tt>, de forma que obtenemos únicamente las líneas cortas.</p>
<p>Este patrón de tomar una cadena como entrada, transformarla con una función y
mostrar el resultado de esa transformación es tan común que existe una función
que hace esto más fácil, la función <tt class="xref cpp cpp-member docutils literal"><span class="pre">interact</span></tt>. <tt class="docutils literal"><span class="pre">interact</span></tt> toma una
función del tipo <tt class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">String</span></tt> como parámetro y devuelve una acción de
E/S que tomara la entrada del programa, ejecutará la función sobre ella y
mostrará por pantalla el resultado de esta función. Vamos a modificar nuestro
programa para que utilice esta función.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">interact</span> <span class="n">shortLinesOnly</span>

<span class="nf">shortLinesOnly</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">shortLinesOnly</span> <span class="n">input</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">allLines</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">input</span>
        <span class="n">shortLines</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">line</span> <span class="ow">-&gt;</span> <span class="n">length</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="n">allLines</span>
        <span class="n">result</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="n">shortLines</span>
    <span class="kr">in</span>  <span class="n">result</span>
</pre></div>
</div>
<p>Con el propósito de mostrar que podemos conseguir lo mismo con mucho menos
código (incluso aunque sea un poco menos legible) y demostrar nuestras
habilidades de composición de funciones, vamos a modificarlo un poco más.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">interact</span> <span class="o">$</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">((</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span> <span class="o">.</span> <span class="n">length</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
</pre></div>
</div>
<p>Wau ¡Lo hemos reducido a una única línea de código!</p>
<p><tt class="docutils literal"><span class="pre">interact</span></tt> se puede utilizar para crear programas a los que se les
redireccionará algún contenido y luego mostrará un resultado, o para crear
programas que parezcan que leen una línea escrita por el usuario desde la
entrada, muestren un resultado basándose en esa línea y luego continúen con
otra línea. En realidad no hay ninguna diferencia entre ellos, simplemente
depende de como lo use el usuario.</p>
<p>Vamos a crear un programa que lea continuamente una línea y nos diga si esa
línea es un palíndromo o no. Podríamos simplemente utilizar <tt class="docutils literal"><span class="pre">getLine</span></tt> para
leer una línea, mostrar al usuario si es palíndroma o no, y volver a ejecutar
<tt class="docutils literal"><span class="pre">main</span></tt>. Pero es más simple si utilizamos <tt class="docutils literal"><span class="pre">interact</span></tt>. Cuando utilices
<tt class="docutils literal"><span class="pre">interact</span></tt>, piensa en que tienes que hacer para transformar la entrada del
programa en la salida que deseas. En nuestro caso, tenemos que remplazar cada
línea de la entrada en <tt class="docutils literal"><span class="pre">&quot;palindrome&quot;</span></tt> o <tt class="docutils literal"><span class="pre">&quot;not</span> <span class="pre">a</span> <span class="pre">palindrome&quot;</span></tt>. Así que
tenemos que transformar algo como <tt class="docutils literal"><span class="pre">&quot;elephant\nABCBA\nwhatever&quot;</span></tt> en
<tt class="docutils literal"><span class="pre">&quot;not</span> <span class="pre">a</span> <span class="pre">palindrome\npalindrome\nnot</span> <span class="pre">a</span> <span class="pre">palindrome&quot;</span></tt> ¡Vamos a intentarlo!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">respondPalindromes</span> <span class="n">contents</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="p">(</span><span class="n">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span>
    <span class="kr">where</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">==</span> <span class="n">reverse</span> <span class="n">xs</span>
          <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="kr">then</span> <span class="s">&quot;palindrome&quot;</span> <span class="kr">else</span> <span class="s">&quot;not a palindrome&quot;</span>
</pre></div>
</div>
<p>Vamos a escribirlo en estilo libre de puntos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">respondPalindromes</span> <span class="ow">=</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">.</span> <span class="n">lines</span>
    <span class="kr">where</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">xs</span> <span class="o">==</span> <span class="n">reverse</span> <span class="n">xs</span>
          <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="kr">then</span> <span class="s">&quot;palindrome&quot;</span> <span class="kr">else</span> <span class="s">&quot;not a palindrome&quot;</span>
</pre></div>
</div>
<p>Sencillo. Primero convierte algo como <tt class="docutils literal"><span class="pre">&quot;elephant\nABCBA\nwhatever&quot;</span></tt> en
<tt class="docutils literal"><span class="pre">[&quot;elephant&quot;,</span> <span class="pre">&quot;ABCBA&quot;,</span> <span class="pre">&quot;whatever&quot;]</span></tt> y luego traza <tt class="docutils literal"><span class="pre">f</span></tt> sobre la lista,
devolviendo <tt class="docutils literal"><span class="pre">[&quot;not</span> <span class="pre">a</span> <span class="pre">palindrome&quot;,</span> <span class="pre">&quot;palindrome&quot;,</span> <span class="pre">&quot;not</span> <span class="pre">a</span> <span class="pre">palindrome&quot;]</span></tt>. Por
último utiliza <tt class="docutils literal"><span class="pre">unlines</span></tt> para concatenar la lista de cadenas en una sola
cadena. Ahora podemos hacer:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">interact</span> <span class="n">respondPalindromes</span>
</pre></div>
</div>
<p>Vamos a comprobarlo.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell palindromes.hs
<span class="go">hehe</span>
<span class="go">not a palindrome</span>
<span class="go">ABCBA</span>
<span class="go">palindrome</span>
<span class="go">cookie</span>
<span class="go">not a palindrome</span>
</pre></div>
</div>
<p>Incluso aunque hemos creado un programa que transforma una gran cadena de
entrada en otra, actúa como si hubiéramos hecho un programa que lee línea a
línea. Esto se debe a que Haskell es perezoso y quiere mostrar la primera
línea del resultado, pero no lo puede hacer porque aún no tiene la primera
línea de la entrada. Así que tan pronto tenga la primera línea de la entrada,
mostrará la primera línea de la salida. Salimos del programa utilizando el
carácter de fin de fichero.</p>
<p>También podemos utilizar el programa redireccionando el contenido de un
fichero. Digamos que tenemos este fichero:</p>
<div class="highlight-none"><div class="highlight"><pre>dogaroo
radar
rotor
madam
</pre></div>
</div>
<p>Y lo hemos guardado como <tt class="docutils literal"><span class="pre">words.txt</span></tt>. Así sería como redireccionaríamos el
fichero a la entrada de nuestro programa.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> cat words.txt | runhaskell palindromes.hs
<span class="go">not a palindrome</span>
<span class="go">palindrome</span>
<span class="go">palindrome</span>
<span class="go">palindrome</span>
</pre></div>
</div>
<p>De nuevo, obtenemos la misma salida que si hubiésemos ejecutado nuestro
programa y hubiésemos tecleado nosotros mismos las palabras. Simplemente no
vemos la entrada de <tt class="docutils literal"><span class="pre">palindromes.hs</span></tt> porque ha sido redireccionada desde
un fichero.</p>
<p>Probablemente ya sepas como funciona E/S perezosa y como se puede aprovechar.
Puedes pensar en términos que como se supone que debe ser la salida y escribir
una función que haga la transformación. En la E/S perezosa, no se consume nada
de la entrada hasta que realmente tenga que hacerse, es decir, cuando queramos
mostrar por pantalla algo que depende de la entrada.</p>
<p>Hasta ahora, hemos trabajado con la E/S mostrando y leyendo cosas de la
terminal ¿Pero qué hay de escribir y leer ficheros? Bueno, de cierto modo, ya
lo hemos hecho. Se puede pensar que leer algo desde la terminal es como leer
algo desde un fichero especial. Lo mismo ocurre a la hora de escribir en la
terminal, es parecido a escribir en un fichero. Podemos llamar a estos dos
ficheros <tt class="docutils literal"><span class="pre">stdout</span></tt> y <tt class="docutils literal"><span class="pre">stdin</span></tt>, que representan la salida estándar y la
entrada estándar respectivamente. Teniendo esto en cuenta, veremos que
escribir y leer ficheros es muy parecido a escribir en la salida estándar y
leer desde la entrada estándar.</p>
<p>Empezaremos con un programa realmente simple que abre un fichero llamado
<tt class="docutils literal"><span class="pre">girlfriend.txt</span></tt>, que contiene un verso del éxito Nº 1 de <em>Avril Lavigne</em>,
<em>Girlfriend</em>, y lo muestra por la terminal. Aquí tienes <tt class="docutils literal"><span class="pre">girlfriend.txt</span></tt>:</p>
<div class="highlight-none"><div class="highlight"><pre>Hey! Hey! You! You!
I don&#39;t like your girlfriend!
No way! No way!
I think you need a new one!
</pre></div>
</div>
<p>Y aquí tienes nuestro programa:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handle</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;girlfriend.txt&quot;</span> <span class="kt">ReadMode</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="n">putStr</span> <span class="n">contents</span>
    <span class="n">hClose</span> <span class="n">handle</span>
</pre></div>
</div>
<p>Ejecutándolo, obtenemos el resultado esperado:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell girlfriend.hs
<span class="go">Hey! Hey! You! You!</span>
<span class="go">I don&#39;t like your girlfriend!</span>
<span class="go">No way! No way!</span>
<span class="go">I think you need a new one!</span>
</pre></div>
</div>
<p>Vamos a analizarlo línea a línea. La primera línea son solo cuatro
exclamaciones que intentan llamar nuestra atención. En la segunda línea, Avril
nos dice que no le gusta nuestra actual pareja. La tercera línea tiene como
objetivo enfatizar su desacuerdo, mientras que la cuarta nos sugiere que
busquemos una nueva novia.</p>
<p>¡Genial! Ahora vamos a analizar nuestro programa línea a línea. El programa
tiene varias acciones de E/S unidas en un bloque <tt class="docutils literal"><span class="pre">do</span></tt>. En la primera línea
del bloque <tt class="docutils literal"><span class="pre">do</span></tt> vemos que hay una función nueva llamada <tt class="xref cpp cpp-member docutils literal"><span class="pre">openFile</span></tt>. Su
tipo es el siguiente: <tt class="docutils literal"><span class="pre">openFile</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">IOMode</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">Handle</span></tt>. Si lo
lees en voz alta dice: <tt class="docutils literal"><span class="pre">openFile</span></tt> toma la ruta de un fichero y un <tt class="docutils literal"><span class="pre">IOMode</span></tt>
y devuelve una acción de E/S que abrirá el fichero indicado y contendrá un
manipulador como resultado.</p>
<p><tt class="docutils literal"><span class="pre">FilePath</span></tt> es simplemente un <a class="reference internal" href="ClasesDeTipos.html#sinonimos"><em>sinónimo de tipo</em></a> de
<tt class="docutils literal"><span class="pre">String</span></tt>, se define como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">FilePath</span> <span class="ow">=</span> <span class="kt">String</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">IOMode</span></tt> es un tipo que se define como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">IOMode</span> <span class="ow">=</span> <span class="kt">ReadMode</span> <span class="o">|</span> <span class="kt">WriteMode</span> <span class="o">|</span> <span class="kt">AppendMode</span> <span class="o">|</span> <span class="kt">ReadWriteMode</span>
</pre></div>
</div>
<img alt="Preso" class="align-left" src="../_images/file.png" />
<p>De la misma forma que aquel tipo que creamos que representaba los siete días
de la semana, este tipo es una enumeración que representa lo que queremos
hacer con un fichero abierto. Muy simple. Fíjate que el tipo es <tt class="docutils literal"><span class="pre">IOMode</span></tt> y
no <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">Mode</span></tt>. <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">Mode</span></tt> sería una acción de E/S que contendría un valor
del tipo <tt class="docutils literal"><span class="pre">Mode</span></tt> como resultado, pero <tt class="docutils literal"><span class="pre">IOMode</span></tt> es simplemente una
enumeración.</p>
<p>Al final esta función devuelve una acción de E/S que abrirá el fichero
indicado del modo indicado. Si ligamos la acción a algo al final obtenemos
un <tt class="docutils literal"><span class="pre">Handle</span></tt>. Un valor del tipo <tt class="docutils literal"><span class="pre">Handle</span></tt> representa donde está nuestro
fichero. Lo usaremos para manipular el fichero de forma que sepamos de donde
leer y escribir datos. Sería un poco estúpido abrir un fichero y no ligar el
manipulador ya que no podríamos hacer nada con ese fichero. En nuestro caso
ligamos el manipulador a <tt class="docutils literal"><span class="pre">handle</span></tt>.</p>
<p>En la siguiente línea vemos una función llamada <tt class="xref cpp cpp-member docutils literal"><span class="pre">hGetContents</span></tt>. Toma un
<tt class="docutils literal"><span class="pre">Handle</span></tt>, de forma que sabe de donde tiene que leer el contenido, y devuelve
una <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt>, una acción de E/S que contiene como resultado el contenido
del fichero. Esta función se parece mucho a <tt class="docutils literal"><span class="pre">getContents</span></tt>. La única
diferencia es que <tt class="docutils literal"><span class="pre">getContents</span></tt> lee automáticamente desde la entrada
estándar (es decir desde la terminal), mientras que <tt class="docutils literal"><span class="pre">hGetContents</span></tt> toma el
manipulador de un fichero que le dice donde debe leer. Por lo demás, funcionan
exactamente igual. Al igual que <tt class="docutils literal"><span class="pre">getContents</span></tt>, <tt class="docutils literal"><span class="pre">hGetContents</span></tt> no leerá
todo el contenido de un fichero de golpe si con forme lo vaya necesitando.
Esto es muy interesante ya que podemos tratar a <tt class="docutils literal"><span class="pre">contents</span></tt> como si fuera
todo el contenido del fichero, solo que en realidad no estará cargado en
la memoria. En caso de que leyéramos un fichero enorme, ejecutar
<tt class="docutils literal"><span class="pre">hGetContents</span></tt> no saturaría la memoria ya que solo se leerá lo que se vaya
necesitando.</p>
<p>Fíjate en la diferencia entre el manipulador utilizado para representar el
fichero y los contenidos del fichero, ligados en nuestro programa a <tt class="docutils literal"><span class="pre">handle</span></tt>
y <tt class="docutils literal"><span class="pre">contents</span></tt>. El manipulador es algo que representa el fichero con el que
estamos trabajando. Si te imaginas el sistema de ficheros como si fuera un
gran libro y cada fichero fuera un capítulo del libro, el manipulador sería
como un marcador que nos indica por donde estamos leyendo (o escribiendo) en
un capítulo, mientras que el contenido sería el capítulo en si.</p>
<p>Con <tt class="docutils literal"><span class="pre">putStr</span> <span class="pre">contents</span></tt> simplemente mostramos el contenido del fichero por
la salida estándar. Luego ejecutamos <tt class="xref cpp cpp-member docutils literal"><span class="pre">hClose</span></tt>, el cual toma un
manipulador y devuelve una acción de E/S que cierra el fichero ¡Tienes que
cerrar tu mismo cada fichero que abras con <tt class="docutils literal"><span class="pre">openFile</span></tt>!</p>
<p>Otra forma de hacer lo que mismo que acabamos de hacer es utilizando la
función <tt class="xref cpp cpp-member docutils literal"><span class="pre">withFile</span></tt>, cuya declaración de tipo es <tt class="docutils literal"><span class="pre">withFile</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span>
<span class="pre">IOMode</span> <span class="pre">-&gt;</span> <span class="pre">(Handle</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></tt>. Toma la ruta de un fichero, un
<tt class="docutils literal"><span class="pre">IOMode</span></tt> y luego toma una función que a su vez toma un manipulador y
devuelve una acción de E/S. <tt class="docutils literal"><span class="pre">withFile</span></tt> devuelve una acción de E/S que
abrirá el fichero indicado, hará algo con él y luego cerrará el fichero. El
resultado contenido en la acción de E/S final es el mismo que el resultado
contenido en la acción de E/S de la función que se le pasa como parámetro.
Quizá te suente un poco complicado, pero es realmente simple, especialmente
con la ayuda de las lambdas. Aquí tienes nuestro programa anterior reescrito
utilizando <tt class="docutils literal"><span class="pre">withFile</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">withFile</span> <span class="s">&quot;girlfriend.txt&quot;</span> <span class="kt">ReadMode</span> <span class="p">(</span><span class="nf">\</span><span class="n">handle</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<p>Como puedes ver ambos son muy parecidos. <tt class="docutils literal"><span class="pre">(\handle</span> <span class="pre">-&gt;</span> <span class="pre">...</span> <span class="pre">)</span></tt> es la función
que toma un manipulador y devuleve una acción de E/S y de forma habitual esta
función se implementea utilizando lambdas. La razón por la que debe tomar
una función que devuelva una acción de E/S en lugar de tomar directamente una
acción de E/S para hacer algo y luego cerrar el fichero, es para que la
función que le pasemos sepa sobre que fichero operar. De este modo,
<tt class="docutils literal"><span class="pre">withFile</span></tt> abre un fichero y le pasa el manipulador a la función que le
demos. Obtiene una acción de E/S como resultado y luego crear una acción de
E/S que se comporte de la misma forma, solo que primero cierra el fichero.
Así sería como implementaríamos la función <tt class="docutils literal"><span class="pre">withFile</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">withFile&#39;</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IOMode</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Handle</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="nf">withFile&#39;</span> <span class="n">path</span> <span class="n">mode</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handle</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="n">path</span> <span class="n">mode</span>
    <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">f</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<img alt="Edd" class="align-right" src="../_images/edd.png" />
<p>Sabemos que el resultado debe ser una acción de E/S así que podemos empezar
directamente con un <tt class="docutils literal"><span class="pre">do</span></tt>. Primero abrimos el fichero y obtenemos el
manipulador. Luego aplicamos <tt class="docutils literal"><span class="pre">handle</span></tt> a nuestra función y obtenemos una
acción de E/S que realizará todo el trabajo. Ligamos esa acción a <tt class="docutils literal"><span class="pre">result</span></tt>,
cerramos el fichero y hacemos <tt class="docutils literal"><span class="pre">return</span> <span class="pre">result</span></tt>. Al realizar el <tt class="docutils literal"><span class="pre">return</span></tt>
sobre el resultado que contenia la acción de E/S que obtuvimos de <tt class="docutils literal"><span class="pre">f</span></tt>,
hacemos que nuestra acción de E/S contenga el mismo resultado que obtuvimos
de <tt class="docutils literal"><span class="pre">f</span> <span class="pre">handle</span></tt>. Así que si <tt class="docutils literal"><span class="pre">f</span> <span class="pre">handle</span></tt> devuleve una acción que lea un
número de líneas de la entrada estándar y luego las escriba en el fichero,
de forma que contenga como resultado el número de líneas que ha leído, la
acción resultante de <tt class="docutils literal"><span class="pre">withFile'</span></tt> también tendrá como resultado el número de
líneas leidas.</p>
<p>De la misma forma que <tt class="docutils literal"><span class="pre">hGetContents</span></tt> funciona igual que <tt class="docutils literal"><span class="pre">getContents</span></tt> pero
sobre el fichero indicado, existen también <tt class="xref cpp cpp-member docutils literal"><span class="pre">hGetLine</span></tt>, <tt class="xref cpp cpp-member docutils literal"><span class="pre">hPutStr</span></tt>,
<tt class="xref cpp cpp-member docutils literal"><span class="pre">hPutStrLn</span></tt>, <tt class="xref cpp cpp-member docutils literal"><span class="pre">hGetChar</span></tt>, etc. Funcionan exactamente igual que sus
homónimas, solo que toman un manipulador como parámetro y operar sobre el
fichero indicado en lugar de sobre la entrada o salida estándar. Por ejemplo,
<tt class="docutils literal"><span class="pre">putStrLn</span></tt> es una función que toma una cadena y devuelve una acción de E/S
que mostrará esa cadena por la terminal seguida de un salto de línea.
<tt class="docutils literal"><span class="pre">hPutStrLn</span></tt> toma un manipulador y una cadena y devuelve una acción de E/S
que escribirá esa cadena en el fichero indicado, seguido de un salto de línea.
Del mismo modo, <tt class="docutils literal"><span class="pre">hGetLine</span></tt> toma un manipulador y devuelve una acción de E/S
que lee una línea de su fichero.</p>
<p>Cargar ficheros y luego tratar sus conteidos como cadenas es algo tan común
que tenemos estas tres pequeñas funciones que hacen nuestra vida más fácil:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">readFile</span></tt> tiene la declaración de tipo <tt class="docutils literal"><span class="pre">readFile</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">IO</span>
<span class="pre">String</span></tt>. Recueda, <tt class="docutils literal"><span class="pre">FilePath</span></tt> es solo un sinónimo de <tt class="docutils literal"><span class="pre">String</span></tt>.
<tt class="docutils literal"><span class="pre">readFile</span></tt> toma la ruta de un fichero y devuelve un acción de E/S que
leerá ese fichero (de forma perezosa) y ligará sus contenidos a una cadena.
Normalmente es más cómodo que hacer <tt class="docutils literal"><span class="pre">openFile</span></tt> y ligar su manipulador
para luego utilizar <tt class="docutils literal"><span class="pre">hGetContents</span></tt>. Aquí tienes como sería nuestro
ejemplo anterior utilizando <tt class="docutils literal"><span class="pre">readFile</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;girlfriend.txt&quot;</span>
    <span class="n">putStr</span> <span class="n">contents</span>
</pre></div>
</div>
<p>Como no obtenemos un manipulador con el cual identificar nuestro fichero,
no podemos cerrarlo manualmente, así que Haskell se encarga de cerrarlo por
nosotros cuando utilizamos <tt class="docutils literal"><span class="pre">readFile</span></tt>.</p>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">writeFile</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></tt>. Toma la
ruta de un fichero y una cadena que escribir en ese fichero y devuelve una
acción de E/S que se encargará de escribirla. En caso de que el fichero
indicado ya exista, sobreescribirá el fichero desde el incio. Aquí tienes
como convertir <tt class="docutils literal"><span class="pre">girlfriend.txt</span></tt> en una versión en mayúsculas y guardarlo
en <tt class="docutils literal"><span class="pre">girlfriendcaps.txt</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;girlfriend.txt&quot;</span>
    <span class="n">writeFile</span> <span class="s">&quot;girlfriendcaps.txt&quot;</span> <span class="p">(</span><span class="n">map</span> <span class="n">toUpper</span> <span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell girlfriendtocaps.hs
<span class="gp">$</span> cat girlfriendcaps.txt
<span class="go">HEY! HEY! YOU! YOU!</span>
<span class="go">I DON&#39;T LIKE YOUR GIRLFRIEND!</span>
<span class="go">NO WAY! NO WAY!</span>
<span class="go">I THINK YOU NEED A NEW ONE!</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="xref cpp cpp-member docutils literal"><span class="pre">appendFile</span></tt> tiene el mismo tipo que <tt class="docutils literal"><span class="pre">writeFile</span></tt>, solo que
<tt class="docutils literal"><span class="pre">appendFile</span></tt> no sobreescribe el fichero desde el principio en caso de que
el fichero indicado ya exista, sino que añade contiendo al final del
fichero.</p>
<p>Digamos que tenemos un fichero <tt class="docutils literal"><span class="pre">todo.txt</span></tt> que contiene una tarea que
debemos realizar en cada línea. Ahora vamos a crear un programa que tome
una línea por la entrada estándar y la añada a nuestra lista de tareas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">todoItem</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">appendFile</span> <span class="s">&quot;todo.txt&quot;</span> <span class="p">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell appendtodo.hs
<span class="go">Iron the dishes</span>
<span class="gp">$</span> runhaskell appendtodo.hs
<span class="go">Dust the dog</span>
<span class="gp">$</span> runhaskell appendtodo.hs
<span class="go">Take salad out of the oven</span>
<span class="gp">$</span> cat todo.txt
<span class="go">Iron the dishes</span>
<span class="go">Dust the dog</span>
<span class="go">Take salad out of the oven</span>
</pre></div>
</div>
<p>Tenemos que añadir <tt class="docutils literal"><span class="pre">&quot;\n&quot;</span></tt> al final de cada línea ya que <tt class="docutils literal"><span class="pre">getLine</span></tt> no
nos devuelve el carácter de fin de línea al final.</p>
</li>
</ul>
</div></blockquote>
<p>Oh, una cosa más. Hemos hablado de como al hacer <tt class="docutils literal"><span class="pre">contents</span> <span class="pre">&lt;-</span> <span class="pre">hGetContents</span>
<span class="pre">handle</span></tt> no se provoca que el fichero enetero sea leído de golpe y guardado en
memoria. Es una acción de E/S perezosa, así que al hacer esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">withFile</span> <span class="s">&quot;something.txt&quot;</span> <span class="kt">ReadMode</span> <span class="p">(</span><span class="nf">\</span><span class="n">handle</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<p>En realidad es como redireccionar el fichero a la salida. De la misma forma
que puedes tratar las cadenas como flujos de datos también puedes tratar
los ficheros como flujos de datos. Esto leerá una línea cada vez y la mostrará
por pantalla. Probablemente te estes preguntado ¿Con qué frecuencia se accede
al disco? ¿Qué tamaño tiene cada transferencia? Bueno, para ficheros de texto,
el tamaño por defecto para el búfer es una línea. Esto siginfica que la parte
más pequeña que se puede leer de fichero de una sola vez es una línea. Por
este motivo el ejemplo anterior en realidad leía una línea, la mostraba, leía
otra línea, la mostraba, etc. Para ficheros binarios, el tamaño del búfer
suele ser de un bloque. Esto significa que los ficheros binarios se leen de
bloques en bloques. El tamaño de un bloque es el que le apetezca a tu sistema
operativo.</p>
<p>Puedes controlar como se comporta exactamente el búfer utilizando la función
<tt class="docutils literal"><span class="pre">hSetBuffering</span></tt>. Ésta toma un manipulador y un <tt class="docutils literal"><span class="pre">BufferMode</span></tt> y devuelve una
acción de E/S que estable las propiedades del búfer para ese fichero.
<tt class="docutils literal"><span class="pre">BufferMode</span></tt> es una simple tipo de enumeración y sus posibles valores son:
<tt class="docutils literal"><span class="pre">NoBuffering</span></tt>, <tt class="docutils literal"><span class="pre">LineBuffering</span></tt> or <tt class="docutils literal"><span class="pre">BlockBuffering</span> <span class="pre">(Maybe</span> <span class="pre">Int)</span></tt>. El
<tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">Int</span></tt> indica el tamaño del bloque, en bytes. Si es <tt class="docutils literal"><span class="pre">Nothing</span></tt>, el
sistema operativo determinará el tamaño apropiado. <tt class="docutils literal"><span class="pre">NoBuffering</span></tt> significa
que se escribirá o se leera un carácter cada vez. Normalmente <tt class="docutils literal"><span class="pre">NoBuffering</span></tt>
no es muy eficiente ya que tiene que acceder al disco muchas veces.</p>
<p>Aquí tienes nuestro ejemplo anterior, solo que esta vez leerá bloques de
2048 bytes en lugar de línea por línea.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">withFile</span> <span class="s">&quot;something.txt&quot;</span> <span class="kt">ReadMode</span> <span class="p">(</span><span class="nf">\</span><span class="n">handle</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">hSetBuffering</span> <span class="n">handle</span> <span class="o">$</span> <span class="kt">BlockBuffering</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">2048</span><span class="p">)</span>
        <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="p">)</span>
</pre></div>
</div>
<p>Leer ficheros con bloques grandes nos puede ayudar si queremos minimizar el
acceso a disco o cuando nuestro fichero en realidad es un rescurso de una red
muy lenta.</p>
<p>También podemos utilizr <tt class="xref cpp cpp-member docutils literal"><span class="pre">hFlush</span></tt>, que es una función que toma un
manipulador y devuelve una acción de E/S que vaciará el búfer del fichero
asociado al manipulador. Cuando usamos un búfer de líneas, el búfer se vacía
depués de cada línea. Cuando utilizmos un búfer de bloques, el búfer se vacía
depués de que se lea o escriba un bloque. También se vacía después de cerrar
un manipulador. Esto signfica que cuando alcanzemos un salto de línea, el
mecanismode de lectura (o escritura) informará de todos los datos hasta el
momento. Pero podemos utilizar <tt class="docutils literal"><span class="pre">hFlush</span></tt> para forzar ese informe de datos.
Depués de realizar el vaciado, los datos están disponibles para cualquier otro
programa que este ejecutandose.</p>
<p>Para entender mejor el búfer de bloques, imagina que la taza de tu retrete
está configurada para vaciarse cuando alcance los cuatro litros de agua en su
interior. Así que empiezas a verter agua en su interior y cuando alcanza
la marca de los cuatro litros automaticamente se vacía, y los datos que
contenian el agua que has vertido hasta el momento son leidos o escritos. Pero
también puedes vaciar manualmente el retrete pulsando el botón que éste posee.
Esto hace que el retrete se vacie y el agua (datos) dentro del retrete es
leida o escrita. Solo por si no te has dado cuenta, vacia manualmente el
retrete es una metáfora para <tt class="docutils literal"><span class="pre">hFlush</span></tt>. Quizá este no sea una buena
analogía en el mundo de las analogías estándar de la programación, pero quería
un objeto real que se pudiera vaciar.</p>
<p>Ya hemos creado un programa que añade una tarea a nuestra lista de tareas
pendientes <tt class="docutils literal"><span class="pre">todo.txt</span></tt>, así que ahora vamos a crear uno que elimine una
tarea. Voy a mostrar el código a continuación y luego recorerremos el progeama
juntos para que veas que es realmente fácil. Usaremos una cuantas funciones
nuevas que se encuentran en <tt class="docutils literal"><span class="pre">System.Directory</span></tt> y una funcón nueva de
<tt class="docutils literal"><span class="pre">System.IO</span></tt>.</p>
<p>De todas formas, aquí tienes el programa que elimina una tarea de
<tt class="docutils literal"><span class="pre">todo.txt</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.Directory</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handle</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;todo.txt&quot;</span> <span class="kt">ReadMode</span>
    <span class="p">(</span><span class="n">tempName</span><span class="p">,</span> <span class="n">tempHandle</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="kr">let</span> <span class="n">todoTasks</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="n">line</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="n">todoTasks</span>
    <span class="n">putStrLn</span> <span class="s">&quot;These are your TO-DO items:&quot;</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Which one do you want to delete?&quot;</span>
    <span class="n">numberString</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="kr">let</span> <span class="n">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">newTodoItems</span> <span class="ow">=</span> <span class="n">delete</span> <span class="p">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="p">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="s">&quot;todo.txt&quot;</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="s">&quot;todo.txt&quot;</span>
</pre></div>
</div>
<p>Primero abrirmos el fichero <tt class="docutils literal"><span class="pre">todo.txt</span></tt> en modo lectura y ligamos el
manipulador a <tt class="docutils literal"><span class="pre">handle</span></tt>.</p>
<p>A continuación, utilizamos una función que aún no conocemos y que proviene
de <tt class="docutils literal"><span class="pre">System.IO</span></tt>, <tt class="xref cpp cpp-member docutils literal"><span class="pre">openTempFile</span></tt>. Su nombre es bastante auto descriptivo.
Toma la ruta de un directorio temporal y una plantilla para nombres para un
fichero y abre un fichero temporal. Hemos utilizado <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> para el directorio
temporal porque <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt> representa el directorio actual en cualquier S.O.
Utilizamos <tt class="docutils literal"><span class="pre">&quot;temp&quot;</span></tt> como plantilla para el nombre del fichero, de forma que
que el fichero temporal tendra como nombre <em>temp</em> más algunos caracteres
aleatorios. Devuelve una acción de E/S que crea un fichero temporal y el
resultado de esa acción es una dupla que contiene: el nombre del fichero
temporal y el manipulador asociado a ese fichero. Podríamo haber abierto
algún fichero normal como <tt class="docutils literal"><span class="pre">todo2.txt</span></tt> o algo parecido pero es un práctica
mejor utilizar <tt class="docutils literal"><span class="pre">openTempFile</span></tt> y asegurarse así de que no sobreescribimos
nada.</p>
<p>La razón por la que no hemos utilizado <tt class="docutils literal"><span class="pre">getCurrentDirectory</span></tt> para obtener
el directorio actual y luego pasarselo a <tt class="docutils literal"><span class="pre">openTempFile</span></tt> es porque <tt class="docutils literal"><span class="pre">&quot;.&quot;</span></tt>
representa el directorio actual tanto es sitemas <em>unix</em> como en <em>Windows</em>.</p>
<p>Luego ligamos los contenido de <tt class="docutils literal"><span class="pre">todo.txt</span></tt> a <tt class="docutils literal"><span class="pre">contents</span></tt>. Después dividimos
esa cadena en una lista de cadenas, una cadena por línea. Así que`
<tt class="docutils literal"><span class="pre">todoTasks</span></tt> es ahora algo como <tt class="docutils literal"><span class="pre">[&quot;Iron</span> <span class="pre">the</span> <span class="pre">dishes&quot;,</span> <span class="pre">&quot;Dust</span> <span class="pre">the</span> <span class="pre">dog&quot;,`</span>
<span class="pre">`&quot;Take</span> <span class="pre">salad</span> <span class="pre">out</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">oven&quot;]</span></tt>. Unimos los números desde el 0 en adelante
y esa lista con una función que toma un número, digamos 3, y una cadena, como
<tt class="docutils literal"><span class="pre">&quot;hey&quot;</span></tt>, así que <tt class="docutils literal"><span class="pre">numberedTasks</span></tt> sería <tt class="docutils literal"><span class="pre">[&quot;0</span> <span class="pre">-</span> <span class="pre">Iron</span> <span class="pre">the</span> <span class="pre">dishes&quot;,</span> <span class="pre">&quot;1</span> <span class="pre">-`</span>
<span class="pre">Dust</span> <span class="pre">the</span> <span class="pre">dog&quot;</span> <span class="pre">...</span></tt>. Concatenamos esa lista de cadenas en una sola cadena
delimitada por saltos de línea con <tt class="docutils literal"><span class="pre">unlines</span></tt> y la mostramos por la terminal.
Fíjate que en lugar de hacer esto podríamos haber hecho algo como <tt class="docutils literal"><span class="pre">mapM</span>
<span class="pre">putStrLn</span> <span class="pre">numberedTasks</span></tt>.</p>
<p>Le preguntamos al usuario que tarea quiere eliminar y esperamos que introduzca
un número. Digamos que queremos eliminar la número 1, que es <tt class="docutils literal"><span class="pre">Dust</span> <span class="pre">the</span> <span class="pre">dog</span></tt>,
así que introducimos <tt class="docutils literal"><span class="pre">1</span></tt>. <tt class="docutils literal"><span class="pre">numberString</span></tt> es ahora <tt class="docutils literal"><span class="pre">&quot;1&quot;</span></tt> y como queremos
un número y no una cadena, utilizamos <tt class="docutils literal"><span class="pre">read</span></tt> sobre ella para obtener un
<tt class="docutils literal"><span class="pre">1</span></tt> y ligarlo a <tt class="docutils literal"><span class="pre">number</span></tt>.</p>
<p>Intenta recordar las funciones <tt class="docutils literal"><span class="pre">delete</span></tt> y <tt class="docutils literal"><span class="pre">!!</span></tt> del módulo <tt class="docutils literal"><span class="pre">Data.List</span></tt>.
<tt class="docutils literal"><span class="pre">!!</span></tt> devuelve un elemento de una lista dado un índice y <tt class="docutils literal"><span class="pre">delete</span></tt> elimina
la primera ocurrencia de un elemento en una lista, y devuelve una nueva lista
sin dicho elemento. <tt class="docutils literal"><span class="pre">(todoTasks</span> <span class="pre">!!</span> <span class="pre">number)</span></tt>, con <tt class="docutils literal"><span class="pre">number</span></tt> a <tt class="docutils literal"><span class="pre">1</span></tt>,
devuelve <tt class="docutils literal"><span class="pre">&quot;Dust</span> <span class="pre">the</span> <span class="pre">dog&quot;</span></tt>. Ligamos <tt class="docutils literal"><span class="pre">todoTasks</span></tt> sin la primera ocurrencia
de <tt class="docutils literal"><span class="pre">&quot;Dust</span> <span class="pre">the</span> <span class="pre">dog&quot;</span></tt> a <tt class="docutils literal"><span class="pre">newTodoItems</span></tt> y luego unimos todo en una sola
cadena utilizando <tt class="docutils literal"><span class="pre">unlines</span></tt> antes de escribirlo al fichero temporal que
hemos abierto. El fichero original permanece sin cambios y el fichero temporal
ahora contiene todas las tareas que contiene el original, excepto la que
queremos eliminar.</p>
<p>Después de cerrar ambos ficheros, tanto el original como el temporal,
eliminamos el original con <tt class="xref cpp cpp-member docutils literal"><span class="pre">removeFile</span></tt>, que, como puedes ver, toma la
ruta de un fichero y lo elimina. Después de eliminar el <tt class="docutils literal"><span class="pre">todo.txt</span></tt> original,
utilizamos <tt class="xref cpp cpp-member docutils literal"><span class="pre">renameFile</span></tt> para renombrar el fichero temporal a
<tt class="docutils literal"><span class="pre">todo.txt</span></tt>. Ten cuidad, tanto <tt class="docutils literal"><span class="pre">removeFile</span></tt> como <tt class="docutils literal"><span class="pre">renameFile</span></tt> (ambas
contenidas en <tt class="docutils literal"><span class="pre">System.Directory</span></tt>) toman rutas de ficheros y no
manipuladores.</p>
<p>¡Y eso es todo! Podríamos haberlo hecho en menos líneas, pero tenemos cuidado
de no sobreescribir ningún fichero existente y preguntamos educadamente al
sistema operativo que nos diga donde podemos ubicar nuestro fichero temporal
¡Vamos a probarlo!</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell deletetodo.hs
<span class="go">These are your TO-DO items:</span>
<span class="go">0 - Iron the dishes</span>
<span class="go">1 - Dust the dog</span>
<span class="go">2 - Take salad out of the oven</span>
<span class="go">Which one do you want to delete?</span>
<span class="go">1</span>

<span class="gp">$</span> cat todo.txt
<span class="go">Iron the dishes</span>
<span class="go">Take salad out of the oven</span>

<span class="gp">$</span> runhaskell deletetodo.hs
<span class="go">These are your TO-DO items:</span>
<span class="go">0 - Iron the dishes</span>
<span class="go">1 - Take salad out of the oven</span>
<span class="go">Which one do you want to delete?</span>
<span class="go">0</span>

<span class="gp">$</span> cat todo.txt
<span class="go">Take salad out of the oven</span>
</pre></div>
</div>
</div>
<div class="section" id="parametros-de-la-linea-de-comandos">
<h2>Parámetros de la línea de comandos<a class="headerlink" href="#parametros-de-la-linea-de-comandos" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Parámetros" class="align-right" src="../_images/arguments.png" />
<p>Prácticamente es una obligación trabajar con parámetros de la línea de
comandos cuando estamos creando un programa que se ejecuta en la terminal. Por
suerte, la biblioteca estándar de Haskell tiene una buena forma de obtener los
parámetros de la línea de comandos.</p>
<p>En la sección anterior, creamos un programa para añadir tareas a nuestra lista
de tareas pendientes y otro programa para eliminar tareas de dicha lista. Hay
dos problemas con el enfoque que tomamos. La primera es que fijamos el nombre
del fichero que contenía la lista en nuestro código fuente. Simplemente
decidimos que sería <tt class="docutils literal"><span class="pre">todo.txt</span></tt> y el usuario nunca podría trabajar con varias
listas.</p>
<p>Una forma de solventar este problema sería preguntar siempre al usuario con
que lista trabajar. Utilizamos este enfoque cuando quisimos saber que tarea
quería el usuario eliminar. Funciona, pero hay mejores opciones ya que
requiere que el usuario ejecute el programa, espere a que el programa le
pregunte algo y luego decirle lo que necesita. A esto se llama programa
interactivo y el problema de los programas interactivos es: ¿Qué pasa si
queremos automatizar la ejecución del programa? Como en un fichero de comandos
por lotes que ejecuta un programa o varios de ellos.</p>
<p>Por este motivo a veces es mejor que el usuario diga al programa que tiene que
hacer cuando lo ejecuta, en lugar de que el programa tenga que preguntar al
usuario una vez se haya ejecutado. Y que mejor forma de que el usuario diga al
programa que quiere que haga cuando se ejecute que con los parámetros de la
línea de comandos.</p>
<p>El módulo <tt class="docutils literal"><span class="pre">System.Environment</span></tt> tiene dos acciones de E/S muy interesante.
Una es <tt class="xref cpp cpp-member docutils literal"><span class="pre">getArgs</span></tt>, cuya declaración de tipo es <tt class="docutils literal"><span class="pre">getArgs</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">[String]</span></tt>
y es una acción de E/S que obtendrá los parámetros con los que el programa fue
ejecutado y el resultado que contiene son dichos parámetros en forma de lista.
<tt class="xref cpp cpp-member docutils literal"><span class="pre">getProgName</span></tt> tiene el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></tt> y es una acción de E/S que
contiene el nombre del programa.</p>
<p>Aquí tienes un pequeño programa que demuestra el comportamiento de estas
funciones:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
   <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
   <span class="n">progName</span> <span class="ow">&lt;-</span> <span class="n">getProgName</span>
   <span class="n">putStrLn</span> <span class="s">&quot;The arguments are:&quot;</span>
   <span class="n">mapM</span> <span class="n">putStrLn</span> <span class="n">args</span>
   <span class="n">putStrLn</span> <span class="s">&quot;The program name is:&quot;</span>
   <span class="n">putStrLn</span> <span class="n">progName</span>
</pre></div>
</div>
<p>Ligamos <tt class="docutils literal"><span class="pre">getArgs</span></tt> y <tt class="docutils literal"><span class="pre">getProgName</span></tt> a <tt class="docutils literal"><span class="pre">args</span></tt> y <tt class="docutils literal"><span class="pre">progName</span></tt>. Mostramos
<tt class="docutils literal"><span class="pre">The</span> <span class="pre">arguments</span> <span class="pre">are:</span></tt> y luego para cada parámetro en <tt class="docutils literal"><span class="pre">args</span></tt> hacemos
<tt class="docutils literal"><span class="pre">putStrLn</span></tt>. Al final también mostramos el nombre del programa. Vamos a
compilar esto como <tt class="docutils literal"><span class="pre">arg-test</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ./arg-test first second w00t <span class="s2">&quot;multi word arg&quot;</span>
<span class="go">The arguments are:</span>
<span class="go">first</span>
<span class="go">second</span>
<span class="go">w00t</span>
<span class="go">multi word arg</span>
<span class="go">The program name is:</span>
<span class="go">arg-test</span>
</pre></div>
</div>
<p>Bien. Armados con este conocimiento podemos crear aplicaciones de línea de
comandos interesantes. De hecho vamos a continuar y a crear una. En la
sección anterior creamos programas separados para añadir tareas y para
eliminarlas. Ahora vamos a crear un programa con ambas funcionalidades, lo que
haga dependerá de los parámetros de la línea de comandos. También vamos a
permitir que puede trabajar con ficheros diferentes y no solo <tt class="docutils literal"><span class="pre">todo.txt</span></tt>.</p>
<p>Llamaremos al programa <tt class="docutils literal"><span class="pre">todo</span></tt> y será capaz de hacer tres cosas:</p>
<blockquote>
<div><ul class="simple">
<li>Ver las tareas</li>
<li>Añadir una tarea</li>
<li>Eliminar una tarea</li>
</ul>
</div></blockquote>
<p>No nos vamos a preocupar sobre posibles errores en la entrada ahora mismo.</p>
<p>Nuestro programa estará creado de forma que si queremos añadir la tarea
<tt class="docutils literal"><span class="pre">Find</span> <span class="pre">the</span> <span class="pre">magic</span> <span class="pre">sword</span> <span class="pre">of</span> <span class="pre">power</span></tt> en el fichero <tt class="docutils literal"><span class="pre">todo.txt</span></tt>, tendremos que
escribir <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">add</span> <span class="pre">todo.txt</span> <span class="pre">&quot;Find</span> <span class="pre">the</span> <span class="pre">magic</span> <span class="pre">sword</span> <span class="pre">of</span> <span class="pre">power&quot;</span></tt> en la terminal.
Para ver las tareas simplemente ejecutamos <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">view</span> <span class="pre">todo.txt</span></tt> y para
eliminar la tarea con índice 2 hacemos <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">remove</span> <span class="pre">todo.txt</span> <span class="pre">2</span></tt>.</p>
<p>Empezaremos creando una lista de asociación. Será una simple lista de
asociación que tenga como claves los parámetros de la línea de comandos y
funciones como sus correspondientes valores. Todas estas funciones serán del
tipo <tt class="docutils literal"><span class="pre">[String]</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></tt>. Tomarán la lista de parámetros de la línea de
comandos y devolverán una acción de E/S que se encarga de mostrar las tareas,
añadir una tarea o eliminar una tarea.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.Directory</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">dispatch</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)]</span>
<span class="nf">dispatch</span> <span class="ow">=</span>  <span class="p">[</span> <span class="p">(</span><span class="s">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;view&quot;</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;remove&quot;</span><span class="p">,</span> <span class="n">remove</span><span class="p">)</span>
            <span class="p">]</span>
</pre></div>
</div>
<p>Tenemos que definir <tt class="docutils literal"><span class="pre">main</span></tt>, <tt class="docutils literal"><span class="pre">add</span></tt>, <tt class="docutils literal"><span class="pre">view</span></tt> y <tt class="docutils literal"><span class="pre">remove</span></tt>, así que
empecemos con <tt class="docutils literal"><span class="pre">main</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">command</span><span class="kt">:</span><span class="n">args</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
    <span class="kr">let</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">action</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">command</span> <span class="n">dispatch</span>
    <span class="n">action</span> <span class="n">args</span>
</pre></div>
</div>
<p>Primero, ligamos los parámetros a <tt class="docutils literal"><span class="pre">(command:args)</span></tt>. Si te acuerdas del
ajuste de patrones, esto significa que el primer parámetro se ligará con
<tt class="docutils literal"><span class="pre">command</span></tt> y el resto de ellos con <tt class="docutils literal"><span class="pre">args</span></tt>. Si ejecutamos nuestro programa
como <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">add</span> <span class="pre">todo.txt</span> <span class="pre">&quot;Spank</span> <span class="pre">the</span> <span class="pre">monkey&quot;</span></tt>, <tt class="docutils literal"><span class="pre">command</span></tt> será <tt class="docutils literal"><span class="pre">&quot;add&quot;</span></tt> y
<tt class="docutils literal"><span class="pre">args</span></tt> será <tt class="docutils literal"><span class="pre">[&quot;todo.txt&quot;,</span> <span class="pre">&quot;Spank</span> <span class="pre">the</span> <span class="pre">monkey&quot;]</span></tt>.</p>
<p>En la siguiente línea buscamos el comando en lista de asociación. Como
<tt class="docutils literal"><span class="pre">&quot;add&quot;</span></tt> se asocia con <tt class="docutils literal"><span class="pre">add</span></tt>, obtendremos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">add</span></tt> como resultado.
Utilizamos de nuevo el ajuste de patrones para extraer esta función del tipo
<tt class="docutils literal"><span class="pre">Maybe</span></tt> ¿Qué pasaría si el comando no estuviese en la lista de asociación?
Bueno, entonces devolvería <tt class="docutils literal"><span class="pre">Nothing</span></tt>, pero ya hemos dicho que no nos vamos
a preocupar demasiado de los errores en la entrada, así que el ajuste de
patrones fallaría y junto a él nuestro programa.</p>
<p>Para terminar, llamamos a la función <tt class="docutils literal"><span class="pre">action</span></tt> con el resto de la lista de
parámetros. Esto devolverá una acción de E/S que o bien añadirá una tarea, o
bien mostrará una lista de tareas, o bien eliminará una tarea. Y como está
acción es parte del bloque <tt class="docutils literal"><span class="pre">do</span></tt> de <tt class="docutils literal"><span class="pre">main</span></tt>, se ejecutará. Si seguimos el
ejemplo que hemos utilizado hasta ahora nuestra función <tt class="docutils literal"><span class="pre">action</span></tt> será
<tt class="docutils literal"><span class="pre">add</span></tt>, la cual será llamada con <tt class="docutils literal"><span class="pre">args</span></tt> (es decir con <tt class="docutils literal"><span class="pre">[&quot;todo.txt&quot;,</span>
<span class="pre">&quot;Spank</span> <span class="pre">the</span> <span class="pre">monkey&quot;]</span></tt>) y devolverá una acción que añadirá la tarea <tt class="docutils literal"><span class="pre">Spank</span>
<span class="pre">the</span> <span class="pre">monkey</span></tt> a <tt class="docutils literal"><span class="pre">todo.txt</span></tt>.</p>
<p>¡Genial! Todo lo que nos queda ahora es implementar las funciones <tt class="docutils literal"><span class="pre">add</span></tt>,
<tt class="docutils literal"><span class="pre">view</span></tt> y <tt class="docutils literal"><span class="pre">remove</span></tt>. Empecemos con <tt class="docutils literal"><span class="pre">add</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">add</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">add</span> <span class="p">[</span><span class="n">fileName</span><span class="p">,</span> <span class="n">todoItem</span><span class="p">]</span> <span class="ow">=</span> <span class="n">appendFile</span> <span class="n">fileName</span> <span class="p">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Si ejecutamos nuestro programa como <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">add</span> <span class="pre">todo.txt</span> <span class="pre">&quot;Spank</span> <span class="pre">the</span> <span class="pre">monkey&quot;</span></tt>,
<tt class="docutils literal"><span class="pre">&quot;add&quot;</span></tt> será ligado a <tt class="docutils literal"><span class="pre">command</span></tt> en el primer ajuste de patrones del bloque
<tt class="docutils literal"><span class="pre">main</span></tt>, mientras que <tt class="docutils literal"><span class="pre">[&quot;todo.txt&quot;,</span> <span class="pre">&quot;Spank</span> <span class="pre">the</span> <span class="pre">monkey&quot;]</span></tt> será pasado a la
función que obtengamos de la lista de asociación. Así que como no estamos
preocupándonos acerca de posibles entradas erróneas, podemos usar el ajuste
de patrones directamente sobre una lista con esos dos elementos y devolver una
acción de E/S que añada la tarea al final de fichero, junto con un salto de
línea.</p>
<p>A continuación vamos a implementar la funcionalidad de mostrar la lista de
tareas. Si queremos ver los elementos de un fichero, ejecutamos <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">view</span>
<span class="pre">todo.txt</span></tt>. Así que en el primer ajuste de patrones, <tt class="docutils literal"><span class="pre">command</span></tt> será
<tt class="docutils literal"><span class="pre">&quot;view&quot;</span></tt> y <tt class="docutils literal"><span class="pre">args</span></tt> será <tt class="docutils literal"><span class="pre">[&quot;todo.txt&quot;]</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">view</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">view</span> <span class="p">[</span><span class="n">fileName</span><span class="p">]</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
    <span class="kr">let</span> <span class="n">todoTasks</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="n">line</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="n">todoTasks</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>
</pre></div>
</div>
<p>Ya hicimos algo muy parecido en el programa que eliminaba tareas a la hora de
mostrar las tareas para que el usuario pudiera elegir una, solo que aquí solo
mostramos las tareas.</p>
<p>Y para terminar implementamos <tt class="docutils literal"><span class="pre">remove</span></tt>. Será muy similar al programa que
eliminaba tareas, así que si hay algo que no entiendas revisa la explicación
que dimos en su momento. La principal diferencia es que no fijamos el nombre
del fichero a <tt class="docutils literal"><span class="pre">todo.txt</span></tt> sino que lo obtenemos como parámetro. Tampoco
preguntamos al usuario el índice de la tarea a eliminar ya que también lo
obtenemos como un parámetro más.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">remove</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">remove</span> <span class="p">[</span><span class="n">fileName</span><span class="p">,</span> <span class="n">numberString</span><span class="p">]</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handle</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="n">fileName</span> <span class="kt">ReadMode</span>
    <span class="p">(</span><span class="n">tempName</span><span class="p">,</span> <span class="n">tempHandle</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="kr">let</span> <span class="n">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">todoTasks</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">newTodoItems</span> <span class="ow">=</span> <span class="n">delete</span> <span class="p">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="p">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="n">fileName</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="n">fileName</span>
</pre></div>
</div>
<p>Abrimos el fichero basándonos en <tt class="docutils literal"><span class="pre">fileName</span></tt> y abrimos un fichero temporal,
eliminamos la línea con índice de línea que el usuario desea eliminar, lo
escribimos en un fichero temporal, eliminamos el fichero original y
renombramos el fichero temporal a <tt class="docutils literal"><span class="pre">fileName</span></tt>.</p>
<p>¡Aquí tienes el programa entero en todo su esplendor!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.Directory</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">dispatch</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span><span class="p">)]</span>
<span class="nf">dispatch</span> <span class="ow">=</span>  <span class="p">[</span> <span class="p">(</span><span class="s">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;view&quot;</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
            <span class="p">,</span> <span class="p">(</span><span class="s">&quot;remove&quot;</span><span class="p">,</span> <span class="n">remove</span><span class="p">)</span>
            <span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">command</span><span class="kt">:</span><span class="n">args</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
    <span class="kr">let</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">action</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">command</span> <span class="n">dispatch</span>
    <span class="n">action</span> <span class="n">args</span>

<span class="nf">add</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">add</span> <span class="p">[</span><span class="n">fileName</span><span class="p">,</span> <span class="n">todoItem</span><span class="p">]</span> <span class="ow">=</span> <span class="n">appendFile</span> <span class="n">fileName</span> <span class="p">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

<span class="nf">view</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">view</span> <span class="p">[</span><span class="n">fileName</span><span class="p">]</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
    <span class="kr">let</span> <span class="n">todoTasks</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">n</span> <span class="n">line</span> <span class="ow">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span> <span class="n">todoTasks</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>

<span class="nf">remove</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">remove</span> <span class="p">[</span><span class="n">fileName</span><span class="p">,</span> <span class="n">numberString</span><span class="p">]</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">handle</span> <span class="ow">&lt;-</span> <span class="n">openFile</span> <span class="n">fileName</span> <span class="kt">ReadMode</span>
    <span class="p">(</span><span class="n">tempName</span><span class="p">,</span> <span class="n">tempHandle</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="kr">let</span> <span class="n">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">todoTasks</span> <span class="ow">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">newTodoItems</span> <span class="ow">=</span> <span class="n">delete</span> <span class="p">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="p">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="o">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="n">fileName</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="n">fileName</span>
</pre></div>
</div>
<img alt="Ensalada" class="align-left" src="../_images/salad.png" />
<p>Resumiendo: creamos una lista de asociación que asocie los comandos con
funciones que tomen argumentos de la línea de comandos y devuelvan acciones
de E/S. Vemos que comando quiere ejecutar el usuario y obtenemos la función
apropiada a partir de la lista de asociación. Llamamos a esa función con el
resto de parámetros de la línea de comandos y obtenemos una acción de E/S que
realizará la acción apropiada cuando sea ejecutada.</p>
<p>En otros lenguajes, deberíamos haber implementado esto utilizando un gran
<tt class="docutils literal"><span class="pre">switch</span></tt> o cualquier otra cosa, pero gracias a las funciones de orden
superior se nos permite crear una lista de asociación que nos devolverá la
acción de E/S adecuada para cada comando que pasemos por la línea de comandos.</p>
<p>¡Vamos a probar nuestra aplicación!</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> ./todo view todo.txt
<span class="go">0 - Iron the dishes</span>
<span class="go">1 - Dust the dog</span>
<span class="go">2 - Take salad out of the oven</span>

<span class="gp">$</span> ./todo add todo.txt <span class="s2">&quot;Pick up children from drycleaners&quot;</span>

<span class="gp">$</span> ./todo view todo.txt
<span class="go">0 - Iron the dishes</span>
<span class="go">1 - Dust the dog</span>
<span class="go">2 - Take salad out of the oven</span>
<span class="go">3 - Pick up children from drycleaners</span>

<span class="gp">$</span> ./todo remove todo.txt 2

<span class="gp">$</span> ./todo view todo.txt
<span class="go">0 - Iron the dishes</span>
<span class="go">1 - Dust the dog</span>
<span class="go">2 - Pick up children from drycleaners</span>
</pre></div>
</div>
<p>Otra cosa interesante acerca de esto es que bastante sencillo añadir
funcionalidad adicional. Simplemente tenemos que agregar un elemento más en
la lista de asociación y luego implementar la función correspondiente. Como
ejercicio puedes implementar el comando <tt class="docutils literal"><span class="pre">bump</span></tt> que tomará un fichero y un
y un índice de una tarea y hará que dicha tarea aparezca al principio de la
lista de tareas pendientes.</p>
<p>Puedes hacer que este programa fallé de forma más elegante en caso de que
reciba unos parámetros erróneos (como por ejemplo <tt class="docutils literal"><span class="pre">todo</span> <span class="pre">UP</span> <span class="pre">YOURS</span> <span class="pre">HAHAHAH</span></tt>)
creando una acción de E/S que simplemente informe que ha ocurrido un error
(digamos <tt class="docutils literal"><span class="pre">errorExit</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">()</span></tt>) y luego comprar si hay algún parámetro
erróneo para realizar el informe. Otra forma sería utilizando excepciones, lo
cual veremos dentro de poco.</p>
</div>
<div class="section" id="aleatoriedad">
<span id="id1"></span><h2>Aleatoriedad<a class="headerlink" href="#aleatoriedad" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Aleatorio" class="align-right" src="../_images/random.png" />
<p>Muchas veces mientras programamos, necesitamos obtener algunos datos
aleatorios. Quizá estemos haciendo un juego en el que se tenga que lanzar un
dado o quizá necesitemos generar algunos datos para comprobar nuestro
programa. Hay mucho usos para los datos aleatorios. Bueno, en realidad,
pseudo-aleatorios, ya que todos sabemos que la única fuente verdadera de
aleatoriedad en un mono sobre un monociclo con un trozo de queso en un mano
y su trasero en la otra. En esta sección, vamos a ver como Haskell genera
datos aparentemente aleatorios.</p>
<p>En la mayoría de los otros lenguajes, tenemos funciones que nos devuelven
números aleatorios. Cada vez que llamas a la función, obtienes (con suerte)
un número aleatorio diferente. Bueno, recuerda, Haskell es un leguaje
funcional puro. Por lo tanto posee transparencia referencial. Lo que
significa que una función, dados los mismo parámetros, debe producir el mismo
resultado. Esto es genial ya que nos permite razonar sobre los programas de
una forma diferente y nos permite retrasar la evaluación de las operaciones
hasta que realmente las necesitemos. Si llamamos a una función, podemos estar
seguros de que no hará cualquier otra cosa antes de darnos un resultado. Todo
lo que importa es su resultado. Sin embargo, esto hace un poco complicado
obtener números aleatorios. Si tenemos una función como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">randomNumber</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">randomNumber</span> <span class="ow">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>No será muy útil como función de números aleatorios ya que siempre nos
devolverá el mismo <tt class="docutils literal"><span class="pre">4</span></tt>, aunque puedo asegurar que ese 4 es totalmente
aleatorio ya que acabo de lanzar un dado para obtenerlo.</p>
<p>¿Qué hacen demás lenguajes para generar número aparentemente aleatorios?
Bueno, primero obtienen algunos datos de tu computadora, como la hora actual,
cuanto y a donde has movido el ratón, el ruido que haces delante del
computador, etc. Y basándose en eso, devuelve un número que parece aleatorio.
La combinación de esos factores (la aleatoriedad) probablemente es diferente
en cada instante de tiempo, así que obtienes números aleatorios diferentes.</p>
<p>Así que en Haskell, podemos crear un número aleatorio si creamos una función
que tome como parámetro esa aleatoriedad y devuelva un número (o cualquier
otro tipo de dato) basándose en ella.</p>
<p>Utilizaremos el módulo <tt class="docutils literal"><span class="pre">System.Random</span></tt>. Contiene todas las funciones que
calmaran nuestra sed de aleatoriedad. Vamos a jugar con una de las funciones
que exporta, llamada <tt class="xref cpp cpp-member docutils literal"><span class="pre">random</span></tt>. Su declaración de tipo es <tt class="docutils literal"><span class="pre">random</span> <span class="pre">::</span>
<span class="pre">(RandomGen</span> <span class="pre">g,</span> <span class="pre">Random</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">g</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">g)</span></tt> ¡Wau! Hay nuevas clases de tipos en
esta declaración. La clase de tipos <tt class="xref cpp cpp-class docutils literal"><span class="pre">RandomGen</span></tt> es para tipos que pueden
actuar como fuentes de aleatoriedad. La clase de tipos <tt class="xref cpp cpp-class docutils literal"><span class="pre">Random</span></tt> es para
tipos que pueden tener datos aleatorios. Un dato booleano puede tener valores
aleatorios, <tt class="xref docutils literal"><span class="pre">True</span></tt> o <tt class="xref docutils literal"><span class="pre">False</span></tt>. Un número también puede tomar un conjunto
de diferentes valores alotarios ¿Puede el tipo función tomar valores
aleatorios? No creo. Si traducimos la declaración de tipo de <tt class="docutils literal"><span class="pre">random</span></tt> al
español temos algo como: toma un generador aleatorio (es decir nuestra fuente
de aleatoriedad) y devuelve un valor aleatorio y un nuevo generador aleatorio
¿Por qué devuelve un nuevo generador junto al valor aleatorio? Lo veremos
enseguida.</p>
<p>Para utilizar la función <tt class="docutils literal"><span class="pre">random</span></tt>, primero tenemos que obtener uno de esos
generadores aleatorios. El módulo <tt class="docutils literal"><span class="pre">System.Random</span></tt> exporta un tipo
interensante llamado <tt class="xref cpp cpp-type docutils literal"><span class="pre">StdGen</span></tt> que posee una instancia para la clase de
tipos <tt class="docutils literal"><span class="pre">RandomGen</span></tt>. Podemos crear un <tt class="docutils literal"><span class="pre">StdGen</span></tt> manualmente o podemos decirle
al sistema que nos de uno basandose en un motón de cosas aleatorias.</p>
<p>Para crear manualmente un generador aletario, utilizamos la función
<tt class="xref cpp cpp-member docutils literal"><span class="pre">mkStdGen</span></tt>. Tiene el tipo <tt class="docutils literal"><span class="pre">Int</span> <span class="pre">-&gt;</span> <span class="pre">StdGen</span></tt>. Toma un entero y basándose
en eso, nos devuelve un generador aleatorio. Bien, vamos a intentar utilizar
el tandem <tt class="docutils literal"><span class="pre">random</span></tt> <tt class="docutils literal"><span class="pre">mkStdGen</span></tt> para obtener un número aleatorio.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; random (mkStdGen 100)</span>
<span class="go">&lt;interactive&gt;:1:0:</span>
<span class="go">    Ambiguous type variable `a&#39; in the constraint:</span>
<span class="go">      `Random a&#39; arising from a use of `random&#39; at &lt;interactive&gt;:1:0-20</span>
<span class="go">    Probable fix: add a type signature that fixes these type variable(s)</span>
</pre></div>
</div>
<p>¿Qué pasa? Ah, vale, la función <tt class="docutils literal"><span class="pre">random</span></tt> puede devolver cualquier tipo que
sea miembro de la clase de tipos <tt class="docutils literal"><span class="pre">Random</span></tt>, así que tenemos que decir a
Haskell exactamente que tipo queremos. Recuerda también que devuelve un valor
aleatorio y un generador.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)</span>
<span class="go">(-1352021624,651872571 1655838864)</span>
</pre></div>
</div>
<p>¡Por fin, un número que parece aleatorio! El primer componente de la dupla es
nuestro número aleatorio mientras que el segundo componente es una
representación textual del nuevo generador ¿Qué sucede si volvemos a llamar
<tt class="docutils literal"><span class="pre">random</span></tt> con el mismo generador?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)</span>
<span class="go">(-1352021624,651872571 1655838864)</span>
</pre></div>
</div>
<p>Por supuesto. El mismo resultado para los mismos parámetros. Vamos a probar
dándole como parámetro un generador diferente.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; random (mkStdGen 949494) :: (Int, StdGen)</span>
<span class="go">(539963926,466647808 1655838864)</span>
</pre></div>
</div>
<p>Genial, un número diferente. Podemos usar la anotación de tipo con muchos
otros tipos.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; random (mkStdGen 949488) :: (Float, StdGen)</span>
<span class="go">(0.8938442,1597344447 1655838864)</span>
<span class="go">ghci&gt; random (mkStdGen 949488) :: (Bool, StdGen)</span>
<span class="go">(False,1485632275 40692)</span>
<span class="go">ghci&gt; random (mkStdGen 949488) :: (Integer, StdGen)</span>
<span class="go">(1691547873,1597344447 1655838864)</span>
</pre></div>
</div>
<p>Vamos a crear una función que simule lanzar una modena tres veces. Si
<tt class="docutils literal"><span class="pre">random</span></tt> no devolviera un generador nuevo junto con el valor aleatorio,
tendríamos que hacer que esta función tomara tres generadores como parámetros
y luego devolver un resultado por cada uno de ellos. Pero esto parece que no
es muy correcto ya que si un generador puede crear un valor aleatorio del
tipo <tt class="docutils literal"><span class="pre">Int</span></tt> (el cual puede tener una gran variedad de posibles valores)
debería ser capaz de simular tres lazamientos de una moneda (que solo puede
tener ocho posibles valores). Así que este es el porqué de que <tt class="docutils literal"><span class="pre">random</span></tt>
devuelva un nuevo generador junto al valor generado.</p>
<p>Represtaremos el resultado del lanzamiento de una moneda con un simple
<tt class="docutils literal"><span class="pre">Bool</span></tt>. <tt class="xref docutils literal"><span class="pre">True</span></tt> para cara, <tt class="xref docutils literal"><span class="pre">False</span></tt> para cruz.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">threeCoins</span> <span class="ow">::</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nf">threeCoins</span> <span class="n">gen</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="p">(</span><span class="n">secondCoin</span><span class="p">,</span> <span class="n">newGen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen</span>
        <span class="p">(</span><span class="n">thirdCoin</span><span class="p">,</span> <span class="n">newGen&#39;&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen&#39;</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">secondCoin</span><span class="p">,</span> <span class="n">thirdCoin</span><span class="p">)</span>
</pre></div>
</div>
<p>Llamamos a <tt class="docutils literal"><span class="pre">random</span></tt> con el generador que obtivimos como parámetro y
obtenemos el resultado de lanzar una moneda junto a un nuevo generador. Luego
volvemos a llamar la misma función, solo que esta vez con nuestro nuevo
generador, de forma que obtenemos el segundo resultado. Si la hubiéramos
llamado con el mismo generador las tres veces, todos los resultados hubieran
sido iguales y por tanto solo hubiéramos podido obtener como resultados
<tt class="docutils literal"><span class="pre">(False,</span> <span class="pre">False,</span> <span class="pre">False)</span></tt> o <tt class="docutils literal"><span class="pre">(True,</span> <span class="pre">True,</span> <span class="pre">True)</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; threeCoins (mkStdGen 21)</span>
<span class="go">(True,True,True)</span>
<span class="go">ghci&gt; threeCoins (mkStdGen 22)</span>
<span class="go">(True,False,True)</span>
<span class="go">ghci&gt; threeCoins (mkStdGen 943)</span>
<span class="go">(True,False,True)</span>
<span class="go">ghci&gt; threeCoins (mkStdGen 944)</span>
<span class="go">(True,True,True)</span>
</pre></div>
</div>
<p>Fíjate que no hemos tendio que hacer <tt class="docutils literal"><span class="pre">random</span> <span class="pre">gen</span> <span class="pre">::</span> <span class="pre">(Bool,</span> <span class="pre">StdGen)</span></tt>. Se
debe a que ya hemos especificado en la declaración de tipo de la función que
queremos valores booleanos. Por este motivo Haskell puede inferir que queremos
valores booleanos.</p>
<p>¿Y qué pasaría si quisiéramos lanzar la moneda cuatro veces? ¿Y cinco? Bien,
para eso tenemos la función llamada <tt class="xref cpp cpp-member docutils literal"><span class="pre">randoms</span></tt> que toma un generador y
devulve una secuencia infinita de valores aletorios.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Int]</span>
<span class="go">[-1807975507,545074951,-1015194702,-1622477312,-502893664]</span>
<span class="go">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Bool]</span>
<span class="go">[True,True,True,True,False]</span>
<span class="go">ghci&gt; take 5 $ randoms (mkStdGen 11) :: [Float]</span>
<span class="go">[7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]</span>
</pre></div>
</div>
<p>¿Por qué <tt class="docutils literal"><span class="pre">randoms</span></tt> no devuelve un nuevo generador junto con la lista?
Podemos implementar la función <tt class="docutils literal"><span class="pre">randoms</span></tt> de forma muy sencilla como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">randoms&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">randoms&#39;</span> <span class="n">gen</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span> <span class="kr">in</span> <span class="n">value</span><span class="kt">:</span><span class="n">randoms&#39;</span> <span class="n">newGen</span>
</pre></div>
</div>
<p>Una función recursiva. Obtenemos un valor aleatorio y nuevo generador a parir
del generador actual y creamos una lista que tenga el valor aleatorio como
cabeza y una lista de valores aloratorios basada en el nuevo generador como
cola. Como queremos ser capazes de generar una cantidad infinita valores
aleatorios, no podemos devolver un nuevo generador.</p>
<p>Podríamos crear una función que generara secuencias de números aletorios
finitas y devolviera también un nuevo generador.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">finiteRandoms</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">g</span><span class="p">)</span>
<span class="nf">finiteRandoms</span> <span class="mi">0</span> <span class="n">gen</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="n">gen</span><span class="p">)</span>
<span class="nf">finiteRandoms</span> <span class="n">n</span> <span class="n">gen</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="p">(</span><span class="n">restOfList</span><span class="p">,</span> <span class="n">finalGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">finiteRandoms</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">newGen</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">value</span><span class="kt">:</span><span class="n">restOfList</span><span class="p">,</span> <span class="n">finalGen</span><span class="p">)</span>
</pre></div>
</div>
<p>De nuevo, una funcón recursiva. Decimos que si queremos cero valores
alatorios, devolvemos una lista vacía y el generador que se nos dió. Para
cualquier otra cantidad de valores aleatorios, primero obtenemos un número
aleatorio y nuevo generador. Esto será la cabeza. Luego decimos que la cola
será <tt class="docutils literal"><span class="pre">n-1</span></tt> valores aleatorios generadors con el nuevo generador. Terminamos
devolviendo la cabeza junto el resto de la lista y el generador que obtuvimos
cuando generamos los <tt class="docutils literal"><span class="pre">n-1</span></tt> valores aleatorios.</p>
<p>¿Y si queremos obtener un valor aleatorio dentro de un determindo rango? Todos
los enteros que hemos generador hasta ahora son escandalosamente grandes o
pequeños ¿Y si queremos lanzar un dado? Bueno, para eso utilizamos
<tt class="xref cpp cpp-member docutils literal"><span class="pre">randomR</span></tt>. Su declaración de tipo es <tt class="docutils literal"><span class="pre">randomR</span> <span class="pre">::</span> <span class="pre">(RandomGen</span> <span class="pre">g,</span> <span class="pre">Random</span> <span class="pre">a)</span>
<span class="pre">::</span> <span class="pre">(a,</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">g</span> <span class="pre">-&gt;</span> <span class="pre">(a,</span> <span class="pre">g)</span></tt>, lo que significa que tiene comportamiento similar
a <tt class="docutils literal"><span class="pre">random</span></tt>, solo que primero toma una dupla de valores que establecerán el
límite superior e inferior de forma que el valor aleatorio generado esté
dentro de ese rango.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; randomR (1,6) (mkStdGen 359353)</span>
<span class="go">(6,1494289578 40692)</span>
<span class="go">ghci&gt; randomR (1,6) (mkStdGen 35935335)</span>
<span class="go">(3,1250031057 40692)</span>
</pre></div>
</div>
<p>También existe <tt class="docutils literal"><span class="pre">randomRs</span></tt>, la cual produce una secuencia de valores
aleatorios dentro de nuestro rango.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; take 10 $ randomRs (&#39;a&#39;,&#39;z&#39;) (mkStdGen 3) :: [Char]</span>
<span class="go">&quot;ndkxbvmomg&quot;</span>
</pre></div>
</div>
<p>Genial, tiene pinta de ser una contraseña de alto secreto.</p>
<p>Puedes estar preguntándote que tienes que ver esta sección con la E/S. Hasta
ahora no hemos visto nada relacionado con la E/S. Bien, hasta ahora siempre
hemos creado nuestro generador de forma manual basándonos en algún entero
arbitrario. El problema es que, en los programas reales, siempre devolverán
los mismos números aleatorios, lo cual no es muy buena idea. Por este motivo
<tt class="docutils literal"><span class="pre">System.Random</span></tt> nos ofrece la acción de E/S <tt class="xref cpp cpp-member docutils literal"><span class="pre">getStdGen</span></tt> que tiene
el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">StdGen</span></tt>. Cuando se inicia la ejecución de un programa, éste
pregunta al sistema por un buen generador de valores aleatorios y lo almacena
en algo llamado generador global. <tt class="docutils literal"><span class="pre">getStdGen</span></tt> trae ese generador para que
podamos ligarlo a algo.</p>
<p>Aquí tienes un programa simple que genera una cadena aleatoria.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell random_string.hs
<span class="go">pybphhzzhuepknbykxhe</span>
<span class="gp">$</span> runhaskell random_string.hs
<span class="go">eiqgcxykivpudlsvvjpg</span>
<span class="gp">$</span> runhaskell random_string.hs
<span class="go">nzdceoconysdgcyqjruo</span>
<span class="gp">$</span> runhaskell random_string.hs
<span class="go">bakzhnnuzrkgvesqplrx</span>
</pre></div>
</div>
<p>Ten cuidad ya que al llamar dos veces a <tt class="docutils literal"><span class="pre">getStdGen</span></tt> estamos preguntándole
dos veces al sistema por el mismo generador global. Si hacemos algo como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen</span><span class="p">)</span>
    <span class="n">gen2</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen2</span><span class="p">)</span>
</pre></div>
</div>
<p>Obtendremos la misma cadena mostrada dos veces. Una forma de obtener dos
cadenas diferentes de 20 caracteres de longitud es crear una lista infinita
y tomar los 20 primeros caracteres y mostrarlos en una línea, luego tomamos
los 20 siguientes y los mostramos en una segunda línea. Para realizar esto
podemos utilizar la función <tt class="docutils literal"><span class="pre">splitAt</span></tt> de <tt class="docutils literal"><span class="pre">Data.List</span></tt>, que divide una
lista en un índice dado y devuelve una dupla que tiene la primera parte como
primer componente y la segunda parte como segundo componente.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="kr">let</span> <span class="n">randomChars</span> <span class="ow">=</span> <span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen</span>
        <span class="p">(</span><span class="n">first20</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">20</span> <span class="n">randomChars</span>
        <span class="p">(</span><span class="n">second20</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">20</span> <span class="n">rest</span>
    <span class="n">putStrLn</span> <span class="n">first20</span>
    <span class="n">putStr</span> <span class="n">second20</span>
</pre></div>
</div>
<p>Otra forma de hacerlo es utilizando la acción <tt class="xref cpp cpp-member docutils literal"><span class="pre">newStdGen</span></tt> que divide el
generador de valores aleatorios en dos nuevos generadores. Actualiza el
generador global con uno de ellos y el toro lo de vuelve como resultado de la
acción.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen</span><span class="p">)</span>
    <span class="n">gen&#39;</span> <span class="ow">&lt;-</span> <span class="n">newStdGen</span>
    <span class="n">putStr</span> <span class="o">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="p">(</span><span class="n">randomRs</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="n">gen&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>No solo obtenemos un nuevo generador cuando ligamos <tt class="docutils literal"><span class="pre">newStdGen</span></tt>, sino que
el generador global también se actualiza, así que si después utilizamos
<tt class="docutils literal"><span class="pre">getStdGen</span></tt> obtendremos otro generador que será diferente a <tt class="docutils literal"><span class="pre">gen</span></tt>.</p>
<p>Vamos a crear un programa que haga que nuestro usuario adivine el número en
el que estamos pensado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span><span class="p">(</span><span class="n">when</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">askForNumber</span> <span class="n">gen</span>

<span class="nf">askForNumber</span> <span class="ow">::</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">askForNumber</span> <span class="n">gen</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">randNumber</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="n">gen</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">StdGen</span><span class="p">)</span>
    <span class="n">putStr</span> <span class="s">&quot;Which number in the range from 1 to 10 am I thinking of? &quot;</span>
    <span class="n">numberString</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">not</span> <span class="o">$</span> <span class="n">null</span> <span class="n">numberString</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="kr">if</span> <span class="n">randNumber</span> <span class="o">==</span> <span class="n">number</span>
            <span class="kr">then</span> <span class="n">putStrLn</span> <span class="s">&quot;You are correct!&quot;</span>
            <span class="kr">else</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Sorry, it was &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">randNumber</span>
        <span class="n">askForNumber</span> <span class="n">newGen</span>
</pre></div>
</div>
<img alt="Sota de diamantes" class="align-left" src="../_images/jackofdiamonds.png" />
<p>Hemos creado la función <tt class="docutils literal"><span class="pre">askForNumber</span></tt>, que toma un generador de valores
aleatorios y devuelve una acción de E/S que preguntará al usuario por un
número y le dirá si ha acertado o no. Dentro de esta función, primero
generamos un número aleatorio y nuevo generador basándonos en el generador
que obtuvimos como parámetro, los llamamos <tt class="docutils literal"><span class="pre">randNumber</span></tt> y <tt class="docutils literal"><span class="pre">newGen</span></tt>.
Digamos que el número generado es el <tt class="docutils literal"><span class="pre">7</span></tt>. Luego preguntamos al usuario en
que número estamos pensando. Ejecutamos <tt class="docutils literal"><span class="pre">getLine</span></tt> y ligamos el resultado a
<tt class="docutils literal"><span class="pre">numberString</span></tt>. Cuando el usuario introduce <tt class="docutils literal"><span class="pre">7</span></tt>, <tt class="docutils literal"><span class="pre">numberString</span></tt> se
convierte en <tt class="docutils literal"><span class="pre">&quot;7&quot;</span></tt>. Luego, utilizamos una cláusula <tt class="docutils literal"><span class="pre">when</span></tt> para comprobar
si la cadena que ha introducido el usuario está vacía. Si lo está, una acción
de E/S vacía (<tt class="docutils literal"><span class="pre">return</span> <span class="pre">()</span></tt>) se ejecutará, terminando así nuestro programa. Si
no lo está, la acción contenida en el bloque <tt class="docutils literal"><span class="pre">do</span></tt> se ejecutará. Utilizamos
<tt class="docutils literal"><span class="pre">read</span></tt> sobre <tt class="docutils literal"><span class="pre">numberString</span></tt> para convertirla en un número, el cual
ahora será <tt class="docutils literal"><span class="pre">7</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si el usuario introduce algo que <tt class="docutils literal"><span class="pre">read</span></tt> no pueda leer (como
<tt class="docutils literal"><span class="pre">&quot;haha&quot;</span></tt>), nuestro programa terminará bruscamente con un mensaje
de error bastante horrendo. Si no te apetece que el programa termine
de esta forma, utiliza la función <tt class="xref cpp cpp-member docutils literal"><span class="pre">reads</span></tt>, que devuelve una
lista vacía cuando no puede leer una cadena. Cuando si puede
devuelve una lista unitaria que contiene una dupla con nuestro valor
deseado como primer componente y una cadena con lo que no ha
consumido como segundo componente.</p>
</div>
<p>Comprobamos si el número que han introducido es igual al número que hemos
generado aleatoriamente y damos al usuario un mensaje apropiado. Luego
llamamos a <tt class="docutils literal"><span class="pre">askForNumber</span></tt> de forma recursiva, solo que esta vez con el
nuevo generador que hemos obtenido, de forma que obtenemos una acción de E/S
como la que acabamos de ejecutar, solo que depende de un generador diferente.</p>
<p><tt class="docutils literal"><span class="pre">main</span></tt> consiste básicamente en obtener el generador de valores aleatorio y
llamar a <tt class="docutils literal"><span class="pre">askForNumber</span></tt> con el generador inicial.</p>
<p>¡Aquí tienes nuestro programa en acción!</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell guess_the_number.hs
<span class="go">Which number in the range from 1 to 10 am I thinking of? 4</span>
<span class="go">Sorry, it was 3</span>
<span class="go">Which number in the range from 1 to 10 am I thinking of? 10</span>
<span class="go">You are correct!</span>
<span class="go">Which number in the range from 1 to 10 am I thinking of? 2</span>
<span class="go">Sorry, it was 4</span>
<span class="go">Which number in the range from 1 to 10 am I thinking of? 5</span>
<span class="go">Sorry, it was 10</span>
<span class="go">Which number in the range from 1 to 10 am I thinking of?</span>
</pre></div>
</div>
<p>Otra forma de hacer el mismo programa sería:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span><span class="p">(</span><span class="n">when</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">gen</span> <span class="ow">&lt;-</span> <span class="n">getStdGen</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">randNumber</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">randomR</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="n">gen</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">StdGen</span><span class="p">)</span>
    <span class="n">putStr</span> <span class="s">&quot;Which number in the range from 1 to 10 am I thinking of? &quot;</span>
    <span class="n">numberString</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">when</span> <span class="p">(</span><span class="n">not</span> <span class="o">$</span> <span class="n">null</span> <span class="n">numberString</span><span class="p">)</span> <span class="o">$</span> <span class="kr">do</span>
        <span class="kr">let</span> <span class="n">number</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="kr">if</span> <span class="n">randNumber</span> <span class="o">==</span> <span class="n">number</span>
            <span class="kr">then</span> <span class="n">putStrLn</span> <span class="s">&quot;You are correct!&quot;</span>
            <span class="kr">else</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Sorry, it was &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">randNumber</span>
        <span class="n">newStdGen</span>
        <span class="n">main</span>
</pre></div>
</div>
<p>Es muy similar a la versión anterior, solo que en lugar de hacer una función
que tome un generador y luego se llame a si misma de forma recursiva, hacemos
todo el trabajo en <tt class="docutils literal"><span class="pre">main</span></tt>. Después de decir al usuario si el número que
pensaba es correcto o no, actualizamos el generador global y volvemos a llamar
a <tt class="docutils literal"><span class="pre">main</span></tt>. Ambas implementaciones son válidas pero a mi me gusta más la
primera ya que el <tt class="docutils literal"><span class="pre">main</span></tt> realiza menos acciones y también nos proporciona
una función que podemos reutilizar.</p>
</div>
<div class="section" id="cadenas-de-bytes">
<h2>Cadenas de bytes<a class="headerlink" href="#cadenas-de-bytes" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="Como un cadena normal, solo que muerde..." class="align-right" src="../_images/chainchomp.png" />
<p>Las listas son unas estructuras de datos estupendas además útiles. Hasta ahora
las hemos utilizado en cualquier sitio. Hay una multitud de funciones que
operan con ellas y la evaluación perezosa de Haskell nos permite
intercambiarlas por los bucles a la hora de realizar filtrados y trazados, ya
que la evaluación solo ocurre cuando realmente se necesita, de modo que las
listas infinitas (¡incluso listas infinitas de listas infinitas!) no son un
problema para nosotros. Por este motivo las listas también se pueden utilizar
para representar flujos de datos, ya sea para leer desde la entrada estándar
o desde un fichero. Podemos abrir un fichero y leerlo como si se tratase de
una cadena, incluso aunque solo se acceda hasta donde alcancen nuestras
necesidades.</p>
<p>Sin embargo, procesar ficheros como cadenas tiene un inconveniente: suele ser
lento. Como sabes, <tt class="docutils literal"><span class="pre">String</span></tt> es sinónimo de tipo de <tt class="docutils literal"><span class="pre">[Char]</span></tt>. <tt class="docutils literal"><span class="pre">Char</span></tt> no
tiene un tamaño fijo, ya que puede tomar varios bytes para representar un
carácter. Ademas, las listas son perezosas. Si tienes un lista como
<tt class="docutils literal"><span class="pre">[1,2,3,4]</span></tt>, se evaluará solo cuando sea completamente necesario. Así que
la lista entera es una especie de promesa de que en algún momento será una
lista. Recuerda que <tt class="docutils literal"><span class="pre">[1,2,3,4]</span></tt> es simplemente una decoración sintáctica
para <tt class="docutils literal"><span class="pre">1:2:3:4:[]</span></tt>. Cuando el primer elemento de la lista es forzado a
evaluarse (digamos que mostrándolo por pantalla), el resto de la lista
<tt class="docutils literal"><span class="pre">2:3:4:[]</span></tt> sigue siendo una promesa de una lista, y así continuamente. Así
que puedes pensar en las listas como si se tratasen de promesas de que el
el siguiente elemento será entregado una vez sea necesario. No hace falta
pensar mucho para concluir que procesar una simple lista de números como
una serie de promesas no de debe ser la cosa más eficiente del mundo.</p>
<p>Esta sobrecarga no nos suele preocupar la mayor parte del tiempo, pero si
debería hacerlo al la hora de leer y manipular ficheros de gran tamaño. Por
esta razón Haskell posee <strong>cadenas de bytes</strong>. Las cadenas de bytes son una
especie de listas, solo que cada elemento tiene el tamaño de un byte (o 8
bits). La forma en la que son evaluadas es también diferente.</p>
<p>Existen dos tipos de cadenas de bytes: las estrictas y las perezosas. Las
estrictas residen en <tt class="docutils literal"><span class="pre">Data.ByteString</span></tt> y no posee ninguna evaluación
perezosa. No hay ninguna promesa involucrada, un cadena de bytes estricta
representa una serie de bytes en un vector. No podemos crear cosas como
cadenas de bytes infinitas. Si evaluamos el primer byte de un cadena de bytes
estricta evaluamos toda la cadena. La ventaja es que hay menos sobrecarga ya
que no implica ningún <em>thunk</em> (término técnico de <em>promesa</em>). La desventaja es
que consumirán memoria mucho más rápido ya que se leen en memoria de un solo
golpe.</p>
<p>El otro tipo de cadenas de bytes reside en <tt class="docutils literal"><span class="pre">Data.ByteString.Lazy</span></tt>. Son
perezosas, pero no de la misma forma que las listas. Como ya hemos dicho, hay
tantos <em>thunks</em> como elementos en una cadena normal. Este es el porqué de que
sean lentas en algunas situaciones. Las cadenas de bytes perezosas toman otra
enfoque, se almacenan en bloques de 64KB de tamaño. De esta forma, si
evaluamos un byte en una cadena de bytes perezosa (mostrándolo por pantalla o
algo parecido), los primeros 64KB serán evaluados. Luego de estos, solo existe
una promesa de que los siguientes serán evaluados. Las cadenas de bytes
perezosas son como una especie de lista de cadenas de bytes de 64KB. Cuando
procesemos ficheros utilizando cadenas de bytes perezosas, los contenidos del
fichero serán leídos bloque a bloque. Es genial ya que no llevará la memoria
hasta sus límite y probablemente 64KB caben perfectamente en la memoria
cache L2 de tu procesador.</p>
<p>Si miras la <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html">Documentación</a>
de <tt class="docutils literal"><span class="pre">Data.ByteString.Lazy</span></tt>, verás que exporta un montón de funciones que
tienen el mismo nombre que las de <tt class="docutils literal"><span class="pre">Data.List</span></tt>, solo que en sus declaraciones
de tipo tienen <tt class="docutils literal"><span class="pre">ByteString</span></tt> en lugar de <tt class="docutils literal"><span class="pre">[a]</span></tt> y <tt class="docutils literal"><span class="pre">Word8</span></tt> de la <tt class="docutils literal"><span class="pre">a</span></tt> de
su interior. Las funciones con nombres similares se comportan prácticamente
igual salvo que unas trabajan con listas y las otras con cadenas de bytes.
Como importan nombres de funciones iguales, vamos a importarlas de forma
cualificada en nuestro código y luego lo cargaremos en GHCi para jugar con
con las cadenas de bytes.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">B</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">S</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">B</span></tt> posee las cadenas de bytes perezosas mientras que <tt class="docutils literal"><span class="pre">S</span></tt> contiene las
estrictas. Utilizaremos casi siempre la versión perezosa.</p>
<p>La función <tt class="xref cpp cpp-member docutils literal"><span class="pre">pack</span></tt> tiene un tipo <tt class="docutils literal"><span class="pre">[Word8]</span> <span class="pre">-&gt;</span> <span class="pre">ByteString</span></tt>. Lo cual
significa que toma una lista de bytes del tipo <tt class="docutils literal"><span class="pre">Word8</span></tt> y devuelve una
<tt class="docutils literal"><span class="pre">ByteString</span></tt>.  Puedes verlo como si tomara un lista, que es perezosa, y la
hace menos perezosa, de forma que sigue siendo perezosa solo que a intervalos
de 64KB.</p>
<p>¿Qué sucede con el tipo <tt class="docutils literal"><span class="pre">Word8</span></tt>? Bueno, es como <tt class="docutils literal"><span class="pre">Int</span></tt>, solo que tiene un
rango mucho más pequeño, de 0 a 255. Representa un número de 8b. Y al igual
que <tt class="docutils literal"><span class="pre">Int</span></tt>, es miembro de la clase <tt class="docutils literal"><span class="pre">Num</span></tt>. Por ejemplo, sabemos que el
valor 5 es polimórfico ya que puede comportarse como cualquier tipo numeral.
Bueno, pues también puede tomar el tipo <tt class="docutils literal"><span class="pre">Word8</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; B.pack [99,97,110]</span>
<span class="go">Chunk &quot;can&quot; Empty</span>
<span class="go">ghci&gt; B.pack [98..120]</span>
<span class="go">Chunk &quot;bcdefghijklmnopqrstuvwx&quot; Empty</span>
</pre></div>
</div>
<p>Como puede ver, normalmente no tienes que preocupar mucho del tipo <tt class="docutils literal"><span class="pre">Word8</span></tt>,
ya que el sistema de tipos puede hacer que los números tomen ese tipo. Si
tratas de utilizar un número muy grande, como 336, como un <tt class="docutils literal"><span class="pre">Word8</span></tt>,
simplemente se truncará de forma binaria al valor 80.</p>
<p>Hemos empaquetado solo unos pocos valores dentro de una cadena de bytes, de
forma que caben dentro de un mismo bloque (<tt class="docutils literal"><span class="pre">Chunk</span></tt>). El <tt class="docutils literal"><span class="pre">Empty</span></tt> es como
<tt class="docutils literal"><span class="pre">[]</span></tt> para las listas.</p>
<p><tt class="xref cpp cpp-member docutils literal"><span class="pre">unpack</span></tt> es la versión inversa de de <tt class="docutils literal"><span class="pre">pack</span></tt>. Toma una cadena de bytes y
la convierte en una lista de bytes.</p>
<p><tt class="xref cpp cpp-member docutils literal"><span class="pre">fromChunks</span></tt> toma una lista de cadenas de bytes estrictas y la convierte
en una cadena de bytes perezosa. <tt class="xref cpp cpp-member docutils literal"><span class="pre">toChunks</span></tt> toma una cadena de bytes
perezosa y la convierte en una estricta.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]</span>
<span class="go">Chunk &quot;()*&quot; (Chunk &quot;+,-&quot; (Chunk &quot;./0&quot; Empty))</span>
</pre></div>
</div>
<p>Esto es útil cuando tienes un montón de cadenas de bytes estrictas y quieres
procesarlas eficientemente sin tener que unirlas en memoria en una más grande
primero.</p>
<p>La versión de <tt class="docutils literal"><span class="pre">:</span></tt> para cadenas de bytes se conoce como <tt class="xref cpp cpp-member docutils literal"><span class="pre">cons</span></tt>. Toma un
byte y una cadena de bytes y pone dicho byte al principio. Aunque es perezosa,
generará un nuevo bloque para ese elemento aunque dicho bloque aún no este
lleno. Por este motivo es mejor utilizar la versión estricta de <tt class="docutils literal"><span class="pre">cons</span></tt>,
<tt class="xref cpp cpp-member docutils literal"><span class="pre">cons'</span></tt>, si vas a insertar un montón de bytes al principio de una cadena
de bytes.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; B.cons 85 $ B.pack [80,81,82,84]</span>
<span class="go">Chunk &quot;U&quot; (Chunk &quot;PQRT&quot; Empty)</span>
<span class="go">ghci&gt; B.cons&#39; 85 $ B.pack [80,81,82,84]</span>
<span class="go">Chunk &quot;UPQRT&quot; Empty</span>
<span class="go">ghci&gt; foldr B.cons B.empty [50..60]</span>
<span class="go">Chunk &quot;2&quot; (Chunk &quot;3&quot; (Chunk &quot;4&quot; (Chunk &quot;5&quot; (Chunk &quot;6&quot; (Chunk &quot;7&quot; (Chunk &quot;8&quot; (Chunk &quot;9&quot; (Chunk &quot;:&quot; (Chunk &quot;;&quot; (Chunk &quot;&lt;&quot; Empty))))))))))</span>
<span class="go">ghci&gt; foldr B.cons&#39; B.empty [50..60]</span>
<span class="go">Chunk &quot;23456789:;&lt;&quot; Empty</span>
</pre></div>
</div>
<p>Como puedes ver <tt class="xref cpp cpp-member docutils literal"><span class="pre">empty</span></tt> crea una cadena de bytes vacía ¿Puedes ver las
diferencias entre <tt class="docutils literal"><span class="pre">cons</span></tt> y <tt class="docutils literal"><span class="pre">cons'</span></tt>? Con ayuda de <tt class="docutils literal"><span class="pre">foldr</span></tt> hemos empezado
con una cadena de bytes vacía y luego hemos recorrido la lista de números
desde la derecha, añadiendo cada número al principio de la cadena de bytes.
Cuando utilizamos <tt class="docutils literal"><span class="pre">cons</span></tt>, acabamos con un bloque por cada byte, lo cual no
es muy útil para nuestros propósitos.</p>
<p>De cualquier modo, los módulo de cadenas de bytes tienen un montón de
funciones análogas a las de <tt class="docutils literal"><span class="pre">Data.List</span></tt>, incluyendo, pero no limitándose, a
<tt class="docutils literal"><span class="pre">head</span></tt>, <tt class="docutils literal"><span class="pre">tail</span></tt>, <tt class="docutils literal"><span class="pre">init</span></tt>, <tt class="docutils literal"><span class="pre">null</span></tt>, <tt class="docutils literal"><span class="pre">length</span></tt>, <tt class="docutils literal"><span class="pre">map</span></tt>, <tt class="docutils literal"><span class="pre">reverse</span></tt>,
<tt class="docutils literal"><span class="pre">foldl</span></tt>, <tt class="docutils literal"><span class="pre">foldr</span></tt>, <tt class="docutils literal"><span class="pre">concat</span></tt>, <tt class="docutils literal"><span class="pre">takeWhile</span></tt>, <tt class="docutils literal"><span class="pre">filter</span></tt>, etc.</p>
<p>También contienen funciones con el mismo nombre y comportamiento que algunas
funciones que se encuentran en <tt class="docutils literal"><span class="pre">System.IO</span></tt>, solo que <tt class="docutils literal"><span class="pre">String</span></tt> se remplaza
por <tt class="docutils literal"><span class="pre">ByteString</span></tt>. Por ejemplo, la función <tt class="docutils literal"><span class="pre">readFile</span></tt> de <tt class="docutils literal"><span class="pre">System.IO</span></tt>
tiene el tipo <tt class="docutils literal"><span class="pre">readFile</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></tt>, mientras que
<tt class="xref cpp cpp-member docutils literal"><span class="pre">readFile</span></tt> de los módulos de cadenas de bytes tiene el tipo
<tt class="docutils literal"><span class="pre">readFile</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">ByteString</span></tt>. Ten cuidado, si estás utilizando la
versión estricta de cadenas de bytes e intentas leer un fichero, se leerá en
memoria de un solo golpe. Con las cadenas de bytes perezosas se leerá bloque
a bloque.</p>
<p>Vamos a crear un programa simple que tome dos rutas de ficheros como
parámetros de la línea de comandos y copie el contenido del primero en el
segundo. Ten en cuenta que <tt class="docutils literal"><span class="pre">System.Directory</span></tt> ya contiene una función
llamada <tt class="docutils literal"><span class="pre">copyFile</span></tt>, pero vamos a implementar nuestro programa así de todas
formas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">B</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">(</span><span class="n">fileName1</span><span class="kt">:</span><span class="n">fileName2</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">copyFile</span> <span class="n">fileName1</span> <span class="n">fileName2</span>

<span class="nf">copyFile</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">copyFile</span> <span class="n">source</span> <span class="n">dest</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="kt">B</span><span class="o">.</span><span class="n">readFile</span> <span class="n">source</span>
    <span class="kt">B</span><span class="o">.</span><span class="n">writeFile</span> <span class="n">dest</span> <span class="n">contents</span>
</pre></div>
</div>
<p>Creamos nuestra propia función que toma dos <tt class="docutils literal"><span class="pre">FilePath</span></tt> (recuerda,
<tt class="docutils literal"><span class="pre">FilePath</span></tt> es solo un sinónimo de <tt class="docutils literal"><span class="pre">String</span></tt>) y devuelve una acción de E/S
que copiará el contenido de un fichero utilizando cadenas de bytes. En la
función <tt class="docutils literal"><span class="pre">main</span></tt>, simplemente obtenemos los parámetros y llamamos a nuestra
función con ellos para obtener una acción de E/S que será ejecutada.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell bytestringcopy.hs something.txt ../../something.txt
</pre></div>
</div>
<p>Fíjate que un programa que no utilice cadenas de bytes puede tener el mismo
parecido, la única diferencia sería que en lugar de escribir <tt class="docutils literal"><span class="pre">B.readFile</span></tt> y
<tt class="docutils literal"><span class="pre">B.writeFile</span></tt> usaríamos <tt class="docutils literal"><span class="pre">readFile</span></tt> y <tt class="docutils literal"><span class="pre">writeFile</span></tt>. Muchas veces podemos
convertir un programa que utilice cadenas a un programa que utilice cadenas
de bytes simplemente utilizando los módulos correctos y cualificando algunas
funciones. A veces, pueden necesitar convertir funciones que trabajan con
cadenas para que funcionen con cadenas de bytes, pero no es demasiado difícil.</p>
<p>Siempre que necesites un mayor rendimiento en programas que lean montones
de datos en forma de cadenas, intenta utilizar cadenas de bytes, tendrás
grandes posibilidades de conseguir un rendimiento mayor con muy poco esfuerzo.
Normalmente yo suelo crear programas que trabajan con cadenas normales y luego
las convierto a cadenas de bytes de el rendimiento no se ajusta a los
objetivos.</p>
</div>
<div class="section" id="excepciones">
<h2>Excepciones<a class="headerlink" href="#excepciones" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="¡Árbol va!" class="align-left" src="../_images/timber.png" />
<p>Todos los lenguajes tienen procedimientos, funciones o trozos de código que
fallan de alguna forma. Es una ley de vida. Lenguajes diferentes tienen
formas diferentes de manejar estos fallos. En <em>C</em>, solemos utilizar un valor
de retorno anormal (como -1 o un puntero nulo) para indicar que el valor
devuelto no debe ser tratado de forma normal. <em>Java</em> y <em>C#</em>, por otra parte,
tienden a utilizar excepciones para controlar estos fallos. Cuando se lanza
una excepción, la ejecución de código salta a algún lugar que hemos definido
para realice las tareas apropiadas e incluso quizá relance la excepción para
que sea tratada en otro lugar.</p>
<p>Haskell tiene un buen sistema de tipos. Los tipos de datos algebraicos nos
permiten tener tipos como <tt class="docutils literal"><span class="pre">Maybe</span></tt> y <tt class="docutils literal"><span class="pre">Either</span></tt> que podemos utilizar para
representar resultados que son válidos y que no lo son. En <em>C</em>, devolver,
digamos -1, cuando suceda un error es una cuestión de convención. Solo tiene
un significado especial para los humanos. Si no tenemos cuidado, podemos
tratar esos datos anormales como válidos de forma que nuestro código termine
siendo un auténtico desastre. El sistema de tipos de Haskell nos da la
seguridad que necesitamos en este aspecto. Una función <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></tt>
indica claramente que puede producir un <tt class="docutils literal"><span class="pre">b</span></tt> envuelto por un <tt class="docutils literal"><span class="pre">Just</span></tt> o bien
puede devolver <tt class="docutils literal"><span class="pre">Nothing</span></tt>. El tipo es completamente diferente a <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt> y
si intentamos utilizar estas dos funciones indistintamente, el sistema de
tipos se quejará.</p>
<p>Aunque aún teniendo tipos expresivos que soporten operaciones erróneas,
Haskell sigue teniendo soporte para excepciones, ya tienen más sentido en
el contexto de la E/S. Un montón de cosas pueden salir mal cuando estamos
tratando con el mundo exterior ya que no es muy fiable. Por ejemplo, cuando
abrimos un fichero, bastantes cosas pueden salir mal. El fichero puede estar
protegido, puede no existir o incluso que no exista un soporte físico para él.
Así que está bien poder saltar a algún lugar de nuestro código que se encargue
de un error cuando dicho error suceda.</p>
<p>Vale, así que el código de E/S (es decir, código impuro) puede lanzar
excepciones. Tiene sentido ¿Pero qué sucede con el código puro? Bueno, también
puede lanzar excepciones. Piensa en las funciones <tt class="docutils literal"><span class="pre">div</span></tt> y <tt class="docutils literal"><span class="pre">head</span></tt>. Tienen
los tipos <tt class="docutils literal"><span class="pre">(Integral</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span></tt> y <tt class="docutils literal"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">a</span></tt> respectivamente. No
hay ningún <tt class="docutils literal"><span class="pre">Maybe</span></tt> ni <tt class="docutils literal"><span class="pre">Either</span></tt> en el tipo que devuelven pero aun así
pueden fallar. <tt class="docutils literal"><span class="pre">div</span></tt> puede fallar si intentas dividir algo por cero y
<tt class="docutils literal"><span class="pre">head</span></tt> cuando le das una lista vacía.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; 4 `div` 0</span>
<span class="go">*** Exception: divide by zero</span>
<span class="go">ghci&gt; head []</span>
<span class="go">*** Exception: Prelude.head: empty list</span>
</pre></div>
</div>
<img alt="¡Alto ahí cirminal!" class="align-left" src="../_images/police.png" />
<p>El código puro puede lanzar excepciones, pero solo pueden ser capturadas en
las partes de E/S de nuestro código (cuando estamos dentro de un bloque <tt class="docutils literal"><span class="pre">do</span></tt>
que es alcanzado por <tt class="docutils literal"><span class="pre">main</span></tt>). Esto ocurre así porque no sabemos cuando (o
si) algo será evaluado en el código puro ya que se evalúa de forma perezosa y
no tiene definido un orden de ejecución concreto, mientras que las partes de
E/S sí lo tienen.</p>
<p>Antes hablábamos de como debíamos permanecer el menor tiempo posible en las
partes de E/S de nuestro programa. La lógica de nuestro programa debe
permanecer mayoritariamente en nuestras funciones puras, ya que sus resultados
solo dependen de los parámetros con que las llamemos. Cuando tratas con
funciones puras, solo tenemos que preocuparnos de que devuelve una función, ya
que no puede hacer otra cosa. Esto hace nuestra vida más sencilla. Aunque
realizar algunas tareas en la parte E/S es fundamental (como abrir un fichero
y cosas así), deben permanecer al mínimo. Las funciones puras son perezosas
por defecto, lo que significa que no sabemos cuando serán evaluadas y
realmente tampoco nos debe preocupar. Sin embargo, cuando las funciones puras
empiezan a lanzar excepciones, si importa cuando son evaluadas. Por este
motivo solo podemos capturar excepciones lanzadas desde código puro en las
partes de E/S de nuestro programa. Y como queremos mantener las partes de E/S
al mínimo esto no nos beneficia mucho. Sin embargo, si no las capturamos en
una parte de E/S de nuestro código, el programa se abortará ¿Solución? No
mezcles las excepciones con código puro. Toma ventaja del potente sistema de
tipos de Haskell y utiliza tipos como <tt class="docutils literal"><span class="pre">Either</span></tt> y <tt class="docutils literal"><span class="pre">Maybe</span></tt> para representar
resultados que pueden ser erróneos.</p>
<p>Por este motivo, por ahora solo veremos como utilizar las excepciones de E/S.
Las excepciones de E/S ocurren cuando algo va mal a la hora de comunicamos con
el mundo exterior. Por ejemplo, podemos tratar de abrir un fichero y luego
puede ocurrir que ese fichero ha sido eliminado o algo parecido. Fíjate en el
siguiente programa, el cual abre un fichero que ha sido obtenido como
parámetro  y nos dice cuantas líneas contiene.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="n">fileName</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
          <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>
</pre></div>
</div>
<p>Un programa muy simple. Realizamos la acción de E/S <tt class="docutils literal"><span class="pre">getArgs</span></tt> y ligamos la
primera cadena de la cadena que nos devuelve a <tt class="docutils literal"><span class="pre">fileName</span></tt>. Luego llamamos a
los contenidos de fichero como <tt class="docutils literal"><span class="pre">contents</span></tt>. Para terminar, aplicamos
<tt class="docutils literal"><span class="pre">lines</span></tt> a esos contenidos para obtener una lista de lineas y luego obtenemos
la longitud de esa lista y la mostramos utilizando <tt class="docutils literal"><span class="pre">show</span></tt>. Funciona de la
forma esperada, pero ¿Qué sucede cuando le damos el nombre de un fichero que
no existe?</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell linecount.hs i_dont_exist.txt
<span class="go">linecount.hs: i_dont_exist.txt: openFile: does not exist (No such file or directory)</span>
</pre></div>
</div>
<p>¡Ajá! Obtenemos un error de <em>GHC</em> que nos dice que ese fichero no existe.
Nuestro programa falla ¿Qué pasaría si quisiéramos mostrar un mensaje más
agradable en caso de que el fichero no exista? Una forma de hacerlo sería
comprobando si el fichero existe antes de intentar abrirlo utilizando la
función <tt class="xref cpp cpp-member docutils literal"><span class="pre">doesFileExist</span></tt> de <tt class="docutils literal"><span class="pre">System.Directory</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.Directory</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="n">fileName</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
          <span class="n">fileExists</span> <span class="ow">&lt;-</span> <span class="n">doesFileExist</span> <span class="n">fileName</span>
          <span class="kr">if</span> <span class="n">fileExists</span>
              <span class="kr">then</span> <span class="kr">do</span> <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
                      <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>
              <span class="kr">else</span> <span class="kr">do</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
</pre></div>
</div>
<p>Hicimos <tt class="docutils literal"><span class="pre">fileExists</span> <span class="pre">&lt;-</span> <span class="pre">doesFileExist</span> <span class="pre">fileName</span></tt> porque <tt class="docutils literal"><span class="pre">doesFileExist</span></tt>
tiene como declaración de tipo <tt class="docutils literal"><span class="pre">doesFileExist</span> <span class="pre">::</span> <span class="pre">FilePath</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">Bool</span></tt>, lo
que significa que devuelve una acción de E/S que tiene como resultado un valor
booleano que nos dice si el fichero existe o no. No podemos utilizar
<tt class="docutils literal"><span class="pre">doesFileExist</span></tt> directamente en una expresión <tt class="docutils literal"><span class="pre">if</span></tt>.</p>
<p>Otra solución sería utilizando excepciones. Es perfectamente aceptable
utilizarlas en este contexto. Un fichero que no existe es una excepción que
se lanza desde la E/S, así que capturarla en la E/S es totalmente aceptable.</p>
<p>Para tratar con esto utilizando excepciones, vamos a aprovecharnos de la
función <tt class="xref cpp cpp-member docutils literal"><span class="pre">catch</span></tt> de <tt class="docutils literal"><span class="pre">System.IO.Error</span></tt>. Su declaración de tipo es
<tt class="docutils literal"><span class="pre">catch</span> <span class="pre">::</span> <span class="pre">IO</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(IOError</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a)</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">a</span></tt>. Toma dos parámetros. El
primero es una acción de E/S. Por ejemplo, podría ser una acción que trate de
abrir un fichero. El segundo es lo que llamamos un manipulador. Si la primera
acción de E/S que le pasemos a <tt class="docutils literal"><span class="pre">catch</span></tt> lanza un excepción, la excepción pasa
al manipulador que decide que hacer. Así que el resultado final será una
acción que o bien actuará como su primer parámetro o bien hará lo que diga el
manipulador en caso de que la primera acción de E/S lance una excepción.</p>
<img alt="Cachorrito" class="align-right" src="../_images/puppy.png" />
<p>Si te es familiar los bloques <em>try-catch</em> de lenguajes como <em>Java</em> o <em>Python</em>,
la función <tt class="docutils literal"><span class="pre">catch</span></tt> es similar a ellos. El primer parámetro es lo que hay que
intentar hacer, algo así como lo que hay dentro de un bloque <em>try</em>. El segundo
parámetro es el manipulador que toma una excepción, de la misma forma que la
mayoría de los bloques <em>catch</em> toman excepciones que puedes examinar para ver
que ha ocurrido. El manipulador es invocado si se lanza una excepción.</p>
<p>El manipulador toma un valor del tipo <tt class="docutils literal"><span class="pre">IOError</span></tt>, el cual es un valor que
representa que ha ocurrido una excepción de E/S. También contienen información
acerca de la excepción que ha sido lanzada. La implementación de este tipo
depende de la implementación del propio lenguaje, por lo que no podemos
inspeccionar valores del tipo <tt class="docutils literal"><span class="pre">IOError</span></tt> utilizando el ajuste de patrones
sobre ellos, de la misma forma que no podemos utilizar el ajuste de patrones
con valores del tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">algo</span></tt>. Sin embargo, podemos utilizar un montón de
predicados útiles para examinar los valores del tipo <tt class="docutils literal"><span class="pre">IOError</span></tt> como veremos
en unos segundos.</p>
<p>Así que vamos a poner en uso a nuestro nuevo amigo <tt class="docutils literal"><span class="pre">catch</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.IO.Error</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">toTry</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="n">handler</span>

<span class="nf">toTry</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">toTry</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="n">fileName</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="nf">handler</span> <span class="ow">::</span> <span class="kt">IOError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Whoops, had some trouble!&quot;</span>
</pre></div>
</div>
<p>Lo primero de todo, puedes ver como hemos utilizado las comillas simples para
utilizar esta función de forma infija, ya que toma dos parámetros. Utilizarla
de forma infija la hace mas legible. Así que <tt class="docutils literal"><span class="pre">toTry</span> <span class="pre">`catch`</span> <span class="pre">handler</span></tt> es lo
mismo que <tt class="docutils literal"><span class="pre">catch</span> <span class="pre">toTry</span> <span class="pre">handler</span></tt>, además concuerda con su tipo. <tt class="docutils literal"><span class="pre">toTry</span></tt> es
una acción de E/S que intentaremos ejecutar y <tt class="docutils literal"><span class="pre">handler</span></tt> es la función que
toma un <tt class="docutils literal"><span class="pre">IOError</span></tt> y devuelve una acción que será ejecutada en caso de que
suceda una excepción.</p>
<p>Vamos a probarlo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> runhaskell count_lines.hs i_exist.txt
<span class="go">The file has 3 lines!</span>

<span class="gp">$</span> runhaskell count_lines.hs i_dont_exist.txt
<span class="go">Whoops, had some trouble!</span>
</pre></div>
</div>
<p>No hemos comprobado que tipo de <tt class="docutils literal"><span class="pre">IOError</span></tt> obtenemos dentro de <tt class="docutils literal"><span class="pre">handler</span></tt>.
Simplemente decimos <tt class="docutils literal"><span class="pre">&quot;Whoops,</span> <span class="pre">had</span> <span class="pre">some</span> <span class="pre">trouble!&quot;</span></tt> para cualquier tipo de
error. Capturar todos los tipos de excepciones un mismo manipulador no es una
buena práctica en Haskell ni en ningún otro lenguaje ¿Qué pasaría si se
lanzara alguna otra excepción que no queremos capturar, como si interrumpimos
el programa o algo parecido? Por esta razón vamos a hacer lo mismo que se
suele hacer en otros lenguajes: comprobaremos que tipo de excepción estamos
capturando. Si la excepción es del tipo que queremos capturar, haremos nuestro
trabajo. Si no, relanzaremos esa misma excepción. Vamos a modificar nuestro
programa para que solo capture las excepciones debidas a que un fichero no
exista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.IO.Error</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">toTry</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="n">handler</span>

<span class="nf">toTry</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">toTry</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="n">fileName</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="nf">handler</span> <span class="ow">::</span> <span class="kt">IOError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div>
</div>
<p>Todo permanece igual excepto el manipulador, el cual hemos modificado para
que capture únicamente un grupo de excepciones de E/S. Hemos utilizado dos
nuevas funciones de <tt class="docutils literal"><span class="pre">System.IO.Error</span></tt>, <tt class="xref cpp cpp-member docutils literal"><span class="pre">isDoesNotExistError</span></tt> y
<tt class="xref cpp cpp-member docutils literal"><span class="pre">ioError</span></tt>. <tt class="docutils literal"><span class="pre">isDoesNotExistError</span></tt> es un predicado sobre <tt class="docutils literal"><span class="pre">IOError</span></tt>, o
lo que es lo mismo, es una función que toma un valor del tipo <tt class="docutils literal"><span class="pre">IOError</span></tt> y
devuelve <tt class="xref docutils literal"><span class="pre">True</span></tt> o <tt class="xref docutils literal"><span class="pre">False</span></tt>, por lo que su declaración de tipo es
<tt class="docutils literal"><span class="pre">isDoesNotExistError</span> <span class="pre">::</span> <span class="pre">IOError</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></tt>. Hemos utilizado esta función con
la excepción que se le pasa al manipulador para ver si el error fue debido a
que no existía un fichero. Utilizamos también la sintaxis de
<a class="reference internal" href="Funciones.html#guardas"><em>guardas</em></a>, aunque podríamos haber utilizado un <tt class="docutils literal"><span class="pre">if</span> <span class="pre">else</span></tt>. En
caso de que la excepción no fuera lanzada debido a que no se encuentre un
fichero, relanzamos la excepción que se le pasó al manipulador utilizando la
función <tt class="docutils literal"><span class="pre">ioError</span></tt>. Su declaración de tipo es <tt class="docutils literal"><span class="pre">ioError</span> <span class="pre">::</span> <span class="pre">IOException</span> <span class="pre">-&gt;</span>
<span class="pre">IO</span> <span class="pre">a</span></tt>, así que toma un <tt class="docutils literal"><span class="pre">IOError</span></tt> y produce un acción de E/S que lanza esa
excepción. La acción de E/S tiene el tipo <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></tt> ya que realmente nunca
devolverá un valor.</p>
<p>Resuminedo, si la excepción lanzada dentro de la acción de E/S <tt class="docutils literal"><span class="pre">toTry</span></tt> que
hemos incluido dentro del bloque <tt class="docutils literal"><span class="pre">do</span></tt> no se debe a que no exista un fichero,
<tt class="docutils literal"><span class="pre">toTry</span> <span class="pre">`catch`</span> <span class="pre">handler</span></tt> capturará esa excepción y la volverá a lanzar.</p>
<p>Existen varios predicados que trabajan con <tt class="docutils literal"><span class="pre">IOError</span></tt> que podemos utilizar
junto las guardas, ya que, si una guarda no se evalua a <tt class="xref docutils literal"><span class="pre">True</span></tt>, se seguirá
evaluando la siguiente guarda. Los predicados que trabajan con <tt class="docutils literal"><span class="pre">IOError</span></tt>
son:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isAlreadyExistsError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isDoesNotExistError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isAlreadyInUseError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isFullError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isEOFError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isIllegalOperation</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isPermissionError</span></tt></li>
<li><tt class="xref cpp cpp-member docutils literal"><span class="pre">isUserError</span></tt></li>
</ul>
</div></blockquote>
<p>La moyoría de éstas se explican por si mismas. <tt class="docutils literal"><span class="pre">isUserError</span></tt> se evalua a
<tt class="xref docutils literal"><span class="pre">True</span></tt> cuando utilizamos la función <tt class="xref cpp cpp-member docutils literal"><span class="pre">userError</span></tt> para crear la
excepción, lo cual se utiliza para crear excepciones en nuestro código y
acompañarlas con una cadena. Por ejemplo, puedes utilizar algo como
<tt class="docutils literal"><span class="pre">ioError</span> <span class="pre">$</span> <span class="pre">userError</span> <span class="pre">&quot;remote</span> <span class="pre">computer</span> <span class="pre">unplugged!&quot;</span></tt>, aunque es preferible que
utilices los tipos <tt class="docutils literal"><span class="pre">Either</span></tt> y <tt class="docutils literal"><span class="pre">Maybe</span></tt> para representar posibles fallos en
lugar de lanzar excepciones por ti mismo con <tt class="docutils literal"><span class="pre">userError</span></tt>.</p>
<p>Podríamos tener un manipulador que se pareciera a algo como esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">handler</span> <span class="ow">::</span> <span class="kt">IOError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
    <span class="o">|</span> <span class="n">isFullError</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">freeSomeSpace</span>
    <span class="o">|</span> <span class="n">isIllegalOperation</span> <span class="n">e</span> <span class="ow">=</span> <span class="n">notifyCops</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div>
</div>
<p>Donde <tt class="docutils literal"><span class="pre">notifyCops</span></tt> y <tt class="docutils literal"><span class="pre">freeSomeSpace</span></tt> son acciones de E/S que hemos
definido. Asegurate de relanzar las excepciones que no cumplan tu criterio, de
lo contrario harás que tu programa falle de forma sigilosa cuando no debería.</p>
<p><tt class="docutils literal"><span class="pre">System.IO.Error</span></tt> también exporta algunas funciones que nos permiten
preguntar a estas excepciones por algunos atributos, como qué manipulador
causó el error, o qué ruta de fichero lo provocó. Estas funciones comienzan
por <tt class="docutils literal"><span class="pre">ioe</span></tt> y puedes ver la <a class="reference external" href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">lista completa</a>
en la documentación. Digamos que queremos mostrar la ruta de un fichero que
provocó un error. No podemos mostrar el <tt class="docutils literal"><span class="pre">fileName</span></tt> que obtuvimos de
<tt class="docutils literal"><span class="pre">getArgs</span></tt>, ya que solo un valor del tipo <tt class="docutils literal"><span class="pre">IOError</span></tt> se pasa al manipulador
y manipulador no sabe nada más. Una función depende exclusivamente de los
parámetros con los que fue llamada. Por esta razón podemos utilizar la
función <tt class="xref cpp cpp-member docutils literal"><span class="pre">ioeGetFileName</span></tt>, cuya declaración de tipo es <tt class="docutils literal"><span class="pre">ioeGetFileName</span> <span class="pre">::</span>
<span class="pre">IOError</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">FilePath</span></tt>. Toma un <tt class="docutils literal"><span class="pre">IOError</span></tt> como parámetro y quizá
devuelva un <tt class="docutils literal"><span class="pre">FilePath</span></tt> (que es un sinónimo de <tt class="docutils literal"><span class="pre">String</span></tt>, así que es
prácticamente lo mismo). Básicamente lo que hace es extraer la ruta de un
fichero de un <tt class="docutils literal"><span class="pre">IOError</span></tt>, si puede. Vamos a modificar el programa anterior
para que muestre la ruta del fichero que provocó una posible excepción.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Environment</span>
<span class="kr">import</span> <span class="nn">System.IO</span>
<span class="kr">import</span> <span class="nn">System.IO.Error</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">toTry</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="n">handler</span>

<span class="nf">toTry</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">toTry</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">(</span><span class="n">fileName</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">lines</span> <span class="n">contents</span><span class="p">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="nf">handler</span> <span class="ow">::</span> <span class="kt">IOError</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="ow">=</span>
        <span class="kr">case</span> <span class="n">ioeGetFileName</span> <span class="n">e</span> <span class="kr">of</span> <span class="kt">Just</span> <span class="n">path</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Whoops! File does not exist at: &quot;</span> <span class="o">++</span> <span class="n">path</span>
                                 <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Whoops! File does not exist at unknown location!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div>
</div>
<p>Si la guarda donde se encuentra <tt class="docutils literal"><span class="pre">isDoesNotExistError</span></tt> se evalua a <tt class="xref docutils literal"><span class="pre">True</span></tt>,
utilizamos una expresión <tt class="docutils literal"><span class="pre">case</span></tt> para llamar a <tt class="docutils literal"><span class="pre">ioeGetFileName</span></tt> con <tt class="docutils literal"><span class="pre">e</span></tt>
y aplicamos un ajuste de patrones con el <tt class="docutils literal"><span class="pre">Maybe</span></tt> que devuelve. Normalmente
utilizamos las expresiones <tt class="docutils literal"><span class="pre">case</span></tt> cuando queremos aplicar un ajuste de
patrones sin tener que crear una nueva función.</p>
<p>No tienes porque utilizar un manipulador para capturar todas las excepciones
que ocurran en la parte de E/S de tu programa. Puedes cubrir ciertas partes de
tu código de E/S con <tt class="docutils literal"><span class="pre">catch</span></tt> o puedes cubrir varias de ellas con <tt class="docutils literal"><span class="pre">catch</span></tt>
y utilizar diferentes manipuladores. Algo como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">toTry</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="n">handler1</span>
          <span class="n">thenTryThis</span> <span class="p">`</span><span class="n">catch</span><span class="p">`</span> <span class="n">handler2</span>
          <span class="n">launchRockets</span>
</pre></div>
</div>
<p>Aquí, <tt class="docutils literal"><span class="pre">toTry</span></tt> utiliza <tt class="docutils literal"><span class="pre">handler1</span></tt> como manipulador y <tt class="docutils literal"><span class="pre">thenTryThis</span></tt>
utiliza <tt class="docutils literal"><span class="pre">handler2</span></tt>. <tt class="docutils literal"><span class="pre">launchRockets</span></tt> no es ningún parámetro de nignún
<tt class="docutils literal"><span class="pre">catch</span></tt>, así que cualquier excepción que lanze abortará el programa, a no
ser que <tt class="docutils literal"><span class="pre">launchRockets</span></tt> utilice internamente un <tt class="docutils literal"><span class="pre">catch</span></tt> que gestione sus
propias excepciones. Por supuesto <tt class="docutils literal"><span class="pre">toTry</span></tt>, <tt class="docutils literal"><span class="pre">thenTryThis</span></tt> y
<tt class="docutils literal"><span class="pre">launchRockets</span></tt> son acciones de E/S que han sido unidas con un bloque <tt class="docutils literal"><span class="pre">do</span></tt>
e hipotéticamente definidas en algún lugar. Es similar a los bloques
<em>try-catch</em> que aparecen en otro lenguajes, donde puedes utilizar un solo
bloque <em>try-catch</em> para envolver a todo el programa o puede utilizar un
enfoque más detallado y utilizar bloques diferentes en diferentes partes
del programa.</p>
<p>Ahora ya sabes como tratar las excepciones de la E/S. No hemos visto como
lanzar excepciones desde código puro y trabajar con ellas, porque, como ya
hemos dicho, Haskell ofrece mejores formas de informar de errores sin recurrir
a partes de la E/S. Incluso aun teniendo que trabajar con acciones de la E/S
que puede fallar, prefiero tener tipos como <tt class="docutils literal"><span class="pre">IO</span> <span class="pre">(Either</span> <span class="pre">a</span> <span class="pre">b)</span></tt>, que indiquen
que son acciones de E/S normales solo que su resultado será del tipo
<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">a</span> <span class="pre">b</span></tt>, así que o bien devolverán <tt class="docutils literal"><span class="pre">Left</span> <span class="pre">a</span></tt> o  <tt class="docutils literal"><span class="pre">Right</span> <span class="pre">b</span></tt>.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Problemas.html" title="Resolviendo problemas de forma funcional"
             >siguiente</a></li>
        <li class="right" >
          <a href="ClasesDeTipos.html" title="Creando nuestros propios tipos y clases de tipos"
             >anterior</a> |</li>
        <li><a href="../main.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-21994994-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>