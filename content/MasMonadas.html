
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Unas cuantas mónadas más &mdash; ¡Aprende Haskell por el bien de todos! v0 documentation</title>
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/translations.js"></script>
    <script type="text/javascript" src="../_static/cms.js"></script>    
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="¡Aprende Haskell por el bien de todos! v0 documentation" href="../index.html" />
    <link rel="next" title="Zippers" href="Zippers.html" />
    <link rel="prev" title="Un puñado de mónadas" href="Monadas.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Zippers.html" title="Zippers"
             accesskey="N">siguiente</a></li>
        <li class="right" >
          <a href="Monadas.html" title="Un puñado de mónadas"
             accesskey="P">anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="unas-cuantas-monadas-mas">
<h1>Unas cuantas mónadas más<a class="headerlink" href="#unas-cuantas-monadas-mas" title="Enlazar permanentemente con este título">¶</a></h1>
<img alt="Amigo, existen dos tipos de personas en el mundo: los que aprenden Haskell y lo que trabajan programando en Java." class="align-right" src="../_images/clint.png" />
<p>Hemos visto como podemos utilizar las mónadas para tomar valores con un cierto
contexto y aplicarles funciones utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> o la notación <tt class="docutils literal"><span class="pre">do</span></tt>, lo
cual nos permite centrarnos en los valores en si mientras que el contexto se
trata automáticamente.</p>
<p>Ya hemos conocemos la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt> y hemos visto como añade un contexto de
que existan posibles fallos. Ya hemos aprendido a utilizar la mónada lista y
hemos visto como nos permite introducir un no determinismo en nuestros
programas. También hemos aprendido a trabajar con la mónada <tt class="docutils literal"><span class="pre">IO</span></tt>, ¡incluso
antes de que supiéramos de la existencia de las mónadas!</p>
<p>En este capítulo, vamos a ver una cuantas mónadas más. Veremos como éstas
pueden conseguir que nuestros programas sean más claros permitiéndonos manejar
todo tipo de valores como si fueran monádicos. El hecho de ver unas cuantas
mónadas más también reforzará nuestro conocimiento acerca de ellas.</p>
<p>Todas las mónadas que vamos a ver forman parte del paquete <tt class="docutils literal"><span class="pre">mtl</span></tt>. Un
paquete de Haskell es una colección de módulos. El paquete <tt class="docutils literal"><span class="pre">mtl</span></tt> viene con
la plataforma Haskell así que probablemente ya lo tengas instalado. Para
comprobarlo, ejecuta <tt class="docutils literal"><span class="pre">ghc-pkg</span> <span class="pre">list</span></tt> en la línea de comandos. Así podrás ver
todos los paquetes que tienes instalados y uno de ellos debe ser <tt class="docutils literal"><span class="pre">mtl</span></tt>,
seguido de un número de versión.</p>
<div class="section" id="writer-no-la-conozco">
<h2>¿Writer? No la conozco<a class="headerlink" href="#writer-no-la-conozco" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Hemos cargado una pistola con la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt>, la mónada lista y la mónada
<tt class="docutils literal"><span class="pre">IO</span></tt>. Ahora vamos a hacer sitio en la recámara para la mónada <tt class="docutils literal"><span class="pre">Writer</span></tt> y
ver que pasa cuando la disparamos.</p>
<p>Mientras que <tt class="docutils literal"><span class="pre">Maybe</span></tt> sirve para valores con el contexto adicional de un
posible fallo y las listas son para valores no deterministas, la mónada
<tt class="docutils literal"><span class="pre">Writer</span></tt> sirve para valores que tienen una especie de registres como
contexto. La mónada <tt class="docutils literal"><span class="pre">Writer</span></tt> nos permite realizar cómputos de forma que los
valores del registro se combinan en un solo registro que será adjuntado al
resulto final.</p>
<p>Por ejemplo, podríamos querer equipar algunos valores con unas cadenas que
explicaran lo que esta sucediendo, probablemente para luego depurar el
código. La siguiente función toma el número de bandidos de una banda y nos
dice si es una gran banda o no. Una función muy simple:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">isBigGang</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isBigGang</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span>
</pre></div>
</div>
<p>Ahora, en lugar de que nos devuelva solo <tt class="xref docutils literal"><span class="pre">True</span></tt> o <tt class="xref docutils literal"><span class="pre">False</span></tt>, queremos que
nos devuelve también una cadena de registro que nos indique que ha hecho la
función. Para ello solo tenemos que devolver una cadena junto al valor
<tt class="docutils literal"><span class="pre">Bool</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">isBigGang</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
<span class="nf">isBigGang</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span><span class="p">,</span> <span class="s">&quot;Compared gang size to 9.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Así que ahora en vez de devolver una valor <tt class="docutils literal"><span class="pre">Bool</span></tt>, devuelve una tupla cuyo
primer es el resultado original y el segundo es la cadena que acompaña al
resultado. Ahora este resultado tiene añadido un cierto contexto. Vamos a
probarla:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; isBigGang 3</span>
<span class="go">(False,&quot;Compared gang size to 9.&quot;)</span>
<span class="go">ghci&gt; isBigGang 30</span>
<span class="go">(True,&quot;Compared gang size to 9.&quot;)</span>
</pre></div>
</div>
<img alt="Cuando vayas al retrete, haz tus necesidades, no hables." class="align-left" src="../_images/tuco.png" />
<p>Hasta aquí todo bien. <tt class="docutils literal"><span class="pre">isBigGang</span></tt> toma un valor normal y devuelve un valor
con un determinado contexto. Como ya sabemos, pasar a esta función un valor
normal no causa ningún problema. Pero, ¿y si ya tenemos un valor que tiene
adjuntado una cadena, como por ejemplo <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">&quot;Smallish</span> <span class="pre">gang.&quot;)</span></tt>, y queremos
pasarlo a <tt class="docutils literal"><span class="pre">isBigGang</span></tt>? Parece que una vez más nos topamos con la misma
pregunta: si tenemos una función que toma un valor normal y devuelve un valor
con un cierto contexto, ¿cómo extraemos el valor de ese contexto y se lo
pasamos a la función?</p>
<p>Cuando estábamos explorando la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt> creamos la función
<tt class="docutils literal"><span class="pre">applyMaybe</span></tt>, la cual tomaba un valor de tipo <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> y una función del
tipo <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></tt> y pasa ese valor <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt> a la función, incluso
aunque la función toma una valor del tipo <tt class="docutils literal"><span class="pre">a</span></tt> y no <tt class="docutils literal"><span class="pre">Maybe</span> <span class="pre">a</span></tt>. Conseguíamos
hacer esto teniendo en cuenta el contexto de los valores <tt class="docutils literal"><span class="pre">Maybe</span></tt>, el cual
era el de los valores con un posible fallo. Dentro de la función
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">b</span></tt> éramos capaces de tratar ese valor con absoluta normalidad,
ya que <tt class="docutils literal"><span class="pre">applyMaybe</span></tt> (que luego vino a ser <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>) se encargaba de
comprobar si el valor era <tt class="docutils literal"><span class="pre">Nothing</span></tt> o un valor <tt class="docutils literal"><span class="pre">Just</span></tt>.</p>
<p>Del mismo modo, vamos a crear una función que tome un valor con un registro
añadido, como por ejemplo <tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">String)</span></tt>, y una función del tipo
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">(b,</span> <span class="pre">String)</span></tt> a la que pasaremos el valor inicial. La llamaremos
<tt class="docutils literal"><span class="pre">applyLog</span></tt>. Como un valor del tipo <tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">String)</span></tt> no lleva asociado ningún
contexto de un posible fallo, sino únicamente un registro adicional,
<tt class="docutils literal"><span class="pre">applyLog</span></tt> se encargará de que el registro de la variable original no se
pierda concatenándolo con el registro del resultado de la función. Aquí tienes
la implementación de <tt class="docutils literal"><span class="pre">applyLog</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="kt">String</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span>
<span class="nf">applyLog</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">newLog</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">log</span> <span class="o">++</span> <span class="n">newLog</span><span class="p">)</span>
</pre></div>
</div>
<p>Cuando tenemos un valor dentro de un contexto y queremos pasar dicho valor
a una función, normalmente intentamos separar el valor real del contexto,
luego intentamos aplicar la función sobre ese valor y para terminar volvemos
a considerar el contexto. Con la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt>, primero comprobamos si el
valor era del tipo <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">x</span></tt> y si lo era, tomábamos el valor <tt class="docutils literal"><span class="pre">x</span></tt> y lo
aplicábamos a la función. En este caso es fácil encontrar el valor real, ya
que estamos trabajando con una dupla que contiene el valor y un registro.
Primero tomamos el valor, que es <tt class="docutils literal"><span class="pre">x</span></tt> y le aplicamos la función <tt class="docutils literal"><span class="pre">f</span></tt>.
Obtenemos una dupla de <tt class="docutils literal"><span class="pre">(y,</span> <span class="pre">newLog)</span></tt>, donde <tt class="docutils literal"><span class="pre">y</span></tt> es el nuevo resultado y
<tt class="docutils literal"><span class="pre">newLog</span></tt> es el nuevo registro. Sin embargo, si devolviéramos esto como
resultado, el registro antiguo no se incluiría en el resultado, así que
devolvemos una dupla <tt class="docutils literal"><span class="pre">(y,log</span> <span class="pre">++</span> <span class="pre">newLog)</span></tt>. Utilizamos <tt class="docutils literal"><span class="pre">++</span></tt> para concatenar
ambos registros.</p>
<p>Aquí tienes <tt class="docutils literal"><span class="pre">applyLog</span></tt> en acción:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (3, &quot;Smallish gang.&quot;) `applyLog` isBigGang</span>
<span class="go">(False,&quot;Smallish gang.Compared gang size to 9&quot;)</span>
<span class="go">ghci&gt; (30, &quot;A freaking platoon.&quot;) `applyLog` isBigGang</span>
<span class="go">(True,&quot;A freaking platoon.Compared gang size to 9&quot;)</span>
</pre></div>
</div>
<p>El resultado es similar al anterior, solo que el número de bandidos en la
banda va acompañado de un registro. Unos cuantos ejemplos más:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (&quot;Tobin&quot;,&quot;Got outlaw name.&quot;) `applyLog` (\x -&gt; (length x, &quot;Applied length.&quot;))</span>
<span class="go">(5,&quot;Got outlaw name.Applied length.&quot;)</span>
<span class="go">ghci&gt; (&quot;Bathcat&quot;,&quot;Got outlaw name.&quot;) `applyLog` (\x -&gt; (length x, &quot;Applied length&quot;))</span>
<span class="go">(7,&quot;Got outlaw name.Applied length&quot;)</span>
</pre></div>
</div>
<p>Fíjate en el interior de la función lambda, <tt class="docutils literal"><span class="pre">x</span></tt> es un cadena normal y no una
tupla. Además <tt class="docutils literal"><span class="pre">applyLog</span></tt> se encarga de concatenar los registros.</p>
<div class="section" id="monoides-al-rescate">
<h3>Monoides al rescate<a class="headerlink" href="#monoides-al-rescate" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">¡Asegurate de saber lo que son los <a class="reference internal" href="Funtores.html#monoides"><em>monoides</em></a> si
quieres continuar!</p>
</div>
<p>Ahora mismo, <tt class="docutils literal"><span class="pre">applyLog</span></tt> toma valores del tipo <tt class="docutils literal"><span class="pre">(a,String)</span></tt>, pero, ¿existe
alguno motivo especial por el que lo registros deban ser del tipo <tt class="docutils literal"><span class="pre">String</span></tt>?
Utilizamos <tt class="docutils literal"><span class="pre">++</span></tt> para unir los registros, así que, ¿no debería aceptar
cualquier tipo de listas, y no solo listas de caracteres? Pues sí, debería.
Podemos cambiar su tipo a:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,[</span><span class="n">c</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">c</span><span class="p">]))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,[</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<p>Ahora, el registro es una lista. El tipo de valores que contiene la lista debe
ser el mismo tipo de que tienen los elementos de la lista original, a la vez
que deben ser iguales a los que devuelve la función. De otro modo, no
podríamos utilizar <tt class="docutils literal"><span class="pre">++</span></tt> para unirlos.</p>
<p>¿Debería función con cadenas de bytes? No hay ninguna razón para que no
funcionase. Sin embargo, el tipo que hemos utilizado solo acepta listas.
Parece que tendremos que crear una <tt class="docutils literal"><span class="pre">applyLog</span></tt> solo para cadenas de bytes
¡Pero espera! Tanto las listas como los cadenas de bytes son monoides. Como
tal, ambas poseen instancias de la clase de tipos <tt class="docutils literal"><span class="pre">Monoid</span></tt>, lo cual
significa que ambas implementan la función <tt class="docutils literal"><span class="pre">mappend</span></tt>. Y tanto par las listas
como para las cadenas de bytes, <tt class="docutils literal"><span class="pre">mappend</span></tt> sirve para unir. Mira:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [1,2,3] `mappend` [4,5,6]</span>
<span class="go">[1,2,3,4,5,6]</span>
<span class="go">ghci&gt; B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]</span>
<span class="go">Chunk &quot;chi&quot; (Chunk &quot;huahua&quot; Empty)</span>
</pre></div>
</div>
<p>¡Genial! Ahora <tt class="docutils literal"><span class="pre">applyLog</span></tt> pede funcionar con cualquier monoide. Tenemos que
cambiar la declaración de tipo para que lo refleje, y también la
implementación ya que tenemos cambiar <tt class="docutils literal"><span class="pre">++</span></tt> por <tt class="docutils literal"><span class="pre">mappend</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">applyLog</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">m</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">m</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
<span class="nf">applyLog</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">log</span><span class="p">)</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">newLog</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">log</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">newLog</span><span class="p">)</span>
</pre></div>
</div>
<p>Como el valor que acompaña al valor original ahora puede ser cualquier tipo
de monoide, ya no tenemos que porque ver la dupla como una valor y un
registro, sino como una valor y un monoide. Por ejemplo, podemos tener una
tupla que tenga el nombre de un producto y su precio como valor monoidal.
Simplemente tenemos que utilizar el <tt class="docutils literal"><span class="pre">newtype</span></tt> <tt class="docutils literal"><span class="pre">Sum</span></tt> para asegurarnos de
que los precios se suman. Aquí tienes un ejemplo de una función que añade
la bebida para cierto tipo de comida de cowboy:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="kr">type</span> <span class="kt">Food</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Price</span> <span class="ow">=</span> <span class="kt">Sum</span> <span class="kt">Int</span>

<span class="nf">addDrink</span> <span class="ow">::</span> <span class="kt">Food</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Food</span><span class="p">,</span><span class="kt">Price</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="s">&quot;beans&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;milk&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">25</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="s">&quot;jerky&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;whiskey&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">99</span><span class="p">)</span>
<span class="nf">addDrink</span> <span class="kr">_</span> <span class="ow">=</span> <span class="p">(</span><span class="s">&quot;beer&quot;</span><span class="p">,</span> <span class="kt">Sum</span> <span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>Utilizamos cadenas para representar las comidas y un <tt class="docutils literal"><span class="pre">Int</span></tt> dentro de un
<tt class="docutils literal"><span class="pre">newtype</span></tt> <tt class="docutils literal"><span class="pre">Sum</span></tt> para mantener el precio total. Recuerda, cuando utilizamos
<tt class="docutils literal"><span class="pre">mappend</span></tt> con <tt class="docutils literal"><span class="pre">Sum</span></tt> el resultado será la suma de ambos parámetros:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Sum 3 `mappend` Sum 9</span>
<span class="go">Sum {getSum = 12}</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">addDrink</span></tt> es bastante simple. Si estamos comiendo alubias,
devuelve <tt class="docutils literal"><span class="pre">&quot;milk&quot;</span></tt> junto <tt class="docutils literal"><span class="pre">Sum</span> <span class="pre">25</span></tt>, es decir 25 centavos dentro de un
<tt class="docutils literal"><span class="pre">Sum</span></tt>. Si estamos comiendo cecina bebemos whisky y si estamos comiendo
cualquier otra cosa bebemos cerveza. Aplicar esta función a una comida no
sería muy interesante, pero si utilizamos <tt class="docutils literal"><span class="pre">applyLog</span></tt> para pasar una comida
junto a un precio a esta función la cosa se vuelve más interesante:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (&quot;beans&quot;, Sum 10) `applyLog` addDrink</span>
<span class="go">(&quot;milk&quot;,Sum {getSum = 35})</span>
<span class="go">ghci&gt; (&quot;jerky&quot;, Sum 25) `applyLog` addDrink</span>
<span class="go">(&quot;whiskey&quot;,Sum {getSum = 124})</span>
<span class="go">ghci&gt; (&quot;dogmeat&quot;, Sum 5) `applyLog` addDrink</span>
<span class="go">(&quot;beer&quot;,Sum {getSum = 35})</span>
</pre></div>
</div>
<p>La leche cuesta <tt class="docutils literal"><span class="pre">25</span></tt> centavos, pero si comemos alubias que cuestan <tt class="docutils literal"><span class="pre">10</span></tt>
centavos, acabaremos pagando <tt class="docutils literal"><span class="pre">35</span></tt> centavos. Ahora se ve claramente como el
valor que acompañamos no tiene porque ser siempre un registro, puede ser
cualquier tipo de monoide y como se unan ambos valores dependerá de ese
monoide. Cuando utilizamos registros, se concatenan, cuando utilizamos
números, se suman, etc.</p>
<p>Como el valor que devuelve <tt class="docutils literal"><span class="pre">addDrink</span></tt> es una dupla del tipo
<tt class="docutils literal"><span class="pre">(Food,Price)</span></tt>, podemos pasar el resultado a <tt class="docutils literal"><span class="pre">addDrink</span></tt> de nuevo, de forma
que el resultado nos diga que vamos a beber y cuanto nos a costado en total.
Aquí tienes una muestra:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (&quot;dogmeat&quot;, Sum 5) `applyLog` addDrink `applyLog` addDrink</span>
<span class="go">(&quot;beer&quot;,Sum {getSum = 65})</span>
</pre></div>
</div>
<p>Si añadimos una bebida a un poco de carne de perro obtendremos una cerveza
y otros <tt class="docutils literal"><span class="pre">30</span></tt> centavos de más, <tt class="docutils literal"><span class="pre">(&quot;beer&quot;,</span> <span class="pre">Sum</span> <span class="pre">35)</span></tt>. Si utilizamos
<tt class="docutils literal"><span class="pre">applyLog</span></tt> para pasar este último valor a <tt class="docutils literal"><span class="pre">addDrink</span></tt>, obtenemos otra
cerveza y el resultado final será <tt class="docutils literal"><span class="pre">(&quot;beer&quot;,</span> <span class="pre">Sum</span> <span class="pre">35)</span></tt>.</p>
</div>
<div class="section" id="el-tipo-writer">
<h3>El tipo <tt class="docutils literal"><span class="pre">Writer</span></tt><a class="headerlink" href="#el-tipo-writer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que hemos visto que un valor junto a un monoide puede actuar como un
valor monoidal, vamos a explorar la instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> para esos valores.
El módulo <tt class="docutils literal"><span class="pre">Contol.Monad.Writer</span></tt> exporta el tipo <tt class="docutils literal"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">a</span></tt> junto su
instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> y algunas funciones útiles para trabajar con valores de
este tipo.</p>
<p>Primero vamos a explorar el tipo en si mismo. Para adjuntar un monoide a un
valor solo tenemos que ponerlos juntos en una dupla. El tipo <tt class="docutils literal"><span class="pre">Writter</span> <span class="pre">w</span> <span class="pre">a</span></tt>
es solo un <tt class="docutils literal"><span class="pre">newtype</span></tt> de la dupla. Su definición es muy simple:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">Writer</span> <span class="n">w</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">{</span> <span class="n">runWriter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Gracias a que esta definido con <tt class="docutils literal"><span class="pre">newtype</span></tt> podemos crear una instancia de
<tt class="docutils literal"><span class="pre">Monad</span></tt> que se comporte de forma diferente a la instancia de las tuplas
normales. El parámetro de tipo <tt class="docutils literal"><span class="pre">a</span></tt> representa el tipo del valor mientras
que el parámetro de tipo <tt class="docutils literal"><span class="pre">w</span></tt> representa el valor monádico que adjuntamos al
valor.</p>
<p>Su instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> se define así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">w</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Writer</span> <span class="n">w</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mempty</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="kt">Writer</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">v&#39;</span><span class="p">))</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">in</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">v&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="Cuando vayas al retrete, haz tus necesidades, no hables." class="align-right" src="../_images/angeleyes.png" />
<p>Antes de nada vamos a ver <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>. Su implementación es básicamente la misma
que <tt class="docutils literal"><span class="pre">applyLog</span></tt>, solo que ahora la dupla está contenida en el <tt class="docutils literal"><span class="pre">newtype</span></tt>
<tt class="docutils literal"><span class="pre">Writer</span></tt>, así que tenemos que extraerla con ayuda de un patrón. Tomamos el
valor <tt class="docutils literal"><span class="pre">x</span></tt> y le aplicamos la función <tt class="docutils literal"><span class="pre">f</span></tt>. Esto nos da un valor del tipo
<tt class="docutils literal"><span class="pre">Writer</span> <span class="pre">w</span> <span class="pre">a</span></tt> que, con ayuda de una expresión <tt class="docutils literal"><span class="pre">let,</span> <span class="pre">lo</span> <span class="pre">ajustamos</span> <span class="pre">a</span> <span class="pre">un</span>
<span class="pre">patrón.</span> <span class="pre">Llamamos</span> <span class="pre">``y</span></tt> al nuevo resultado y utilizamos <tt class="docutils literal"><span class="pre">mappend</span></tt> para
combinar el monodie antiguo con el nuevo. Juntamos ambos valores en una dupla
, luego dentro del constructor <tt class="docutils literal"><span class="pre">Writer</span></tt> y por fin este será el resultado
final.</p>
<p>¿Qué pasa con <tt class="docutils literal"><span class="pre">return</span></tt>? Tiene que tomar un valor e introducirlo en el
contexto mínimo por defecto que pueda albergar dicho valor como resultado
¿Cúal será ese contexto para los valores del tipo <tt class="docutils literal"><span class="pre">Writer</span></tt>? Tiene sentido
que si queremos que el valor del monoide afecte tan poco como sea posible
utilizar <tt class="docutils literal"><span class="pre">mempty</span></tt>. Utilizamos <tt class="docutils literal"><span class="pre">mempty</span></tt> como identadad para los valores
monoidales, como <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt>, <tt class="docutils literal"><span class="pre">Sum</span> <span class="pre">0</span></tt>, cadenas de bytes vacías, etc. Siempre que
utilicemos <tt class="docutils literal"><span class="pre">mempty</span></tt> junto a <tt class="docutils literal"><span class="pre">mappend</span></tt> y algún otro valor monoidal, el
resultado será el valor monoidal. Así que si utilizamos <tt class="docutils literal"><span class="pre">return</span></tt> para crear
un valor del tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> y luego utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasárselo a una
función, el valor monoidal resultante será igual al que devuelva la función.
Vamos a utitlizar <tt class="docutils literal"><span class="pre">return</span></tt> con el número <tt class="docutils literal"><span class="pre">3</span></tt> unas cuantas veces, pero
cada vez con un monoide distinto:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runWriter (return 3 :: Writer String Int)</span>
<span class="go">(3,&quot;&quot;)</span>
<span class="go">ghci&gt; runWriter (return 3 :: Writer (Sum Int) Int)</span>
<span class="go">(3,Sum {getSum = 0})</span>
<span class="go">ghci&gt; runWriter (return 3 :: Writer (Product Int) Int)</span>
<span class="go">(3,Product {getProduct = 1})</span>
</pre></div>
</div>
<p>Como <tt class="docutils literal"><span class="pre">Writer</span></tt> no tiene una instancia de <tt class="docutils literal"><span class="pre">Show</span></tt>, tenemos que utilizar
<tt class="docutils literal"><span class="pre">runWriter</span></tt> para convertir los valores de <tt class="docutils literal"><span class="pre">Writer</span></tt> en tuplas normales que
puedan ser mostradas. Para <tt class="docutils literal"><span class="pre">String</span></tt>, el valor monoidal es la cadena vacía.
Con <tt class="docutils literal"><span class="pre">Sum</span></tt>, es <tt class="docutils literal"><span class="pre">0</span></tt> porque si sumamos 0 a algo, el resultado será el mismo.
Para <tt class="docutils literal"><span class="pre">Product</span></tt> la identidad es <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>La instancia de <tt class="docutils literal"><span class="pre">Writer</span></tt> no posee ninguna implementación de <tt class="docutils literal"><span class="pre">fail</span></tt>, así
que si un ajuste de patrones falla dentro de un bloque <tt class="docutils literal"><span class="pre">do</span></tt> se llamará a la
función <tt class="docutils literal"><span class="pre">error</span></tt>.</p>
</div>
<div class="section" id="utilizando-la-notacion-do-junto-a-writer">
<h3>Utilizando la notación <tt class="docutils literal"><span class="pre">do</span></tt> junto a <tt class="docutils literal"><span class="pre">Writer</span></tt><a class="headerlink" href="#utilizando-la-notacion-do-junto-a-writer" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que tenemos una instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> podemos utilizar la notación
<tt class="docutils literal"><span class="pre">do</span></tt> con valores <tt class="docutils literal"><span class="pre">Writer</span></tt>. Es útil para cuando tenemos varios valores del
tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> y queremos hacer cosas con ellas. Al igual que la demás
mónadas, podemos tratar estos valores como valores normales dejando que se
ocupen del contexto por nosotros. En este caso, toda los valores monoidales
se unen con <tt class="docutils literal"><span class="pre">mappend</span></tt> y por lo tanto se reflejan en el resultado final. Aquí
tiene un ejemplo de uso de la notación <tt class="docutils literal"><span class="pre">do</span></tt> con <tt class="docutils literal"><span class="pre">Writer</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">logNumber</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">logNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Writer</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;Got number: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">])</span>

<span class="nf">multWithLog</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">multWithLog</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">3</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">5</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">logNumber</span></tt> toma un número y crea un valor <tt class="docutils literal"><span class="pre">Writer</span></tt> a partir de él.
Utilizamos una lista de cadenas como monoide de forma que adjuntamos una
lista unitaria que dice que número hemos utilizado. <tt class="docutils literal"><span class="pre">multWithLog</span></tt> es un
valor del tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> que multiplica un <tt class="docutils literal"><span class="pre">3</span></tt> y un <tt class="docutils literal"><span class="pre">5</span></tt> y se asegura que
los registros de ambos números aparezcan en el resultado final. Utilizamos
<tt class="docutils literal"><span class="pre">resultado</span></tt> para devolver <tt class="docutils literal"><span class="pre">a*b</span></tt> como resultado. Como <tt class="docutils literal"><span class="pre">return</span></tt> toma un
valor y lo introduce en el contexto mínimo por defecto, podemos estar seguros
de que no añadirá nada al registro. Esto es lo que vemos si lo ejecutamos:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runWriter multWithLog</span>
<span class="go">(15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;])</span>
</pre></div>
</div>
<p>A veces solo queremos que cierto valor monoidal sea incluido llegado el
momento. Para ello tenemos la función <tt class="docutils literal"><span class="pre">tell</span></tt> que forma parte de la clase de
tipos <tt class="docutils literal"><span class="pre">MonadWriter</span></tt>. Para la instancia de <tt class="docutils literal"><span class="pre">Writer</span></tt>, toma un valor
monoidal, como <tt class="docutils literal"><span class="pre">[&quot;This</span> <span class="pre">is</span> <span class="pre">going</span> <span class="pre">on&quot;],</span> <span class="pre">y</span> <span class="pre">crea</span> <span class="pre">un</span> <span class="pre">valor</span> <span class="pre">del</span> <span class="pre">tipo</span> <span class="pre">``Writer</span></tt>
con resultado <tt class="docutils literal"><span class="pre">()</span></tt> y como valor monoidal adjunto el valor que le hayamos
pasado. Cuando tenemos un resultado como <tt class="docutils literal"><span class="pre">()</span></tt> no lo ligamos a ninguna
variable. Aquí tienes como se vería <tt class="docutils literal"><span class="pre">multWithLog</span></tt> con un reporte adicional:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">multWithLog</span> <span class="ow">::</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">multWithLog</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">3</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">logNumber</span> <span class="mi">5</span>
    <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Gonna multiply these two&quot;</span><span class="p">]</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Es importante que <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(a*b)</span></tt> esté en la última línea porque la última
línea de una expresión <tt class="docutils literal"><span class="pre">do</span></tt> es el resultado final del bloque entero. Si
hubiésemos puesto <tt class="docutils literal"><span class="pre">tell</span></tt> en la última línea, <tt class="docutils literal"><span class="pre">()</span></tt> hubiera sido el
resultado final de esta expresión <tt class="docutils literal"><span class="pre">do</span></tt>. Hubiéramos perdido el resultado de
la multiplicación, además que el tipo de la expresión hubiera sido
<tt class="docutils literal"><span class="pre">multWithLog</span> <span class="pre">::</span> <span class="pre">Writer</span> <span class="pre">()</span> <span class="pre">Int</span></tt>. Sin embargo, el registro hubira sido el
mismo. Aquí lo tienes en acción:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runWriter multWithLog</span>
<span class="go">(15,[&quot;Got number: 3&quot;,&quot;Got number: 5&quot;,&quot;Gonna multiply these two&quot;])</span>
</pre></div>
</div>
</div>
<div class="section" id="anadiendo-registros-a-los-programas">
<h3>Añadiendo registros a los programas<a class="headerlink" href="#anadiendo-registros-a-los-programas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El algoritmo de Euclides es un algoritmo que toma dos números y calcula su
máximo común divisor. Es decir, el número más grande que puede dividir a
ambos. Haskell ya posee la función <tt class="docutils literal"><span class="pre">gcb</span></tt>, que hace exactamente esto, pero
vamos a implementarla de nuevo para añadirle un registro. Aquí esta el
algoritmo normal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span>    <span class="ow">=</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>El algoritmo es muy sencillo. Primero, comprueba si el segundo número es 0.
Si lo es, entonces el resultado es el primer número. Si no lo es, entonces el
resultado es el máximo común divisor del segundo número y del resto de dividir
el primer número por el segundo. Por ejemplo, si queremos saber el máximo
común divisor de 8 y 3 simplemente tenemos que seguir el algoritmo. Como 3 no
es 0, tenemos que encontrar el máximo común divisor de de 3 y 2 (si dividimos
8 por 3, el resto es 2). Luego, tenemos que encontrar el máximo común divisor
de 3 y 2. 2 aún no es igual 0, así que tenemos 2 y 1. El segundo número aún
no es 0 así que volvemos a aplicar el algoritmo para obtener 1 y 0, ya que
dividir 2 por 1 nos da como resto 0. Finalmente, como el segundo número es 0,
el resultado final es 1. Vamos a ver si Haskell opina lo mismo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; gcd&#39; 8 3</span>
<span class="go">1</span>
</pre></div>
</div>
<p>Lo hace. Ahora, queremos adjuntar un contexto a este resultado, y el contexto
será un valor monoidal a modo de registro. Como antes, utilizaremos una lista
de cadenas como monoide. De este modo, el tipo de la nueva función <tt class="docutils literal"><span class="pre">gcd'</span></tt>
será:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>Todo lo que nos queda por hacer es añadir a la función los valores del
registro. Así será el código:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">]</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)]</span>
        <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Esta función toma dos valores <tt class="docutils literal"><span class="pre">Int</span></tt> normales y devuelve un
<tt class="docutils literal"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Int</span></tt>. Es decir, un <tt class="docutils literal"><span class="pre">Int</span></tt> que contiene un contexto de
registro. En caso de que <tt class="docutils literal"><span class="pre">b</span></tt> sea <tt class="docutils literal"><span class="pre">0</span></tt>, en lugar de únicamente devolver
<tt class="docutils literal"><span class="pre">a</span></tt> como resultado, utilizamos una expresión <tt class="docutils literal"><span class="pre">do</span></tt> para unir un valor del
tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> con el resultado. Primero utilizamos <tt class="docutils literal"><span class="pre">tell</span></tt> para indicar
que hemos terminado  luego utilizamos <tt class="docutils literal"><span class="pre">return</span></tt> para devolver <tt class="docutils literal"><span class="pre">a</span></tt> como
resultado del bloque <tt class="docutils literal"><span class="pre">do</span></tt>. En lugar de utilizar esta expresión <tt class="docutils literal"><span class="pre">do</span></tt>
podíamos haber utilizado simplemente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Writer</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">])</span>
</pre></div>
</div>
<p>Aún así la expresión <tt class="docutils literal"><span class="pre">do</span></tt> parece más legible. Luego tenemos el caso en el
que <tt class="docutils literal"><span class="pre">b</span></tt> no es igual a <tt class="docutils literal"><span class="pre">0</span></tt>. En este caso, indicamos que vamos a utilizar
<tt class="docutils literal"><span class="pre">mod</span></tt> para averiguar cual es el resto de dividir <tt class="docutils literal"><span class="pre">a</span></tt> por <tt class="docutils literal"><span class="pre">b</span></tt>. La
segunda línea del bloque <tt class="docutils literal"><span class="pre">do</span></tt> simplemente llama de forma de recursiva a
<tt class="docutils literal"><span class="pre">gcd'</span></tt>. Recuerda que <tt class="docutils literal"><span class="pre">gcd'</span></tt> al final devuelve un valor del tipo
<tt class="docutils literal"><span class="pre">Writer</span></tt>, así que es perfectamente válido que <tt class="docutils literal"><span class="pre">gcd'</span> <span class="pre">b</span> <span class="pre">(a</span> <span class="pre">`mod`</span> <span class="pre">b)</span></tt> sea
una línea de la expresión <tt class="docutils literal"><span class="pre">do</span></tt>.</p>
<p>Vamos a probar esta nueva versión de <tt class="docutils literal"><span class="pre">gcd'</span></tt>. Su resultado es del tipo
<tt class="docutils literal"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Int</span></tt> así que debemos extraer la dupla de este <tt class="docutils literal"><span class="pre">newtype</span></tt>.
Luego, el primer componente de la dupla será el resultado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="o">$</span> <span class="n">runWriter</span> <span class="p">(</span><span class="n">gcd&#39;</span> <span class="mi">8</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>¡Bien! Ahora, ¿qué pasa cono el registro? Como el registro es una lista de
cadenas, vamos a utilizar <tt class="docutils literal"><span class="pre">mapM_</span> <span class="pre">putStrLn</span></tt> par mostrar las cadenas por
pantalla:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcd&#39; 8 3)</span>
<span class="go">8 mod 3 = 2</span>
<span class="go">3 mod 2 = 1</span>
<span class="go">2 mod 1 = 0</span>
<span class="go">Finished with 1</span>
</pre></div>
</div>
<p>Es genial como hemos sido capaces de cambiar el algoritmo original a uno que
devuelva lo que está sucediendo simplemente cambiando los valores normales por
valores monádicos y dejando que la implementación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para <tt class="docutils literal"><span class="pre">Writer</span></tt>
se encargue de los registros por nosotros. Podemos añadir este mecanismo de
registro casi a cualquier función. Solo tenemos que remplazar los valores
normales por valores del tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> y cambiar la aplicación normal de
funciones por <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> (o por expresiones <tt class="docutils literal"><span class="pre">do</span></tt> si vemos que es más legible).</p>
</div>
<div class="section" id="construccion-de-listas-ineficiente">
<h3>Construcción de listas ineficiente<a class="headerlink" href="#construccion-de-listas-ineficiente" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando utilizamos la mónada <tt class="docutils literal"><span class="pre">Writer</span></tt> hay que tener cuidado con que monoide
utilizar, ya que utilizar listas como monoides puede resultar en una ejecución
muy lenta. Esto se debe al uso de <tt class="docutils literal"><span class="pre">++</span></tt> de <tt class="docutils literal"><span class="pre">mappend</span></tt>, añadir una lista al
final de otra puede ser muy costoso si una lista es muy larga.</p>
<p>En la función <tt class="docutils literal"><span class="pre">gcd'</span></tt>, el registro es rápido porque la lista se acaba
pareciendo a esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">a</span> <span class="o">++</span> <span class="p">(</span><span class="n">b</span> <span class="o">++</span> <span class="p">(</span><span class="n">c</span> <span class="o">++</span> <span class="p">(</span><span class="n">d</span> <span class="o">++</span> <span class="p">(</span><span class="n">e</span> <span class="o">++</span> <span class="n">f</span><span class="p">))))</span>
</pre></div>
</div>
<p>Las listas son estructuras de datos que se construyen de izquierda a derecha,
y esto último es eficiente porque primero construimos la parte izquierda de la
lista y solo después de construirla añadimos una lista más larga a la derecha.
Pero si no tenemos cuidado al utilizar la mónada <tt class="docutils literal"><span class="pre">Writer</span></tt> podemos producir
listas que se parezcan a:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">((((</span><span class="n">a</span> <span class="o">++</span> <span class="n">b</span><span class="p">)</span> <span class="o">++</span> <span class="n">c</span><span class="p">)</span> <span class="o">++</span> <span class="n">d</span><span class="p">)</span> <span class="o">++</span> <span class="n">e</span><span class="p">)</span> <span class="o">++</span> <span class="n">f</span>
</pre></div>
</div>
<p>Esta lista se asocia por la izquierda en vez de por la derecha. No es
eficiente porque cada vez que queramos añadir la parte derecha a la parte
izquierda tiene que construir la parte izquierda desde el principio.</p>
<p>La siguiente función funciona igual que <tt class="docutils literal"><span class="pre">gdc'</span></tt>, solo que registra las
cadenas al revés. Primero produce el registro del procedimiento y luego añade
el paso actual al final del registro.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcdReverse</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Int</span>
<span class="nf">gcdReverse</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">]</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">gcdReverse</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)]</span>
        <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Primero realiza el paso de recursión y liga el resultado a <tt class="docutils literal"><span class="pre">result</span></tt>. Luego,
añade el paso actual al registro, pero el paso actual debe ir al final del
registro que a sido producido por la recursión. Al final, devuelve el
resultado de la recursión como resultado final.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)</span>
<span class="go">Finished with 1</span>
<span class="go">2 mod 1 = 0</span>
<span class="go">3 mod 2 = 1</span>
<span class="go">8 mod 3 = 2</span>
</pre></div>
</div>
<p>Es ineficiente porque acaba asociando el uso de <tt class="docutils literal"><span class="pre">++</span></tt> por la izquierda en
lugar de por la derecha.</p>
</div>
<div class="section" id="listas-de-diferencia">
<h3>Listas de diferencia<a class="headerlink" href="#listas-de-diferencia" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="Cactus" class="align-left" src="../_images/cactus.png" />
<p>Como la listas a veces son ineficientes cuando se concatenan repetidamente de
esta forma, lo mejor es utilizar un estructura de datos que cuando se
concatene sea siempre eficiente. Una estructura de este tipo es la lista de
diferencia. Una lista de diferencia es similar a una lista, solo que en lugar
de ser una lista normal, es una función que toma un lista y la antepone a
otra lista. La lista de diferencia equivalente a la lista <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt> sería
la función <tt class="docutils literal"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">[1,2,3]</span> <span class="pre">++</span> <span class="pre">xs</span></tt>. Un lista vacía normal <tt class="docutils literal"><span class="pre">[]</span></tt> equivaldría
a <tt class="docutils literal"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">[]</span> <span class="pre">++</span> <span class="pre">xs</span></tt>.</p>
<p>Lo interesante de las listas de diferencia es que soportan la concatenación de
forma eficiente. Cuando añadimos los listas normales con <tt class="docutils literal"><span class="pre">++</span></tt>, hay que
recorrer toda la lista de la izquierda hasta el final y luego añadir la otra
ahí. Pero, ¿y si tomamos el enfoque de las listas de diferencia y
representamos las listas como funciones? Bueno, entones añadir dos listas
diferentes sería:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">f</span> <span class="p">`</span><span class="n">append</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Recuerda que <tt class="docutils literal"><span class="pre">f</span></tt> y <tt class="docutils literal"><span class="pre">g</span></tt> son funciones que toman lista y la anteponen a
otra lista. Así que, por ejemplo, si la función <tt class="docutils literal"><span class="pre">f</span></tt> es <tt class="docutils literal"><span class="pre">(&quot;dog&quot;++)</span></tt> (que
es otra forma de decir que es <tt class="docutils literal"><span class="pre">\xs</span> <span class="pre">-&gt;</span> <span class="pre">&quot;dog&quot;</span> <span class="pre">++</span> <span class="pre">xs</span></tt>) y la función <tt class="docutils literal"><span class="pre">g</span></tt> es
<tt class="docutils literal"><span class="pre">(&quot;meat&quot;++)</span></tt>, entonces <tt class="docutils literal"><span class="pre">f</span> <span class="pre">`append`</span> <span class="pre">g</span></tt> crea una nueva función que será
equivalente a:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="s">&quot;dog&quot;</span> <span class="o">++</span> <span class="p">(</span><span class="s">&quot;meat&quot;</span> <span class="o">++</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>Hemos concatenado dos listas de diferencia creando una nueva función que
primero aplica una lista de diferencia y luego aplica la otra.</p>
<p>Vamos a crear un <tt class="docutils literal"><span class="pre">newtype</span></tt> para estas listas de diferencia de forma que
podamos darle fácilmente una instancia de <tt class="docutils literal"><span class="pre">Monoid</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">DiffList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">{</span> <span class="n">getDiffList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>El tipo que estamos definiendo es <tt class="docutils literal"><span class="pre">[a]</span> <span class="pre">-&gt;</span> <span class="pre">[a]</span></tt> porque las listas de
diferencia son solo funciones que toma una lista y devuelven otra. Convertir
listas normales en listas de diferencia y viceversa es fácil:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">toDiffList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">DiffList</span> <span class="n">a</span>
<span class="nf">toDiffList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="n">xs</span><span class="o">++</span><span class="p">)</span>

<span class="nf">fromDiffList</span> <span class="ow">::</span> <span class="kt">DiffList</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">fromDiffList</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>Para crear una lista de diferencia a partir de una lista normal solo tenemos
que hacer lo que ya hicimos antes, crear una función que añada una lista a
ella. Como una lista de diferencia es una función que antepone algo a una
lista, si queremos ese algo tenemos que aplicar la función a la lista
vacía.</p>
<p>Aquí esta la instancia de <tt class="docutils literal"><span class="pre">Monoid</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="kt">[]</span> <span class="o">++</span> <span class="n">xs</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">DiffList</span> <span class="n">f</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">DiffList</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">xs</span><span class="p">))</span>
</pre></div>
</div>
<p>Fíjate que <tt class="docutils literal"><span class="pre">mempty</span></tt> es igual a <tt class="docutils literal"><span class="pre">id</span></tt> y <tt class="docutils literal"><span class="pre">mappend</span></tt> es en realidad una
composición de funciones. Vamos a ver como funciona:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])</span>
<span class="go">[1,2,3,4,1,2,3]</span>
</pre></div>
</div>
<p>Ahora podemos aumentar la eficiencia de la función <tt class="docutils literal"><span class="pre">gcdReverse</span></tt> haciendo
que utilice listas de diferencia en lugar de listas normales:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Writer</span>

<span class="nf">gcd&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="kt">String</span><span class="p">)</span> <span class="kt">Int</span>
<span class="nf">gcd&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="s">&quot;Finished with &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">])</span>
        <span class="n">return</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">gcd&#39;</span> <span class="n">b</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; mod &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot; = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">a</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">b</span><span class="p">)])</span>
        <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Solo tenemos que cambiar el tipo del monoide de <tt class="docutils literal"><span class="pre">[String]</span></tt> a <tt class="docutils literal"><span class="pre">DiffList</span>
<span class="pre">String</span></tt> y luego cuando utilizamos <tt class="docutils literal"><span class="pre">tell</span></tt> convertir las listas normales a
listas de diferencia con <tt class="docutils literal"><span class="pre">toDiffList</span></tt>. Vamos a ver si se parecen:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ gcdReverse 110 34</span>
<span class="go">Finished with 2</span>
<span class="go">8 mod 2 = 0</span>
<span class="go">34 mod 8 = 2</span>
<span class="go">110 mod 34 = 8</span>
</pre></div>
</div>
<p>Ejecutamos <tt class="docutils literal"><span class="pre">gcdReverse</span> <span class="pre">110</span> <span class="pre">34</span></tt>, luego utilizamos <tt class="docutils literal"><span class="pre">runWriter</span></tt> para extraer
desde <tt class="docutils literal"><span class="pre">newtype</span></tt>, luego aplicamos <tt class="docutils literal"><span class="pre">snd</span></tt> para obtener el registro, y para
terminar aplicamos <tt class="docutils literal"><span class="pre">fromDiffList</span></tt> para convertir la lista de diferencia en
una lista normal que luego mostramos por pantalla.</p>
</div>
<div class="section" id="comparando-el-rendimiento">
<h3>Comparando el rendimiento<a class="headerlink" href="#comparando-el-rendimiento" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para hacernos una idea de cuanto mejoran el rendimiento las listas de
diferencia, considera esta función que simplemente hace una cuenta atrás hasta
cero, pero produce el registro al revés, al igual que <tt class="docutils literal"><span class="pre">gcdReverse</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">finalCountDown</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">(</span><span class="kt">DiffList</span> <span class="kt">String</span><span class="p">)</span> <span class="nb">()</span>
<span class="nf">finalCountDown</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="s">&quot;0&quot;</span><span class="p">])</span>
<span class="nf">finalCountDown</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">finalCountDown</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tell</span> <span class="p">(</span><span class="n">toDiffList</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
<p>Si le pasamos un <tt class="docutils literal"><span class="pre">0</span></tt>, lo registra. Para cualquier otro número, primero
cuenta su predecesor y luego añade el número actual al registro. Así que
si aplicamos <tt class="docutils literal"><span class="pre">finalCountDown</span></tt> a <tt class="docutils literal"><span class="pre">100</span></tt>, la cadena <tt class="docutils literal"><span class="pre">&quot;100&quot;</span></tt> será la última
en registrar.</p>
<p>De cualquier modo, si cargamos esta función en <em>GHCi</em>  y la aplicamos a un
número muy grande, como <tt class="docutils literal"><span class="pre">500000</span></tt>, veremos que empieza a contar desde <tt class="docutils literal"><span class="pre">0</span></tt>
rápidamente.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn . fromDiffList . snd . runWriter $ finalCountDown 500000</span>
<span class="go">0</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">...</span>
</pre></div>
</div>
<p>Sin embargo, si cambiamos la función para que utilice listas normales:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">finalCountDown</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="nb">()</span>
<span class="nf">finalCountDown</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;0&quot;</span><span class="p">]</span>
<span class="nf">finalCountDown</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">finalCountDown</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span><span class="p">]</span>
</pre></div>
</div>
<p>Y luego le decimos a <em>GHCi</em> que empiece a contar:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn . snd . runWriter $ finalCountDown 500000</span>
</pre></div>
</div>
<p>Veremos que va muy despacio.</p>
<p>Por supuesto, esta no es la forma correcta y científica de probar lo rápidos
que son nuestros programas, pero al menos podemos ver que para este caso,
utilizar listas de diferencia produce resultados de la forma apropiada
mientras que las listas normales tardan una eternidad.</p>
<p>Por cierto, te estará rondando por la cabeza el estribillo de la canción
<em>Final Countdown</em> de <em>Europe</em>, así que, ¡disfrútala!</p>
</div>
</div>
<div class="section" id="reader-o-no-otra-vez-la-misma-broma">
<h2>¿Reader? O no, otra vez la misma broma...<a class="headerlink" href="#reader-o-no-otra-vez-la-misma-broma" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En el capítulo que hablábamos de los
<a class="reference internal" href="Funtores.html#cfuntores"><em>funtores aplicativos</em></a>, vimos que el tipo función,
<tt class="docutils literal"><span class="pre">(-&gt;)</span> <span class="pre">r</span></tt> posee una instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt>. Al mapear una función <tt class="docutils literal"><span class="pre">f</span></tt>
sobre una función <tt class="docutils literal"><span class="pre">g</span></tt> creamos una función que tomará los mismo parámetros
que <tt class="docutils literal"><span class="pre">g</span></tt>, aplicará la función <tt class="docutils literal"><span class="pre">g</span></tt> y luego aplicará <tt class="docutils literal"><span class="pre">f</span></tt> a su resultado.
Básicamente estamos creando una función igual que <tt class="docutils literal"><span class="pre">g</span></tt>, solo que en vez de
devolver su resultado, devuelve el resultado de aplicar <tt class="docutils literal"><span class="pre">f</span></tt>. Por ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let f = (*5)</span>
<span class="go">ghci&gt; let g = (+3)</span>
<span class="go">ghci&gt; (fmap f g) 8</span>
<span class="go">55</span>
</pre></div>
</div>
<p>También vimos que las funciones son funtores aplicativos. Nos permiten operar
sobre funciones como si se tratasen de los resultados. Un ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let f = (+) &lt;$&gt; (*2) &lt;*&gt; (+10)</span>
<span class="go">ghci&gt; f 3</span>
<span class="go">19</span>
</pre></div>
</div>
<p>La expresión <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">&lt;$&gt;</span> <span class="pre">(*2)</span> <span class="pre">&lt;*&gt;</span> <span class="pre">(+10)</span></tt> crea una función que toma un número,
pasa ese número a <tt class="docutils literal"><span class="pre">(*2)</span></tt> y a <tt class="docutils literal"><span class="pre">(+10)</span></tt> y luego suma ambos resultados. Por
ejemplo, si aplicamos esta función a <tt class="docutils literal"><span class="pre">3</span></tt>, aplica tanto <tt class="docutils literal"><span class="pre">(*2)</span></tt> como
<tt class="docutils literal"><span class="pre">(+10)</span></tt> a <tt class="docutils literal"><span class="pre">3</span></tt>, obteniendo <tt class="docutils literal"><span class="pre">6</span></tt> y <tt class="docutils literal"><span class="pre">13</span></tt> y luego los suma devolviendo
<tt class="docutils literal"><span class="pre">19</span></tt>.</p>
<p>El tipo función <tt class="docutils literal"><span class="pre">(-&gt;)</span> <span class="pre">r</span></tt> no es solo un funtor y un funtor aplicativo, sino
también una mónada. De la misma forma que cualquier otro valor monádico que
ya hemos visto, una función puede ser vista como un valor con un contexto. El
contexto en este caso es que el valor aún no esta presente de forma que
tenemos que aplicar esa función a algo antes de obtener el resultado.</p>
<p>Como ya sabemos como funcionan las funciones como funtores y funtores
aplicativos, vamos a ver como luce su instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt>. Se encuentra en
<tt class="docutils literal"><span class="pre">Control.Monad.Instances</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span>
    <span class="n">h</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">w</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">h</span> <span class="n">w</span><span class="p">)</span> <span class="n">w</span>
</pre></div>
</div>
<p>Ya vimos como se implementaba <tt class="docutils literal"><span class="pre">pure</span></tt> para las funciones y <tt class="docutils literal"><span class="pre">return</span></tt> es
básicamente lo mismo. Toma un valor y lo introduce en el contexto mínimo que
siempre tendrá como resultado ese valor. Y la única forma de crear una
función que siempre tenga el mismo resultado es ignorando completamente su
parámetro.</p>
<p>La implementación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> puede parecer algo compleja, pero en realidad en
muy sencilla. Cuando utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasar un valor monádico a una
función, el resultado siempre es un valor monádico. Así que en este caso,
pasamos una función a otra función, y resultado será también una función. Por
este motivo la definición de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es una función lambda. Todas las
implementaciones de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> que hemos visto hasta ahora siempre asilaban el
resultado del valor monádico de algún modo y luego le aplicaban la función
<tt class="docutils literal"><span class="pre">f</span></tt>. Aquí pasa lo mismo. Para obtener el resultado de una función, tenemos
que aplicarla a algo, por este motivo hacemos <tt class="docutils literal"><span class="pre">(h</span> <span class="pre">w)</span></tt> aquí, para obtener el
resultado de una función y luego le aplicamos <tt class="docutils literal"><span class="pre">f</span></tt>. <tt class="docutils literal"><span class="pre">f</span></tt> devuelve un valor
monádico, que es una función en este caso, así que que le aplicamos <tt class="docutils literal"><span class="pre">w</span></tt> de
nuevo.</p>
<p>Si no entiendes como funciona <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> en este momento, no te preocupes, con
unos cuantos ejemplos veremos que es una mónada muy simple. Aquí tienes un
ejemplo de como usar una expresión <tt class="docutils literal"><span class="pre">do</span></tt> con esta mónada:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.Instances</span>

<span class="nf">addStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addStuff</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>Es básicamente la misma expresión aplicativa que escribimos antes, solo que
ahora vemos las funciones como mónadas. Una expresión <tt class="docutils literal"><span class="pre">do</span></tt> siempre resulta
en un valor monádico. En este caso tomamos un número y luego aplicamos
<tt class="docutils literal"><span class="pre">(*2)</span></tt> a ese número y el resultado lo ligamos a <tt class="docutils literal"><span class="pre">a</span></tt>. <tt class="docutils literal"><span class="pre">(+10)</span></tt> se aplica
de nuevo al mismo número y ligamos su resultado a <tt class="docutils literal"><span class="pre">b</span></tt>. <tt class="docutils literal"><span class="pre">return</span></tt>, como en
todas las demás mónadas, no tiene ningún otro efecto aparte de el de crear un
valor monádico que contendrá algún resultado. En este caso crea una función
que contendrá <tt class="docutils literal"><span class="pre">(a+b)</span></tt> como resultado. Si lo probamos veremos que obtenemos
los mismos resultados:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; addStuff 3</span>
<span class="go">19</span>
</pre></div>
</div>
<p>Tanto <tt class="docutils literal"><span class="pre">(*2)</span></tt> como <tt class="docutils literal"><span class="pre">(+10)</span></tt> se aplican al número <tt class="docutils literal"><span class="pre">3</span></tt>. <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(a+b)</span></tt>
también se aplica a <tt class="docutils literal"><span class="pre">3</span></tt> pero lo ignora y siempre devuelve <tt class="docutils literal"><span class="pre">(a+b)</span></tt> como
resultado. Por este motivo, la mónada de las funciones es conocida como la
mónada lectora (<em>reader</em> en inglés, en contraposición de <em>writer</em>, escritora).
Todas las funciones leen de la misma fuente. Podemos ilustrar esto incluso
mejor, podemos reescribir <tt class="docutils literal"><span class="pre">addStuff</span></tt> como:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">addStuff</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addStuff</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">let</span>
    <span class="n">a</span> <span class="ow">=</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">x</span>
    <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="n">x</span>
    <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span>
</pre></div>
</div>
<p>Podemos ver como la mónada lectora nos permite tratar a las funciones como
valores en un cierto contexto. Podemos actuar como ya conociéramos lo que van
a devolver. Lo que hacemos es unir todas las funciones en una sola y luego
pasamos el parámetro de esta función a todas las demás. Si tenemos un montón
de funciones a las que les faltan un solo parámetro y al final este parámetro
será igual para todas, podemos utilizar la mónada lectora para extraer sus
futuros resultados y la implementación de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> se encargará de que todo
funcione al final.</p>
</div>
<div class="section" id="monadas-monas-con-estado">
<h2>Mónadas monas con estado<a class="headerlink" href="#monadas-monas-con-estado" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="No juegues con Texas." class="align-left" src="../_images/texas.png" />
<p>Haskell es un lenguaje puro y como tal, los programas consisten en funciones
que no pueden cambiar ningún estado global o variables, solo pueden hacer
algunos cálculos o cómputos y devolver resultados. Esta restricción hace que
sea más fácil razonar acerca de los programas ya que no tenemos que
preocuparnos por el estado de una variable a lo largo del tiempo. Sin embargo,
algunos problemas posee de forma inherentemente estados que cambian con el
tiempo. Aunque estos estos estados no causan ningún problema a Haskell, a
veces pueden ser un poco tediosos de modelar. Por esta razón Haskell posee la
mónada estado, la cual nos permite tratar los problemas con estados como si
fueran un juego de niños y además mantiene todo el código puro.</p>
<p>Cuando estábamos trabajando con <a class="reference internal" href="EntradaSalida.html#aleatoriedad"><em>números aleatorios</em></a>,
utilizábamos funciones que tomaban un generador de aleatoriedad como parámetro
y devolvían un número aleatorio y un nuevo generador de aleatoriedad. Si
queríamos generar varios números aleatorios, siempre teníamos que utilizar el
generador de aleatoriedad que devolvió la función anterior. Si queremos crear
una función que tome un generador de aleatoriedad y devuelva el resultado de
lanzar una moneda tres veces, tenemos que hacer esto:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">threeCoins</span> <span class="ow">::</span> <span class="kt">StdGen</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)</span>
<span class="nf">threeCoins</span> <span class="n">gen</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">newGen</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="p">(</span><span class="n">secondCoin</span><span class="p">,</span> <span class="n">newGen&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen</span>
        <span class="p">(</span><span class="n">thirdCoin</span><span class="p">,</span> <span class="n">newGen&#39;&#39;</span><span class="p">)</span> <span class="ow">=</span> <span class="n">random</span> <span class="n">newGen&#39;</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">firstCoin</span><span class="p">,</span> <span class="n">secondCoin</span><span class="p">,</span> <span class="n">thirdCoin</span><span class="p">)</span>
</pre></div>
</div>
<p>Toma un generador <tt class="docutils literal"><span class="pre">gen</span></tt> y luego <tt class="docutils literal"><span class="pre">random</span> <span class="pre">gen</span></tt> devuelve un <tt class="docutils literal"><span class="pre">Bool</span></tt> junto
con un nuevo generador. Para lanzar la segunda moneda, utilizamos el nuevo
generador, y así sucesivamente. La mayoría de los otros lenguajes no hubieran
devuelto un nuevo generador junto con el número aleatorio. Simplemente
habrían modificado el generador original. Pero Haskell es puro, no podemos
hacer esto, así que tenemos que tomar un estado, crear un resultado a partir
de él y producir un nuevo estado que será utilizado para generar nuevos
resultados.</p>
<p>Si crees que para evitar tratar manualmente con estos estado en Haskell
tenemos que perder la pureza de nuestro código, estás equivocado. Existe una
pequeña mónada, llamada la mónada estado, que se encarga de manejar todo lo
relaciona con estado sin renegar a la pureza.</p>
<p>Así que, para entender mejor todo este concepto de cómputos con estado vamos
a darle un tipo. Antes hemos dicho que un cómputo con estado es una función
que toma un estado y produce un resultado junto a un nuevo estado. Esta
función tendría un tipo como este:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">s</span></tt> es el estado y <tt class="docutils literal"><span class="pre">a</span></tt> el resultado de estos cómputos con estado.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">En otros lenguajes, la asignación de variables puede verse como un
especie de cómputo con estado. Por ejemplo, si hacemos <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">5</span></tt> en
un lenguaje imperativo, se asignará el valor <tt class="docutils literal"><span class="pre">5</span></tt> a la variable
<tt class="docutils literal"><span class="pre">x</span></tt> y la expresión tendrá un resultado igual a <tt class="docutils literal"><span class="pre">5</span></tt>. Podemos ver
esta funcionalidad como si la asignación fuera una función que toma
un estado (es decir, todas las variables que han sido asignadas
anteriormente) y devuelve un resultado (en este caso <tt class="docutils literal"><span class="pre">5</span></tt>) y nuevo
estado que será el conjunto de todas las variables anteriores más
la nueva asignación.</p>
</div>
<p>Estos cómputos con estado, funciones que toman un estado y devuelven un
resultado junto con un nuevo estado, también se pueden ver como un valor en
cierto contexto. El valor real es es el resultado, mientras que el contexto es
el estado inicial del que hemos extraído el resultado, generando así un nuevo
estado.</p>
<div class="section" id="pilas-y-pilones">
<h3>Pilas y pilones<a class="headerlink" href="#pilas-y-pilones" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Digamos que queremos modelar una pila. Tenemos un pila de cosas una encima de
otra y podemos o bien añadir otra cosa encima de la pila o bien tomar una cosa
de la cima de la pila. Cuando ponemos un objeto en la cima de la pila decimos
que estamos apilando un objeto, y cuando tomamos un objeto de la pila decimos
que estamos retirando un objeto. Si queremos el objeto que se encuentra más
abajo de la pila tenemos que retirar antes todos los objetos que se encuentran
por encima de éste.</p>
<p>Utilizaremos una lista para representar la pila, y su cabeza para representar
la cima de la pila. Para hacer las cosas más fáciles, vamos a crear dos
funciones: <tt class="docutils literal"><span class="pre">pop</span></tt> y <tt class="docutils literal"><span class="pre">push</span></tt>. <tt class="docutils literal"><span class="pre">pop</span></tt> tomará una pila y retirará un elemento
que devolverá como resultado, junto a una nueva pila sin dicho elemento en la
cima. <tt class="docutils literal"><span class="pre">push</span></tt> tomará un elemento y una pila y luego apilará dicho elemento en
la pila. Devolverá <tt class="docutils literal"><span class="pre">()</span></tt> como resultado, junto a una nueva pila.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">type</span> <span class="kt">Stack</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>

<span class="nf">pop</span> <span class="ow">::</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Stack</span><span class="p">)</span>
<span class="nf">pop</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span>

<span class="nf">push</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="kt">Stack</span><span class="p">)</span>
<span class="nf">push</span> <span class="n">a</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">a</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p>A la hora de apilar un elemento devolvemos <tt class="docutils literal"><span class="pre">()</span></tt> porque el hecho de apilar un
elemento no tienen ningún resulto importante, su principal objetivo es
modificar la pila. Fíjate que en <tt class="docutils literal"><span class="pre">push</span></tt> solo hemos añadido el primer
parámetro, obteniendo así un cómputo con estado. <tt class="docutils literal"><span class="pre">pop</span></tt> ya es de por si un
cómputo con estado debido a su tipo.</p>
<p>Vamos a escribir un trocito de código que simule el uso de estas funciones.
Tomaremos una pila, apilaremos un <tt class="docutils literal"><span class="pre">3</span></tt> y luego retiraremos dos elementos,
para pasar el rato más que nada.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">Stack</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Stack</span><span class="p">)</span>
<span class="nf">stackManip</span> <span class="n">stack</span> <span class="ow">=</span> <span class="kr">let</span>
    <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">newStack1</span><span class="p">)</span> <span class="ow">=</span> <span class="n">push</span> <span class="mi">3</span> <span class="n">stack</span>
    <span class="p">(</span><span class="n">a</span> <span class="p">,</span><span class="n">newStack2</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pop</span> <span class="n">newStack1</span>
    <span class="kr">in</span> <span class="n">pop</span> <span class="n">newStack2</span>
</pre></div>
</div>
<p>Tomamos una pila (<tt class="docutils literal"><span class="pre">stack</span></tt>) y luego hacemos <tt class="docutils literal"><span class="pre">push</span> <span class="pre">3</span> <span class="pre">stack</span></tt>, lo que nos
devuelve una tupla. La primera parte de la tupla es <tt class="docutils literal"><span class="pre">()</span></tt> y la segunda es
una nueva pila que llamaremos <tt class="docutils literal"><span class="pre">newStack1</span></tt>. Luego, retiramos un número de
<tt class="docutils literal"><span class="pre">newStack1</span></tt>, lo cual devuelve ese número <tt class="docutils literal"><span class="pre">a</span></tt> (que es <tt class="docutils literal"><span class="pre">3</span></tt>) y una nueva
pila que llamaremos <tt class="docutils literal"><span class="pre">newStack2</span></tt>. Luego retiramos otro elemento de
<tt class="docutils literal"><span class="pre">newStack2</span></tt> y obtenemos un número <tt class="docutils literal"><span class="pre">b</span></tt> y una pila <tt class="docutils literal"><span class="pre">newStack3</span></tt>. Devolvemos
una dupla que contendrá ese número y esa tupla. Vamos a probarlo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; stackManip [5,8,2,1]</span>
<span class="go">(5,[8,2,1])</span>
</pre></div>
</div>
<p>Genial, el resultado es <tt class="docutils literal"><span class="pre">5</span></tt> y la pila es <tt class="docutils literal"><span class="pre">[8,2,1]</span></tt>. El mismo
<tt class="docutils literal"><span class="pre">stackManip</span></tt> es un cómputo con estado. Hemos tomado un puñado de cómputos
con estado y de alguna forma los hemos unido todos. Mmm... Me recuerda a algo.</p>
<p>El código que acabamos de ver es algo tedioso ya que tenemos que pasar el
estado manualmente en cada cómputo, además de que tenemos que ligarlo a una
variable para luego pasarlo al siguiente cómputo ¿No sería mejor si, en lugar
de pasar una pila manualmente a cada función, pudiéramos escribir algo como
esto?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>Bueno, pues usando la mónada estado podemos hacerlo. Gracias a ella podemos
tomar cómputos con estado como estos y usarlos sin tener que preocuparnos por
manejar el estado de forma manual.</p>
</div>
<div class="section" id="la-monada-estado">
<h3>La mónada estado<a class="headerlink" href="#la-monada-estado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El módulo <tt class="docutils literal"><span class="pre">Control.Monad.State</span></tt> contiene un <tt class="docutils literal"><span class="pre">newtype</span></tt> para los cómputos
con estado. Aquí tienes su definición:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">newtype</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="p">{</span> <span class="n">runState</span> <span class="ow">::</span> <span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>
</pre></div>
</div>
<p>Un <tt class="docutils literal"><span class="pre">State</span> <span class="pre">s</span> <span class="pre">a</span></tt> es un cómputo con estado que manipula el estado del tipo
<tt class="docutils literal"><span class="pre">s</span></tt> y tiene como resultado el tipo <tt class="docutils literal"><span class="pre">a</span></tt>.</p>
<p>Ahora que ya hemos visto como funcionan los cómputos con estado y que incluso
podemos verlos como valores en cierto contexto, vamos a comprobar su
instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="p">(</span><span class="kt">State</span> <span class="n">h</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">newState</span><span class="p">)</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">s</span>
                                        <span class="p">(</span><span class="kt">State</span> <span class="n">g</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">a</span>
                                    <span class="kr">in</span>  <span class="n">g</span> <span class="n">newState</span>
</pre></div>
</div>
<p>Vamos a echar un vistazo primero a <tt class="docutils literal"><span class="pre">return</span></tt>. Nuestro objetivo con <tt class="docutils literal"><span class="pre">return</span></tt>
es tomar un valor y crear un cómputo con estado que siempre contenga ese
valor como resultado. Por este motivo creamos una función lamba
<tt class="docutils literal"><span class="pre">\s</span> <span class="pre">-&gt;</span> <span class="pre">(s,a)</span></tt>. Siempre devolvemos <tt class="docutils literal"><span class="pre">x</span></tt> como resultado del cómputo con
estado y además el estado se mantiene constante, ya que <tt class="docutils literal"><span class="pre">return</span></tt> debe
insertar un valor en el contexto mínimo. Recapitulando, <tt class="docutils literal"><span class="pre">return</span></tt> tomará un
valor y creará un cómputo con estado que revolverá ese valor como resultado
y mantendrá el estado intacto.</p>
<img alt="Soy un agente de la ley." class="align-right" src="../_images/badge.png" />
<p>¿Y <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>? Bueno, el resultado de pasar un cómputo con estado a una función
con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es un cómputo con estado ¿no? Así que empezamos construyendo el
<tt class="docutils literal"><span class="pre">newtype</span></tt> <tt class="docutils literal"><span class="pre">State</span></tt> y luego utilizamos una función lambda. La función lambda
será el cómputo con estado. Pero, ¿qué es lo que hace? Bueno, de alguna forma
debemos extraer el resultado del primer cómputo con estado. Como nos
encontramos dentro de un cómputo con estado, podemos pasarle el estado actual
<tt class="docutils literal"><span class="pre">s</span></tt> a <tt class="docutils literal"><span class="pre">h</span></tt>, lo cual devolverá un dupla con el resultado y un nuevo estado
<tt class="docutils literal"><span class="pre">(a,</span> <span class="pre">newState)</span></tt>. Siempre que hemos implementado <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, una vez extraído el
resultado de un valor monádico aplicábamos la función <tt class="docutils literal"><span class="pre">f</span></tt> sobre éste para
obtener un nuevo valor monádico. Por ejemplo, con <tt class="docutils literal"><span class="pre">Writer</span></tt>, luego de obtener
el nuevo valor monádico, aún teníamos que asegurarnos de tratar el nuevo
contexto aplicando <tt class="docutils literal"><span class="pre">mappend</span></tt> entre el valor monoidal antiguo y el nuevo.
Aquí, realizamos <tt class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></tt> para obtener un nuevo cómputo con estado <tt class="docutils literal"><span class="pre">g</span></tt>. Ahora
que ya tenemos un nuevo cómputo con estado y nuevo estado (con el nombre de
<tt class="docutils literal"><span class="pre">newState</span></tt>) solo tenemos que aplicar <tt class="docutils literal"><span class="pre">g</span></tt> sobre <tt class="docutils literal"><span class="pre">newState</span></tt>. El resultado
será una tupla, y al mismo tiempo, el resultado final.</p>
<p>Así que <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> básicamente se encarga de unir dos cómputos con estado, solo
que el segundo está oculto dentro de una función que se encarga de obtener el
resultado anterior. Como <tt class="docutils literal"><span class="pre">pop</span></tt> y <tt class="docutils literal"><span class="pre">push</span></tt> son ya cómputos con estado, es
muy fácil introducirlos dentro de <tt class="docutils literal"><span class="pre">State</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">pop</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">pop</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xs</span><span class="p">)</span>

<span class="nf">push</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">push</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">a</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">pop</span></tt> ya es en si mismo un cómputo con estado y <tt class="docutils literal"><span class="pre">push</span></tt> es una función que
toma un <tt class="docutils literal"><span class="pre">Int</span></tt> y devuelve un cómputo con estado. Ahora podemos reescribir el
ejemplo anterior que apilaba un <tt class="docutils literal"><span class="pre">3</span></tt> y luego retiraba  dos números así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>¿Ves como hemos unido un <tt class="docutils literal"><span class="pre">push</span></tt> y dos <tt class="docutils literal"><span class="pre">pop</span></tt> juntos en un solo cómputo con
estado? Cuando extraemos el contenido del <tt class="docutils literal"><span class="pre">newtype</span></tt> obtenemos una función
a la que tenemos que pasarle el estado inicial:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runState stackManip [5,8,2,1]</span>
<span class="go">(5,[8,2,1])</span>
</pre></div>
</div>
<p>De hecho no tenemos porque ligar el segundo <tt class="docutils literal"><span class="pre">pop</span></tt> a <tt class="docutils literal"><span class="pre">a</span></tt> ya que no
utilizamos <tt class="docutils literal"><span class="pre">a</span></tt> luego. Así que podemos reescribirlo de nuevo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">stackManip</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="kt">Int</span>
<span class="nf">stackManip</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">push</span> <span class="mi">3</span>
    <span class="n">pop</span>
    <span class="n">pop</span>
</pre></div>
</div>
<p>Perfecto. Ahora queremos hacer esto: retiramos un número de la pila y si dicho
número es <tt class="docutils literal"><span class="pre">5</span></tt> lo devolvemos a la pila, si no, apilamos un <tt class="docutils literal"><span class="pre">3</span></tt> y un <tt class="docutils literal"><span class="pre">8</span></tt>.
Así sería el código:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">stackStuff</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">stackStuff</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">pop</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">5</span>
        <span class="kr">then</span> <span class="n">push</span> <span class="n">a</span>
        <span class="kr">else</span> <span class="kr">do</span>
            <span class="n">push</span> <span class="mi">3</span>
            <span class="n">push</span> <span class="mi">8</span>
</pre></div>
</div>
<p>Bastante sencillo. Vamos a ejecutarlo junto a un estado inicial.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runState stackStuff [9,0,2,1,0]</span>
<span class="go">((),[8,3,0,2,1,0])</span>
</pre></div>
</div>
<p>Recuerda que las expresiones <tt class="docutils literal"><span class="pre">do</span></tt> devuelve valores monádicos y en el caso
de la mónada <tt class="docutils literal"><span class="pre">State</span></tt>, cada expresión <tt class="docutils literal"><span class="pre">do</span></tt> es también una función con
estado. Como tanto <tt class="docutils literal"><span class="pre">stackStuff</span></tt> y <tt class="docutils literal"><span class="pre">stackManip</span></tt> son cómputos con estado
normales y corrientes, podemos unirlos y producir un nuevo cómputo con estado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">moreStack</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">moreStack</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">stackManip</span>
    <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">100</span>
        <span class="kr">then</span> <span class="n">stackStuff</span>
        <span class="kr">else</span> <span class="n">return</span> <span class="nb">()</span>
</pre></div>
</div>
<p>Si el resultado de <tt class="docutils literal"><span class="pre">stackManip</span></tt> sobre la pila actual es <tt class="docutils literal"><span class="pre">100</span></tt>, ejecutamos
<tt class="docutils literal"><span class="pre">stackStuff</span></tt>, si no no hacemos nada. <tt class="docutils literal"><span class="pre">return</span> <span class="pre">()</span></tt> simplemente mantiene el
estado.</p>
<p>El módulo <tt class="docutils literal"><span class="pre">Control.Monad.State</span></tt> contiene una clase de tipos llamada
<tt class="docutils literal"><span class="pre">MonadState</span></tt> y ésta a su vez contiene dos útiles funciones: <tt class="docutils literal"><span class="pre">get</span></tt> y
<tt class="docutils literal"><span class="pre">put</span></tt>. Para <tt class="docutils literal"><span class="pre">State</span></tt>, <tt class="docutils literal"><span class="pre">get</span></tt> se implementa así:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">get</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Es decir, toma el estado actual y lo devuelve como resultado. La función
<tt class="docutils literal"><span class="pre">put</span></tt> toma un estado y crea una función con estado que remplazará el estado
actual por su parámetro:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">put</span> <span class="n">newState</span> <span class="ow">=</span> <span class="kt">State</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="nb">()</span><span class="p">,</span><span class="n">newState</span><span class="p">)</span>
</pre></div>
</div>
<p>Gracias a estas funciones, podemos ver que el contenido de la pila actual o
incluso remplazar toda la pila por una nueva.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">stackyStack</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">Stack</span> <span class="nb">()</span>
<span class="nf">stackyStack</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">stackNow</span> <span class="ow">&lt;-</span> <span class="n">get</span>
    <span class="kr">if</span> <span class="n">stackNow</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
        <span class="kr">then</span> <span class="n">put</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="kr">else</span> <span class="n">put</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Es bueno ver como quedaría el tipo de <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> si solo funcionará con valores
del tipo <tt class="docutils literal"><span class="pre">State</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="n">s</span> <span class="n">b</span>
</pre></div>
</div>
<p>Fíjate en que el tipo del estado <tt class="docutils literal"><span class="pre">s</span></tt> se mantiene constante pero sin embargo
el tipo del resultado puede cambiar de <tt class="docutils literal"><span class="pre">a</span></tt> a <tt class="docutils literal"><span class="pre">b</span></tt>. Esto significa que
podemos unir varios cómputos con estado cuyos resultados sean de diferentes
tipos pero el tipo de sus estados sea el mismo. Y, ¿por qué? Bueno, por
ejemplo, para <tt class="docutils literal"><span class="pre">Maybe</span></tt>, <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> tiene este tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div>
</div>
<p>Tiene sentido que la mónada en si misma, <tt class="docutils literal"><span class="pre">Maybe</span></tt>, no cambie. No tendría
sentido que pudiéramos usar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> con dos mónadas distintas. Bueno, en el
caso de la mónada estado, en realidad la mónada es <tt class="docutils literal"><span class="pre">State</span> <span class="pre">s</span></tt>, así que si
<tt class="docutils literal"><span class="pre">s</span></tt> fuera distinta, estaríamos utilizando <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> entre dos mónadas
distintas.</p>
</div>
<div class="section" id="aleatoriedad-y-la-monada-estado">
<h3>Aleatoriedad y la mónada estado<a class="headerlink" href="#aleatoriedad-y-la-monada-estado" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Al principio de esta sección vimos que como se generaban número aleatorios y
que a veces puede ser algo pesado ya que cada función aleatoria toma un
generador y devuelve un número aleatorio junto un nuevo generador, que
tendremos que utilizar en lugar del viejo para generar otro número diferente.
La mónada estado hace que trabajar con todo esto sea mucho más cómodo.</p>
<p>La función <tt class="docutils literal"><span class="pre">random</span></tt> del módulo <tt class="docutils literal"><span class="pre">System.Random</span></tt> tiene este tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">random</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">g</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
</pre></div>
</div>
<p>Es decir, toma un generador de aleatoriedad y produce un número aleatorio
junto un nuevo generador. Podemos ver que en realidad se trata de un cómputo
con estado, así que podemos introducirlo en el constructor <tt class="docutils literal"><span class="pre">newtype</span></tt>
<tt class="docutils literal"><span class="pre">State</span></tt> y luego utilizarlo como un valor monádico de forma que no nos
tengamos que preocupar por manejar el estado:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">randomSt</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RandomGen</span> <span class="n">g</span><span class="p">,</span> <span class="kt">Random</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">State</span> <span class="n">g</span> <span class="n">a</span>
<span class="nf">randomSt</span> <span class="ow">=</span> <span class="kt">State</span> <span class="n">random</span>
</pre></div>
</div>
<p>Así que si ahora queremos lanzar tres monedas (<tt class="xref docutils literal"><span class="pre">True</span></tt> cruz, <tt class="xref docutils literal"><span class="pre">False</span></tt> cara)
solo tenemos que hacer lo siguiente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">System.Random</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="nf">threeCoins</span> <span class="ow">::</span> <span class="kt">State</span> <span class="kt">StdGen</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Bool</span><span class="p">,</span><span class="kt">Bool</span><span class="p">)</span>
<span class="nf">threeCoins</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">randomSt</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>Ahora <tt class="docutils literal"><span class="pre">threeCoins</span></tt> es un cómputo con estado y luego de tomar un generador de
aleatoriedad inicial, lo pasa al primer <tt class="docutils literal"><span class="pre">randomSt</span></tt>, el cual producirá un
número aleatorio y un nuevo generador, el cual será pasado al siguiente y así
sucesivamente. Utilizamos <tt class="docutils literal"><span class="pre">return</span> <span class="pre">(a,b,c)</span></tt> para devolver <tt class="docutils literal"><span class="pre">(a,b,c)</span></tt> como
resultado manteniendo constante el generador más reciente.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runState threeCoins (mkStdGen 33)</span>
<span class="go">((True,False,True),680029187 2103410263)</span>
</pre></div>
</div>
<p>Ahora realizar todo este tipo de tareas que requieren el uso de algún tipo de
estado es mucho más cómodo.</p>
</div>
</div>
<div class="section" id="errores-errores-errores">
<h2>Errores, errores, errores...<a class="headerlink" href="#errores-errores-errores" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Sabemos que <tt class="docutils literal"><span class="pre">Maybe</span></tt> se utiliza para dar el contexto de un posible fallo a
los valores. Un valor puede ser <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">algo</span></tt> o <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Sin embargo,
cuando tenemos un <tt class="docutils literal"><span class="pre">Nothing</span></tt>, puede resultar útil dar alguna información del
error que ha ocurrido, lo cual no podemos hacer con <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>Por otra parte, el tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></tt> nos permite incorporar el contexto de
un posible fallo al mismo tiempo que nos permite dar información acerca del
posible fallo, de forma que podemos describir que ha ido mal o dar alguna
información acerca del fallo. Un valor del tipo <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></tt> puede ser un
valor <tt class="docutils literal"><span class="pre">Right</span></tt>, lo cual representa un respuesta correcta, o un valor
<tt class="docutils literal"><span class="pre">Left</span></tt>, que representa un fallo. Por ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; :t Right 4</span>
<span class="go">Right 4 :: (Num t) =&gt; Either a t</span>
<span class="go">ghci&gt; :t Left &quot;out of cheese error&quot;</span>
<span class="go">Left &quot;out of cheese error&quot; :: Either [Char] b</span>
</pre></div>
</div>
<p>Básicamente es como un <tt class="docutils literal"><span class="pre">Maybe</span></tt> mejorado, así que tiene sentido que sea una
mónada. También puede ser visto como un valor con el contexto de un posible
fallo, solo que ahora existe un valor añadido cuando ocurre un error.</p>
<p>Su instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> es parecida a la de <tt class="docutils literal"><span class="pre">Maybe</span></tt> y se encuentra en
<tt class="docutils literal"><span class="pre">Control.Monad.Error</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="p">(</span><span class="kt">Error</span> <span class="n">e</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">e</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">x</span>
    <span class="kt">Right</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
    <span class="kt">Left</span> <span class="n">err</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
    <span class="n">fail</span> <span class="n">msg</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="p">(</span><span class="n">strMsg</span> <span class="n">msg</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">return</span></tt>, como siempre, toma un valor y lo introduce en el contexto mínimo
por defecto. Introduce un valor en el constructor <tt class="docutils literal"><span class="pre">Right</span></tt> ya que utilizamos
<tt class="docutils literal"><span class="pre">Right</span></tt> para representar un cómputo con éxito donde existe un resultado. Se
parece mucho al <tt class="docutils literal"><span class="pre">return</span></tt> de <tt class="docutils literal"><span class="pre">Maybe</span></tt>.</p>
<p>La función <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> examina dos posibles casos: un <tt class="docutils literal"><span class="pre">Left</span></tt> y un <tt class="docutils literal"><span class="pre">Right</span></tt>. En
caso de <tt class="docutils literal"><span class="pre">Right</span></tt>, la función <tt class="docutils literal"><span class="pre">f</span></tt> se aplica sobre el valor interior, de
forma similar a lo que sucedía con <tt class="docutils literal"><span class="pre">Just</span></tt>. En caso de que ocurra un error,
se mantiene constante el valor de <tt class="docutils literal"><span class="pre">Left</span></tt>, el cual da información acerca del
error.</p>
<p>La instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> para <tt class="docutils literal"><span class="pre">Either</span> <span class="pre">e</span></tt> tiene un requerimiento adicional,
y este es que el tipo del valor que está contenido en <tt class="docutils literal"><span class="pre">Left</span></tt>, el parámetro
de tipo <tt class="docutils literal"><span class="pre">e</span></tt> en este caso, tiene que formar parte de la clase de tipos
<tt class="docutils literal"><span class="pre">Error</span></tt>. La clase de tipos <tt class="docutils literal"><span class="pre">Error</span></tt> es para los tipos cuyos valores pueden
actuar como mensajes de error. Define la función <tt class="docutils literal"><span class="pre">strMsg</span></tt>, que toma un error
en forma de cadena y devuelve ese valor en forma de error. Un buen ejemplo de
instancia de <tt class="docutils literal"><span class="pre">Error</span></tt> es el tipo <tt class="docutils literal"><span class="pre">String</span></tt>. Para el caso de <tt class="docutils literal"><span class="pre">String</span></tt>, la
función <tt class="docutils literal"><span class="pre">strMsg</span></tt> simplemente devuelve la cadena que se le pasa:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; :t strMsg</span>
<span class="go">strMsg :: (Error a) =&gt; String -&gt; a</span>
<span class="go">ghci&gt; strMsg &quot;boom!&quot; :: String</span>
<span class="go">&quot;boom!&quot;</span>
</pre></div>
</div>
<p>Como normalmente utilizamos <tt class="docutils literal"><span class="pre">String</span></tt> para describir los errores no tenemos
que preocuparnos mucho por esto. Cuando un ajuste de patrones falla dentro de
una expresión <tt class="docutils literal"><span class="pre">do</span></tt>, se devuelve valor <tt class="docutils literal"><span class="pre">Left</span></tt> para representar este error.</p>
<p>De cualquier modo, aquí tienes unos cuantos ejemplos:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Left &quot;boom&quot; &gt;&gt;= \x -&gt; return (x+1)</span>
<span class="go">Left &quot;boom&quot;</span>
<span class="go">ghci&gt; Right 100 &gt;&gt;= \x -&gt; Left &quot;no way!&quot;</span>
<span class="go">Left &quot;no way!&quot;</span>
</pre></div>
</div>
<p>Cuando utilizamos <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> para pasar un valor <tt class="docutils literal"><span class="pre">Left</span></tt> a una función, la
función se ignora y se devuelve un <tt class="docutils literal"><span class="pre">Left</span></tt> idéntico. Cuando pasamos un valor
<tt class="docutils literal"><span class="pre">Right</span></tt> a una función, la función se aplica al contenido de éste, pero en
este caso la función devuelve un valor <tt class="docutils literal"><span class="pre">Left</span></tt> de todas formas.</p>
<p>Si intentamos pasar una valor <tt class="docutils literal"><span class="pre">Right``a</span> <span class="pre">una</span> <span class="pre">función</span> <span class="pre">que</span> <span class="pre">también</span> <span class="pre">devuelve</span> <span class="pre">un</span>
<span class="pre">valor</span> <span class="pre">``Right</span></tt> en <em>GHCi</em>, nos encontraremos con un error peculiar.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100)</span>

<span class="go">&lt;interactive&gt;:1:0:</span>
<span class="go">    Ambiguous type variable `a&#39; in the constraints:</span>
<span class="go">      `Error a&#39; arising from a use of `it&#39; at &lt;interactive&gt;:1:0-33</span>
<span class="go">      `Show a&#39; arising from a use of `print&#39; at &lt;interactive&gt;:1:0-33</span>
<span class="go">    Probable fix: add a type signature that fixes these type variable(s)</span>
</pre></div>
</div>
<p>Haskell dice que no sabe que tipo elegir para la parte <tt class="docutils literal"><span class="pre">e</span></tt> del tipo
<tt class="docutils literal"><span class="pre">Either</span> <span class="pre">e</span> <span class="pre">a</span></tt>, incluso aunque solo mostremos la parte <tt class="docutils literal"><span class="pre">Right</span></tt>. Esto se debe
a la restricción <tt class="docutils literal"><span class="pre">Error</span> <span class="pre">e</span></tt> de la instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt>. Así que si no
quieres ver más errores de este tipo cuando trabajes con la mónada <tt class="docutils literal"><span class="pre">Either</span></tt>,
añade un anotación de tipo explícita:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Right 3 &gt;&gt;= \x -&gt; return (x + 100) :: Either String Int</span>
<span class="go">Right 103</span>
</pre></div>
</div>
<p>¡Bien! Ahora funciona.</p>
<p>Aparte de este pequeño detalle, esta mónada es muy similar a la mónada
<tt class="docutils literal"><span class="pre">Maybe</span></tt>. En el capítulo anterior, utilizamos varios aspectos monádicos de
<tt class="docutils literal"><span class="pre">Maybe</span></tt> para simular el aterrizaje de las aves en la barra de equilibrio de
nuestro buen amigo Pierre. A modo de ejercicio, puedes reescribir estas
funciones con la mónada error de forma que cuando el funambulista se caiga,
podamos informar del número de pájaros que había en la barra cuando se cayó.</p>
</div>
<div class="section" id="algunas-funciones-monadicas-utiles">
<h2>Algunas funciones monádicas útiles<a class="headerlink" href="#algunas-funciones-monadicas-utiles" title="Enlazar permanentemente con este título">¶</a></h2>
<p>En esta sección vamos a ver una cuantas funciones que pueden operar con
valores monádicos o devolver valores monádicos como resultado (¡o ambas
cosas!). Normalmente no referimos a estas funciones como funciones monádicas.
Mientras que algunas de éstas nos serán totalmente desconocidas, otras son las
versiones monádicas de algunas funciones que ya conocemos, como <tt class="docutils literal"><span class="pre">filter</span></tt> o
<tt class="docutils literal"><span class="pre">foldl</span></tt>.</p>
<div class="section" id="liftm-y-sus-amigos">
<h3><tt class="docutils literal"><span class="pre">liftM</span></tt> y sus amigos<a class="headerlink" href="#liftm-y-sus-amigos" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="¡Yo también soy un agente de la ley!" class="align-right" src="../_images/wolf.png" />
<p>Cuando empezamos nuestro viaje hacia la cima de las mónadas, primero vimos los
funtores, que son cosas que se pueden mapear. Luego vimos que podíamos mejorar
los funtores en algo que llamamos funtores aplicativos, que permitían aplicar
funciones normales entre valores aplicativos a la vez que permitían tomar
funciones e introducirlas en el contexto por defecto. Para terminar, vimos que
podíamos mejorar los funtores aplicativos y eso nos llevaba a las mónadas, que
añadían la habilidad de poder pasas esos valores con un cierto contexto a
funciones normales.</p>
<p>Resumiendo, todas las mónadas son funtores aplicativos y todos los funtores
aplicativos son funtores normales. La clase de tipos <tt class="docutils literal"><span class="pre">Applicative</span></tt> posee una
restricción de clase que dice que su tipo debe poseer una instancia de la
clase <tt class="docutils literal"><span class="pre">Functor</span></tt> antes de que se puede crear un instancia de <tt class="docutils literal"><span class="pre">Applicative</span></tt>.
Aunque la clase <tt class="docutils literal"><span class="pre">Monad</span></tt> debería tener la misma restricción con
<tt class="docutils literal"><span class="pre">Applicative</span></tt>, ya que todas las mónadas son también funtores aplicativos, no
la tiene. Esto se debe a que la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt> se introdujo en
Haskell antes que <tt class="docutils literal"><span class="pre">Applicative</span></tt>.</p>
<p>Incluso aunque toda mónada es también un funtor, no tenemos que depender de
la instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt> gracias a la existencia de la función <tt class="docutils literal"><span class="pre">liftM</span></tt>.
<tt class="docutils literal"><span class="pre">liftM</span></tt> toma una función y un valor monádico y mapea la función sobre el
valor monádico. Vamos, ¡igual que <tt class="docutils literal"><span class="pre">fmap</span></tt>! Esta es su declaración de tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>Y esta es la de <tt class="docutils literal"><span class="pre">map</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Si tanto la instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt> como la instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> obedecen
las leyes de los funtores y de las mónadas, estas dos funciones hacen lo mismo
(todas las mónadas que hemos visto cumplen ambas). Es lo mismo que pasaba con
<tt class="docutils literal"><span class="pre">pure</span></tt> y <tt class="docutils literal"><span class="pre">return</span></tt>, solo que una tiene la restricción de clase
<tt class="docutils literal"><span class="pre">Applicative</span></tt> y otra la de <tt class="docutils literal"><span class="pre">Monad</span></tt>. Vamos a probar <tt class="docutils literal"><span class="pre">liftM</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; liftM (*3) (Just 8)</span>
<span class="go">Just 24</span>
<span class="go">ghci&gt; fmap (*3) (Just 8)</span>
<span class="go">Just 24</span>
<span class="go">ghci&gt; runWriter $ liftM not $ Writer (True, &quot;chickpeas&quot;)</span>
<span class="go">(False,&quot;chickpeas&quot;)</span>
<span class="go">ghci&gt; runWriter $ fmap not $ Writer (True, &quot;chickpeas&quot;)</span>
<span class="go">(False,&quot;chickpeas&quot;)</span>
<span class="go">ghci&gt; runState (liftM (+100) pop) [1,2,3,4]</span>
<span class="go">(101,[2,3,4])</span>
<span class="go">ghci&gt; runState (fmap (+100) pop) [1,2,3,4]</span>
<span class="go">(101,[2,3,4])</span>
</pre></div>
</div>
<p>Ya conocemos bastante bien como funciona <tt class="docutils literal"><span class="pre">fmap</span></tt> con los valores el tipo
<tt class="docutils literal"><span class="pre">Maybe</span></tt>. <tt class="docutils literal"><span class="pre">liftM</span></tt> hace lo mismo. Para los valores del tipo <tt class="docutils literal"><span class="pre">Writer</span></tt>, la
función se mapea sobre el primer componente de la dupla, que es el resultado.
Hacer <tt class="docutils literal"><span class="pre">fmap</span></tt> o <tt class="docutils literal"><span class="pre">liftM</span></tt> sobre un cómputo con estado devuelve un nuevo
cómputo con estado, solo que su resultado final se vera modificado por la
función. Si no hubiésemos mapeado <tt class="docutils literal"><span class="pre">(+100)</span></tt> sobre <tt class="docutils literal"><span class="pre">pop</span></tt>, el resulto
hubiese sido <tt class="docutils literal"><span class="pre">(1,[2,3,4])</span></tt>.</p>
<p>Esta es la implementación de <tt class="docutils literal"><span class="pre">liftM</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">liftM</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
<p>O con notación <tt class="docutils literal"><span class="pre">do</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">liftM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">liftM</span> <span class="n">f</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Pasamos el valor monádico <tt class="docutils literal"><span class="pre">m</span></tt> a la función y luego aplicamos la función
<tt class="docutils literal"><span class="pre">f</span></tt> a su resultado, introduciendo el resultado de ésta en el contexto por
defecto. Gracias a las leyes de las mónadas, tenemos garantizado que el
contexto se mantendrá constante, solo se modificará el resultado del valor
monádico. Podemos ver que <tt class="docutils literal"><span class="pre">liftM</span></tt> está implementado sin hacer referencia a
<tt class="docutils literal"><span class="pre">Functor</span></tt>. Esto significa que podemos implementar <tt class="docutils literal"><span class="pre">fmap</span></tt> (o <tt class="docutils literal"><span class="pre">liftM</span></tt>,
depende de ti) utilizando únicamente lo que nos ofrecen las mónadas. Por este
motivo, podemos concluir que las mónadas son más potentes que los funtores
normales.</p>
<p>La clase de tipos <tt class="docutils literal"><span class="pre">Applicative</span></tt> nos permite aplicar funciones entre valores
con un contexto como si se trataran de funciones normales.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Just 5</span>
<span class="go">Just 8</span>
<span class="go">ghci&gt; (+) &lt;$&gt; Just 3 &lt;*&gt; Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Utilizar el estilo aplicativo hace las cosas muy fáciles. <tt class="docutils literal"><span class="pre">&lt;$&gt;</span></tt> es <tt class="docutils literal"><span class="pre">fmap</span></tt>
y <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> es una función de la clase de tipos <tt class="docutils literal"><span class="pre">Applicative</span></tt> que tiene el
siguiente tipo:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div>
</div>
<p>Es parecida a <tt class="docutils literal"><span class="pre">fmap</span></tt>, solo que la función en si misma posee un contexto.
Tenemos que extraer de alguna forma el resultado de <tt class="docutils literal"><span class="pre">f</span> <span class="pre">a</span></tt> para poder mapear
la función sobre ella y luego volver a introducir el resultado en un contexto.
Como todas las funciones de Haskell están currificadas por defecto, podemos
utilizar la combinación de <tt class="docutils literal"><span class="pre">&lt;$&gt;</span></tt> y <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> para aplicar una función sobre
varios parámetros.</p>
<p>De cualquier forma, resulta que al igual que <tt class="docutils literal"><span class="pre">fmap</span></tt>, <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> también puede
ser implementado utilizando lo que nos ofrece la clase de tipos <tt class="docutils literal"><span class="pre">Monad</span></tt>. La
función <tt class="docutils literal"><span class="pre">ap</span></tt> es básicamente <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt>, solo que posee un restricción de clase
<tt class="docutils literal"><span class="pre">Monad</span></tt> en lugar de <tt class="docutils literal"><span class="pre">Applicative</span></tt>. Aquí tienes la definición:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">ap</span> <span class="n">mf</span> <span class="n">m</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">mf</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">m</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">mf</span></tt> es un valor monádico cuyo resultado es una función. Como tanto la
función como el valor están dentro de un contexto, extraemos la función del
contexto y la llamamos <tt class="docutils literal"><span class="pre">f</span></tt>. Luego extraemos el valor y lo llamamos <tt class="docutils literal"><span class="pre">x</span></tt>.
Para terminar aplicamos la función sobre el valor y devolvemos el resultado.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; Just (+3) &lt;*&gt; Just 4</span>
<span class="go">Just 7</span>
<span class="go">ghci&gt; Just (+3) `ap` Just 4</span>
<span class="go">Just 7</span>
<span class="go">ghci&gt; [(+1),(+2),(+3)] &lt;*&gt; [10,11]</span>
<span class="go">[11,12,12,13,13,14]</span>
<span class="go">ghci&gt; [(+1),(+2),(+3)] `ap` [10,11]</span>
<span class="go">[11,12,12,13,13,14]</span>
</pre></div>
</div>
<p>Ahora podemos ver que las mónadas son también más potentes que los funtores
aplicativos, porque podemos utilizar las funciones de <tt class="docutils literal"><span class="pre">Monad</span></tt> para
implementar las de <tt class="docutils literal"><span class="pre">Applicative</span></tt>. De hecho, a menudo la gente cuando sabe
que un tipo es un mónada, primero implementa la instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> y luego
crea la instancia de <tt class="docutils literal"><span class="pre">Applicative</span></tt> simplemente diciendo que <tt class="docutils literal"><span class="pre">pure</span></tt> es
<tt class="docutils literal"><span class="pre">return</span></tt> y <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> es <tt class="docutils literal"><span class="pre">ap</span></tt>. De forma similar, si sabemos que algo tiene
una instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt>, podemos crear la instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt>
simplemente estableciendo que <tt class="docutils literal"><span class="pre">fmap</span></tt> es igual a <tt class="docutils literal"><span class="pre">liftM</span></tt>.</p>
<p>La función <tt class="docutils literal"><span class="pre">liftA2</span></tt> es una función de conveniencia para aplicar una función
entre dos valores aplicativos. Su definición es así de sencilla:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="nf">liftA2</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">y</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">liftM2</span></tt> hace exactamente lo mismo, solo que posee una
restricción de clase <tt class="docutils literal"><span class="pre">Monad</span></tt>. También existe <tt class="docutils literal"><span class="pre">liftM3</span></tt>, <tt class="docutils literal"><span class="pre">liftM4</span></tt> y
<tt class="docutils literal"><span class="pre">liftM5</span></tt>.</p>
<p>Hemos visto como las mónadas son más potentes que los funtores aplicativos y
que los funtores normales y aunque todas las mónadas son también funtores
y funtores aplicativos, no necesariamente poseen una instancia de <tt class="docutils literal"><span class="pre">Functor</span></tt>
y <tt class="docutils literal"><span class="pre">Applicative</span></tt>, y esta es la  razón por la que acabamos de ver las
funciones equivalentes entre los funtores y las mónadas.</p>
</div>
<div class="section" id="la-funcion-join">
<h3>La función <tt class="docutils literal"><span class="pre">join</span></tt><a class="headerlink" href="#la-funcion-join" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Piensa en esto: si el resultado de un valor monádico es otro valor monádico,
es decir, si un valor monádico es anidado dentro de otro, ¿Podemos convertir
ambos en un único valor monádico? Por ejemplo, si tenemos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">9)</span></tt>,
¿Podemos convertirlo en <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">9</span></tt>? Pues resulta que convertir valores
monádicos anidados en valores monádicos simples es una de las propiedades
únicas de las mónadas. Por este motivo tiene su razón de ser la función
<tt class="docutils literal"><span class="pre">join</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">join</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>Toma una un valor monádico que contiene otro valor monádico y devuelve un solo
valor monádico. Aquí tienes un ejemplo de su uso con valores <tt class="docutils literal"><span class="pre">Maybe</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; join (Just (Just 9))</span>
<span class="go">Just 9</span>
<span class="go">ghci&gt; join (Just Nothing)</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; join Nothing</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>La primera línea tiene un cómputo correcto como resultado de otro cómputo
correcto, así que ambos son unido en un solo cómputo correcto. La segunda
línea posee un <tt class="docutils literal"><span class="pre">Nothing</span></tt> como resultado de un valor <tt class="docutils literal"><span class="pre">Just</span></tt>. Antes, cuando
trabajamos con valores <tt class="docutils literal"><span class="pre">Maybe</span></tt> queríamos combinar varios valores en uno, ya
sea con <tt class="docutils literal"><span class="pre">&lt;*&gt;</span></tt> o con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, todos tenían que ser valores <tt class="docutils literal"><span class="pre">Just</span></tt> para que
el resultado fuese también un valor <tt class="docutils literal"><span class="pre">Just</span></tt>. Si existe un fallo en algún
punto del camino, el resultado final será un fallo y lo mismo ocurre aquí. En
la tercera línea, vemos que si intentamos unir un único fallo, el resultado
es también un fallo.</p>
<p>Unir, o aplanar listas es bastante intuitivo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; join [[1,2,3],[4,5,6]]</span>
<span class="go">[1,2,3,4,5,6]</span>
</pre></div>
</div>
<p>Como puedes ver, para listas <tt class="docutils literal"><span class="pre">join</span></tt> es igual que <tt class="docutils literal"><span class="pre">concat</span></tt>. Para unir un
valor <tt class="docutils literal"><span class="pre">Writer</span></tt> cuyo resultado es también un valor <tt class="docutils literal"><span class="pre">Writer</span></tt> tenemos que
aplicar <tt class="docutils literal"><span class="pre">mappend</span></tt> al valor monádico.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runWriter $ join (Writer (Writer (1,&quot;aaa&quot;),&quot;bbb&quot;))</span>
<span class="go">(1,&quot;bbbaaa&quot;)</span>
</pre></div>
</div>
<p>El valor monádico exterior <tt class="docutils literal"><span class="pre">&quot;bbb&quot;</span></tt> se utiliza primero y luego se le añade
<tt class="docutils literal"><span class="pre">&quot;aaa&quot;</span></tt>. Dicho de otra forma, cuando queremos examinar el resultado de un
valor <tt class="docutils literal"><span class="pre">Writer</span></tt>, primero tenemos que actualizar su registro y solo después de
esto podremos examinar sus contenidos.</p>
<p>Unir valores <tt class="docutils literal"><span class="pre">Either</span></tt> es muy parecido a unir valores <tt class="docutils literal"><span class="pre">Maybe</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; join (Right (Right 9)) :: Either String Int</span>
<span class="go">Right 9</span>
<span class="go">ghci&gt; join (Right (Left &quot;error&quot;)) :: Either String Int</span>
<span class="go">Left &quot;error&quot;</span>
<span class="go">ghci&gt; join (Left &quot;error&quot;) :: Either String Int</span>
<span class="go">Left &quot;error&quot;</span>
</pre></div>
</div>
<p>Si aplicamos <tt class="docutils literal"><span class="pre">join</span></tt> a un cómputo cuyo resultado sea otro cómputo con
estado, el resultado será un cómputo con estado que primero ejecutará el
cómputo exterior y luego el interior. Mira:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; runState (join (State $ \s -&gt; (push 10,1:2:s))) [0,0,0]</span>
<span class="go">((),[10,1,2,0,0,0])</span>
</pre></div>
</div>
<p>Aquí la función lambda toma un estado y apila <tt class="docutils literal"><span class="pre">2</span></tt> y <tt class="docutils literal"><span class="pre">1</span></tt> sobre la pila
y devuelve como resultado <tt class="docutils literal"><span class="pre">push</span> <span class="pre">10</span></tt>, que es otro computo con estado. Así que
cuando todo esto se une con <tt class="docutils literal"><span class="pre">join</span></tt> y luego se ejecuta, primero se apila
<tt class="docutils literal"><span class="pre">2</span></tt> y <tt class="docutils literal"><span class="pre">1</span></tt> y luego se ejecuta <tt class="docutils literal"><span class="pre">push</span> <span class="pre">10</span></tt>, poniendo así <tt class="docutils literal"><span class="pre">10</span></tt> en la cima
de la pila.</p>
<p>La implementación de <tt class="docutils literal"><span class="pre">join</span></tt> es la siguiente:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">join</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="nf">join</span> <span class="n">mm</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">mm</span>
    <span class="n">m</span>
</pre></div>
</div>
<p>Como el resultado de <tt class="docutils literal"><span class="pre">mm</span></tt> es un valor monádico, obtenemos ese resultado y
luego simplemente lo ponemos solo en la última línea porque por si solo ya es
un valor monádico. El truco aquí esta en <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&lt;-</span> <span class="pre">mm</span></tt>, el contexto de la mónada
de la que estamos obteniendo un resultado se tiene en cuenta. Por este motivo,
por ejemplo, los valores <tt class="docutils literal"><span class="pre">Maybe</span></tt> solo devuelven <tt class="docutils literal"><span class="pre">Just</span></tt> cuando tanto el
valor exterior como el valor interior son ambos <tt class="docutils literal"><span class="pre">Just</span></tt>. Así se vería esto
si <tt class="docutils literal"><span class="pre">mm</span></tt> fuera desde el principio <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">8)</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">joinedMaybes</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">joinedMaybes</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">m</span>
</pre></div>
</div>
<img alt="¡Incluso yo soy un ajente de la ley!" class="align-right" src="../_images/tipi.png" />
<p>Quizá lo más interesante de <tt class="docutils literal"><span class="pre">join</span></tt> es que funciona para cualquier mónada,
pasar un valor monádico a una función con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> es lo mismo que mapear esa
función sobre el valor monádico y luego utilizar <tt class="docutils literal"><span class="pre">join</span></tt> para unir el
resultado. Dicho de otro modo, <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></tt> es siempre igual que
<tt class="docutils literal"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></tt>. Vale la pena que le dediques un poco de atención. Con
<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, siempre pensamos que estamos pasando un valor monádico a una función
que toma un valor normal pero devuelve un valor monádico. Si mapeamos
directamente la función sobre el valor monádico, tendremos un valor como
resultado un valor monádico dentro de otro valor monádico. Por ejemplo,
digamos que tenemos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">9</span></tt> y la función <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">Just</span> <span class="pre">(x+1)</span></tt>. Si mapeamos
esta función sobre <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">9</span></tt> nos dará como resultado <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">(Just</span> <span class="pre">10)</span></tt>.</p>
<p>El hecho de que <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></tt> sea siempre igual a <tt class="docutils literal"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></tt> es muy
útil porque si estamos creando una instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt> para un tipo,
siempre es más fácil averiguar como se deben unir dos valores monádicos
anidados que averiguar como implementar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>.</p>
</div>
<div class="section" id="filterm">
<h3>filterM<a class="headerlink" href="#filterm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La función <tt class="docutils literal"><span class="pre">filter</span></tt> junto a la función <tt class="docutils literal"><span class="pre">map</span></tt> son de las funciones más
utilizadas en Haskell. Toma un predicado y una lista y la filtra de forma que
la lista resultante solo contenga los resultados que satisfagan el predicado.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>El predicado toma un elemento de la lista y devuelve un valor <tt class="docutils literal"><span class="pre">Bool</span></tt>. Pero,
¿y si el valor <tt class="docutils literal"><span class="pre">Bool</span></tt> que devuelve el predicado fuera en realidad un valor
monádico? ¿¡Qué!? En otras palabras, ¿y si el resultado tuviera un contexto?
¿Podría funcionar? Por ejemplo, ¿qué pasaría ti todos los valores <tt class="xref docutils literal"><span class="pre">True</span></tt> y
<tt class="xref docutils literal"><span class="pre">False</span></tt> que el predicado produce vienen acompañados de un valor monádico
como <tt class="docutils literal"><span class="pre">[&quot;Número</span> <span class="pre">5</span> <span class="pre">aceptado&quot;]</span></tt> o <tt class="docutils literal"><span class="pre">[&quot;3</span> <span class="pre">es</span> <span class="pre">muy</span> <span class="pre">pequeño&quot;]</span></tt>? Dicho así podría
funcionar. Si ese fuera el caso, cabe esperar que la lista resultante venga
con un registro que contenga el registro de todos los valores que se han
ido produciendo. Así que si el valor <tt class="docutils literal"><span class="pre">Bool</span></tt> que produce el resultado viene
con un contexto, lo normal es que la lista resultante también venga con
un contexto, de otro modo el contexto de cada <tt class="docutils literal"><span class="pre">Bool</span></tt> se perdería.</p>
<p>La función <tt class="docutils literal"><span class="pre">filterM</span></tt> de <tt class="docutils literal"><span class="pre">Control.Monad</span></tt> hace exactamente lo que estamos
buscando.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">filterM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>El predicado devuelve un valor monádico cuyo resultado es un <tt class="docutils literal"><span class="pre">Bool</span></tt>, pero
como es un valor monádico, su contexto puede ser cualquier cosa, desde un
fallo hasta un no determinismo. Para asegurarnos de que el resultado final
refleja el contexto, el resultado también debe ser un valor monádico.</p>
<p>Vamos a tomar una lista y vamos a filtrarla de forma que solo nos quedemos con
los números que sean menores que 4. Para empezar, vamos a utilizar la función
normal <tt class="docutils literal"><span class="pre">filter</span></tt>:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; filter (\x -&gt; x &lt; 4) [9,1,5,2,10,3]</span>
<span class="go">[1,2,3]</span>
</pre></div>
</div>
<p>Muy fácil. Ahora, vamos hacer que este predicado, además de devolver
<tt class="xref docutils literal"><span class="pre">True</span></tt> o <tt class="xref docutils literal"><span class="pre">False</span></tt>, también adjunte un registro indicando lo que ha hecho.
Por supuesto vamos a utilizar la mónada <tt class="docutils literal"><span class="pre">Writer</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">keepSmall</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Writer</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="kt">Bool</span>
<span class="nf">keepSmall</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="s">&quot;Keeping &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">return</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">tell</span> <span class="p">[</span><span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; is too large, throwing it away&quot;</span><span class="p">]</span>
        <span class="n">return</span> <span class="kt">False</span>
</pre></div>
</div>
<p>En lugar de devolver un <tt class="docutils literal"><span class="pre">Bool</span></tt>, esta función devuelve un
<tt class="docutils literal"><span class="pre">Writer</span> <span class="pre">[String]</span> <span class="pre">Bool</span></tt>. Es un predicado monádico. Suena excesivo, ¿no crees?
Si el número es menor que <tt class="docutils literal"><span class="pre">4</span></tt> registramos que lo vamos a mantener y
luego hacemos <tt class="docutils literal"><span class="pre">return</span> <span class="pre">True</span></tt>.</p>
<p>Ahora vamos a utilizar <tt class="docutils literal"><span class="pre">filterM</span></tt> con una lista. Como el predicado devuelve
un valor <tt class="docutils literal"><span class="pre">Writer</span></tt>, el resultado de la lista será también un valor
<tt class="docutils literal"><span class="pre">Writer</span></tt>.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; fst $ runWriter $ filterM keepSmall [9,1,5,2,10,3]</span>
<span class="go">[1,2,3]</span>
</pre></div>
</div>
<p>Examinando el resultado del valor de tipo <tt class="docutils literal"><span class="pre">Writer</span></tt> vemos que todo está en
orden. Ahora, vamos a mostrar el registro:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; mapM_ putStrLn $ snd $ runWriter $ filterM keepSmall [9,1,5,2,10,3]</span>
<span class="go">9 is too large, throwing it away</span>
<span class="go">Keeping 1</span>
<span class="go">5 is too large, throwing it away</span>
<span class="go">Keeping 2</span>
<span class="go">10 is too large, throwing it away</span>
<span class="go">Keeping 3</span>
</pre></div>
</div>
<p>Increíble. Simplemente utilizando un predicado monádico con <tt class="docutils literal"><span class="pre">filterM</span></tt> somos
capaces de filtrar una lista a la vez que mantenemos el contexto del que
estamos utilizando.</p>
<p>Existe un truco en Haskell para obtener el superconjunto de una lista (si
vemos las listas como un conjunto). El superconjunto de un conjunto es un
conjunto de todos los posible subconjuntos de éste. Así que si tenemos un
conjunto como <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>, su superconjunto incluirá los siguientes
conjuntos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div>
</div>
<p>En otras palabras, obtener el superconjunto es como obtener todas las posibles
combinaciones de mantener o eliminar elementos de un conjunto. <tt class="docutils literal"><span class="pre">[2,3]</span></tt> sería
el conjunto original al que hemos eliminado el número <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>Para crear una función que devuelva el superconjunto de una lista vamos a
utilizar el no determinismo. Tomamos una lista como <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt> y luego
miramos el primer elemento, que es <tt class="docutils literal"><span class="pre">1</span></tt>, y nos preguntamos: ¿lo debemos
mantener o lo debemos eliminar? Bueno, en realidad queremos hacer ambas cosas.
Resumiendo, vamos a filtrar una lista y vamos a un utilizar un predicado no
determinista que elimine y mantenga cada elemento de la lista.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">powerset</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">powerset</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">filterM</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">])</span> <span class="n">xs</span>
</pre></div>
</div>
<p>¿Qué es esto? Bueno, elegimos eliminar y mantener cada elemento,
independientemente del valor de dicho elemento. Tenemos un predicado no
determinista, así que el resultado también será no determinista y por lo tanto
su tipo será una lista de listas. Vamos a probarlo.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; powerset [1,2,3]</span>
<span class="go">[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]</span>
</pre></div>
</div>
<p>Quizá esto puede que no se entienda a la primera, pero si consideramos las
listas como valores no deterministas que no saben que valor escoger y por
tanto deciden ser todos a la vez, es más fácil de ver.</p>
</div>
<div class="section" id="foldm">
<h3><tt class="docutils literal"><span class="pre">foldM</span></tt><a class="headerlink" href="#foldm" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La versión monádica de <tt class="docutils literal"><span class="pre">foldl</span></tt> es <tt class="docutils literal"><span class="pre">foldM</span></tt>. Si recuerdas bien los
<a class="reference internal" href="OrdenSuperior.html#pliegues"><em>pliegues</em></a>, sabrás que <tt class="docutils literal"><span class="pre">foldl</span></tt> toma una función binaria,
un acumulador inicial y una lista y pliega la lista desde la izquierda
reduciendo la lista a un solo valor. <tt class="docutils literal"><span class="pre">foldM</span></tt> hace básicamente lo mismo, solo
que toma una función binaria que devuelve un valor monádico.
Sorprendentemente, el resultado final también es un valor monádico. La
declaración de tipo de <tt class="docutils literal"><span class="pre">foldl</span></tt> es:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>Mientras que la de <tt class="docutils literal"><span class="pre">foldM</span></tt> es:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foldM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>El valor que devuelve la función binaria es un valor monádico por lo tanto
el valor final del pliegue también lo es. Vamos a sumar una lista de números
con un pliegue:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; foldl (\acc x -&gt; acc + x) 0 [2,8,3,1]</span>
<span class="go">14</span>
</pre></div>
</div>
<p>El acumulador inicial es <tt class="docutils literal"><span class="pre">0</span></tt> y luego se suma <tt class="docutils literal"><span class="pre">2</span></tt> al acumulador, el
resultado pasa a ser el nuevo acumulador que tiene un valor de <tt class="docutils literal"><span class="pre">2</span></tt>. Luego
se suma <tt class="docutils literal"><span class="pre">8</span></tt> al acumulador devolviendo así <tt class="docutils literal"><span class="pre">10</span></tt> que pasa a ser el nuevo
acumulador y así hasta que alcance el final de la lista, donde el acumulador
final será el resultado final de la función.</p>
<p>¿Y si queremos sumar una lista de números y además queremos añadir la
condición de que si en la lista existe un número mayor a <tt class="docutils literal"><span class="pre">9</span></tt>, todo el
cómputo falle? Tendría sentido utilizar la función binaria para comprobar si
el número actual es mayor que <tt class="docutils literal"><span class="pre">9</span></tt> y si lo es, falle, y si no continúe.
Debido a esta nueva posibilidad de fallo, vamos a hacer que la función binaria
devuelva un acumulador dentro de un tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> en lugar de un acumulador
normal. Así sería la función binaria:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">binSmalls</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">binSmalls</span> <span class="n">acc</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">9</span>     <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Como la función binaria es ahora una función monádica, ya no podemos utilizar
un pliegue normal como <tt class="docutils literal"><span class="pre">foldl</span></tt>, tendremos que usar un pliegue monádico.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; foldM binSmalls 0 [2,8,3,1]</span>
<span class="go">Just 14</span>
<span class="go">ghci&gt; foldM binSmalls 0 [2,11,3,1]</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>¡Genial! Como había un número mayor que <tt class="docutils literal"><span class="pre">9</span></tt>, el resultado final fue
<tt class="docutils literal"><span class="pre">Nothing</span></tt>. También es útil realizar un pliegue con una función binaria que
devuelva un valor <tt class="docutils literal"><span class="pre">Writer</span></tt>, ya que de este modo podemos obtener un registro
conforme recorremos la lista.</p>
</div>
<div class="section" id="creando-una-version-segura-de-la-calculadora-rpn">
<h3>Creando una versión segura de la calculadora RPN<a class="headerlink" href="#creando-una-version-segura-de-la-calculadora-rpn" title="Enlazar permanentemente con este título">¶</a></h3>
<img alt="¡Encontré oro!" class="align-left" src="../_images/miner.png" />
<p>Cuando estábamos solucionando el problema de implementar la
<a class="reference internal" href="Problemas.html#rpn"><em>calculadora RPN</em></a>, vimos que funcionaría bien siempre y cuando la
entrada tuviera sentido. Pero si algo iba mal, el programa entero terminaba.
Ahora que ya sabemos como convertir código en su versión monádica, vamos a
hacer una versión de la calculador RPN más segura ayudándonos de la mónada
<tt class="docutils literal"><span class="pre">Maybe</span></tt>.</p>
<p>Implementamos la calculadora RPN de forma que tomaba una cadena, como
<tt class="docutils literal"><span class="pre">&quot;1</span> <span class="pre">3</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*&quot;</span></tt>, la dividiera en palabras para obtener algo como
<tt class="docutils literal"><span class="pre">[&quot;1&quot;,&quot;3&quot;,&quot;+&quot;,&quot;2&quot;,&quot;*&quot;]</span></tt> y luego la plegara utilizando como acumulador
inicial una pila vacía y una función binaria que apilaba números en la pila,
o sumaba los dos elementos superiores, o los dividía, etc.</p>
<p>Este era la función principal:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">solveRPN</span> <span class="ow">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="o">.</span> <span class="n">words</span>
</pre></div>
</div>
<p>Convertíamos la expresión en una lista de cadenas, la plegábamos utilizando
una función binaria y luego devolvíamos el único elemento que quedaba en la
pila. Así era la función binaria:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span>
<span class="nf">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="kt">:</span><span class="n">xs</span>
</pre></div>
</div>
<p>En este caso el acumulador del pliegue era la pila, la cual representábamos
como una lista de valores <tt class="docutils literal"><span class="pre">Double</span></tt>. Conforme la función de pliegue avanzaba
por la expresión RPN, si el elemento actual era un operador, obteníamos los
dos elementos superiores de la pila, aplicábamos el operador y luego
apilábamos el resultado de nuevo. Si el elemento actual era una cadena que
representaba un número, convertíamos la cadena en un número real y lo
apilábamos.</p>
<p>Primero vamos a hacer que esta función pueda fallar de forma correcta. Su
declaración de tipo cambiará de esta forma:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
</pre></div>
</div>
<p>Así que ahora su resultado será o bien un valor <tt class="docutils literal"><span class="pre">Just</span></tt> con una pila o bien
fallará con <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
<p>La función <tt class="docutils literal"><span class="pre">reads</span></tt> es igual que <tt class="docutils literal"><span class="pre">read</span></tt>, solo que devuelve una lista con
un único elemento en caso de que tenga éxito. Si no puede leer algo, devuelve
una lista vacía. Aparte de devolver el valor que lee, también devuelve la
parte de la cadena que no ha consumido. Vamos a decir que siempre tiene que
leer toda la cadena para que funcione correctamente y vamos a crear una
función <tt class="docutils literal"><span class="pre">readMaybe</span></tt> por conveniencia.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">readMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">readMaybe</span> <span class="n">st</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">reads</span> <span class="n">st</span> <span class="kr">of</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">x</span>
                                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>La probamos:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; readMaybe &quot;1&quot; :: Maybe Int</span>
<span class="go">Just 1</span>
<span class="go">ghci&gt; readMaybe &quot;GO TO HELL&quot; :: Maybe Int</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>Vale, parece que funciona. Ahora vamos a convertir la función binaria en
una función binaria que puede fallar.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">foldingFunction</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Double</span><span class="p">]</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;+&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="s">&quot;-&quot;</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">((</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">readMaybe</span> <span class="n">numberString</span><span class="p">)</span>
<span class="nf">foldingFunction</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">fail</span> <span class="s">&quot;¡whops!&quot;</span>
</pre></div>
</div>
<p>Los primeros tres casos son iguales que los originales, solo que ahora la
pila nueva se introduce en <tt class="docutils literal"><span class="pre">Just</span></tt> (hemos utilizado <tt class="docutils literal"><span class="pre">return</span></tt> para lograrlo,
pero podíamos haber utilizado simplemente <tt class="docutils literal"><span class="pre">Just</span></tt> también). En el cuarto
caso, hacemos <tt class="docutils literal"><span class="pre">readMaybe</span> <span class="pre">numberString</span></tt> y luego mapeamos <tt class="docutils literal"><span class="pre">(:xs)</span></tt> sobre su
resultado. Es decir, si la pila <tt class="docutils literal"><span class="pre">xs</span></tt> es <tt class="docutils literal"><span class="pre">[1.0,2.0]</span></tt> y
<tt class="docutils literal"><span class="pre">readMaybe</span> <span class="pre">numberString</span></tt> devuelve <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">3.0</span></tt>, el resultado será
<tt class="docutils literal"><span class="pre">[1.0,2.0,3.0]</span></tt>. Si <tt class="docutils literal"><span class="pre">readMaybe</span> <span class="pre">numberString</span></tt> devuelve <tt class="docutils literal"><span class="pre">Nothing</span></tt> el
resultado final será <tt class="docutils literal"><span class="pre">Nothing</span></tt>. Vamos a probar esta función:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; foldingFunction [3,2] &quot;*&quot;</span>
<span class="go">Just [6.0]</span>
<span class="go">ghci&gt; foldingFunction [3,2] &quot;-&quot;</span>
<span class="go">Just [-1.0]</span>
<span class="go">ghci&gt; foldingFunction [] &quot;*&quot;</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; foldingFunction [] &quot;1&quot;</span>
<span class="go">Just [1.0]</span>
<span class="go">ghci&gt; foldingFunction [] &quot;1 wawawawa&quot;</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>¡Parece que funciona! Ahora es hora de mejorar la función <tt class="docutils literal"><span class="pre">solveRPN</span></tt> ¡Aquí
la tienen!</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">solveRPN</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="nf">solveRPN</span> <span class="n">st</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="p">[</span><span class="n">result</span><span class="p">]</span> <span class="ow">&lt;-</span> <span class="n">foldM</span> <span class="n">foldingFunction</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">words</span> <span class="n">st</span><span class="p">)</span>
    <span class="n">return</span> <span class="n">result</span>
</pre></div>
</div>
<p>Al igual que antes, tomamos una cadena y la dividimos en palabras. Luego,
realizamos el pliegue, empezando con una pila vacía, solo que en lugar de
realizar un pliegue normal con <tt class="docutils literal"><span class="pre">foldl</span></tt> utilizamos <tt class="docutils literal"><span class="pre">foldM</span></tt>. El resultado
de <tt class="docutils literal"><span class="pre">foldM</span></tt> debe ser un valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt> que contendrá una lista
(es decir, la pila final) que a su vez solo debería contener un valor.
Utilizamos una expresión <tt class="docutils literal"><span class="pre">do</span></tt> para obtener el valor y lo llamamos
<tt class="docutils literal"><span class="pre">result</span></tt>. En caso de que <tt class="docutils literal"><span class="pre">foldM</span></tt> devuelva <tt class="docutils literal"><span class="pre">Nothing</span></tt>, el resultado final
será <tt class="docutils literal"><span class="pre">Nothing</span></tt>, porque así es como funciona la mónada <tt class="docutils literal"><span class="pre">Maybe</span></tt>. Fíjate
también en el ajuste del patrón en el interior de la expresión <tt class="docutils literal"><span class="pre">do</span></tt>, de esta
forma si la lista tiene más de un solo o ningún elemento, el ajuste fallará
y se producirá un <tt class="docutils literal"><span class="pre">Nothing</span></tt>. En la última línea simplemente hacemos
<tt class="docutils literal"><span class="pre">return</span> <span class="pre">result</span></tt> para devolver el resultado de la expresión RPN dentro de un
valor del tipo <tt class="docutils literal"><span class="pre">Maybe</span></tt>.</p>
<p>Probémoslo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; solveRPN &quot;1 2 * 4 +&quot;</span>
<span class="go">Just 6.0</span>
<span class="go">ghci&gt; solveRPN &quot;1 2 * 4 + 5 *&quot;</span>
<span class="go">Just 30.0</span>
<span class="go">ghci&gt; solveRPN &quot;1 2 * 4&quot;</span>
<span class="go">Nothing</span>
<span class="go">ghci&gt; solveRPN &quot;1 8 wharglbllargh&quot;</span>
<span class="go">Nothing</span>
</pre></div>
</div>
<p>El primer fallo sucede porque la pila final no contiene un único elemento y
por tanto el ajuste de patrones contenido en la expresión <tt class="docutils literal"><span class="pre">do</span></tt> falla. El
segundo fallo se debe a que <tt class="docutils literal"><span class="pre">readMaybe</span></tt> devuelve <tt class="docutils literal"><span class="pre">Nothing</span></tt>.</p>
</div>
<div class="section" id="componiendo-funciones-monadicas">
<h3>Componiendo funciones monádicas<a class="headerlink" href="#componiendo-funciones-monadicas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cuando hablamos de las leyes de las mónadas, vimos que la función <tt class="docutils literal"><span class="pre">&lt;=&lt;</span></tt> era
parecida a la composición de funciones, solo que en lugar de tratar con
funciones normales <tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">b</span></tt>, funcionaba con funciones monádicas como
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">b</span></tt>. Por ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let f = (+1) . (*100)</span>
<span class="go">ghci&gt; f 4</span>
<span class="go">401</span>
<span class="go">ghci&gt; let g = (\x -&gt; return (x+1)) &lt;=&lt; (\x -&gt; return (x*100))</span>
<span class="go">ghci&gt; Just 4 &gt;&gt;= g</span>
<span class="go">Just 401</span>
</pre></div>
</div>
<p>En este ejemplo primero componemos dos funciones normales, y luego las
aplicamos la función resultante a <tt class="docutils literal"><span class="pre">4</span></tt>. Luego componemos dos funciones
monádicas, y luego le pasamos <tt class="docutils literal"><span class="pre">Just</span> <span class="pre">4</span></tt> a la función resultante utilizando
<tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>.</p>
<p>Si tenemos una lista de funciones, podemos componerlas en una sola gran
función utilizando <tt class="docutils literal"><span class="pre">id</span></tt> como acumulador inicial y la función <tt class="docutils literal"><span class="pre">.</span></tt> como
función binaria. O también utilizando la función <tt class="docutils literal"><span class="pre">foldr1</span></tt>. Aquí tienes un
ejemplo:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; let f = foldr (.) id [(+1),(*100),(+1)]</span>
<span class="go">ghci&gt; let g = foldr1 (.) [(+1),(*100),(+1)]</span>
<span class="go">ghci&gt; f 1</span>
<span class="go">201</span>
<span class="go">ghci&gt; g 1</span>
<span class="go">201</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">f</span></tt> toma un número y luego le suma <tt class="docutils literal"><span class="pre">1</span></tt>, luego multiplica el
resultado por <tt class="docutils literal"><span class="pre">100</span></tt> y luego le suma <tt class="docutils literal"><span class="pre">1</span></tt> al resultado anterior. De
todos modos, podemos componer funciones monádicas de la misma forma, solo que
en lugar de utilizar una composición de funciones normal utilizamos <tt class="docutils literal"><span class="pre">&lt;=&lt;</span></tt>, y
en lugar de utilizar <tt class="docutils literal"><span class="pre">id</span></tt> utilizamos <tt class="docutils literal"><span class="pre">return</span></tt>. No tenemos que utilizar
<tt class="docutils literal"><span class="pre">foldM</span></tt> en lugar de <tt class="docutils literal"><span class="pre">foldr</span></tt> ya que <tt class="docutils literal"><span class="pre">&lt;=&lt;</span></tt> se encarga de que la
composición sea monádica.</p>
<p>Cuando vimos la mónada lista en el <a class="reference internal" href="Monadas.html#mlista"><em>capítulo anterior</em></a>, la
utilizamos para encontrar a qué posiciones podía desplazarse un caballo en
un tablero de ajedrez con exactamente tres movimientos. Teníamos una función
que se llamaba <tt class="docutils literal"><span class="pre">moveKnight</span></tt>, la cual tomaba la posición en el tablero del
caballo y devolvía todos los posibles movimientos que podía tomar. Luego,
para generar todos los posibles posiciones que podía alcanzar en tres
movimientos utilizábamos una función como estas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">in3</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">start</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span> <span class="o">&gt;&gt;=</span> <span class="n">moveKnight</span>
</pre></div>
</div>
<p>Y para comprobar si el caballo podía llegar desde <tt class="docutils literal"><span class="pre">start</span></tt> hasta <tt class="docutils literal"><span class="pre">end</span></tt> en
tres movimientos utilizábamos:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">canReachIn3</span> <span class="ow">::</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">canReachIn3</span> <span class="n">start</span> <span class="n">end</span> <span class="ow">=</span> <span class="n">end</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">in3</span> <span class="n">start</span>
</pre></div>
</div>
<p>Utilizando la composición de funciones podemos crear una función como <tt class="docutils literal"><span class="pre">in3</span></tt>,
solo que en lugar de generar todas las posibles soluciones que puede alcanzar
el caballo en tres movimientos, podemos hacerlo para un número arbitrario de
movimientos. Si nos fijamos en <tt class="docutils literal"><span class="pre">in3</span></tt>, vemos que hemos utilizado
<tt class="docutils literal"><span class="pre">moveKnight</span></tt> tres veces y hemos utilizado <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> en cada paso para pasar
las posibles posiciones anteriores. Ahora vamos a hacerlo más general.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">inMany</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">KnightPos</span><span class="p">]</span>
<span class="nf">inMany</span> <span class="n">x</span> <span class="n">start</span> <span class="ow">=</span> <span class="n">return</span> <span class="n">start</span> <span class="o">&gt;&gt;=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&lt;=&lt;</span><span class="p">)</span> <span class="n">return</span> <span class="p">(</span><span class="n">replicate</span> <span class="n">x</span> <span class="n">moveKnight</span><span class="p">)</span>
</pre></div>
</div>
<p>Primero utilizamos <tt class="docutils literal"><span class="pre">replicate</span></tt> para crear una lista que contenga <tt class="docutils literal"><span class="pre">x</span></tt>
veces la función <tt class="docutils literal"><span class="pre">moveKnight</span></tt>. Luego, componemos monádicamente todas esas
funciones en una, lo cual resulta en una función que toma una posición incial
y mueve el caballo de forma no determinista <tt class="docutils literal"><span class="pre">x</span></tt> veces. Luego, simplemente
creamos una lista unitaria con la posición inicial con <tt class="docutils literal"><span class="pre">return</span></tt> y se la
pasamos a la función.</p>
<p>Ahora también podemos cambiar la función <tt class="docutils literal"><span class="pre">canReachIn3</span></tt> para que sea más
general:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">canReachIn</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">KnightPos</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">canReachIn</span> <span class="n">x</span> <span class="n">start</span> <span class="n">end</span> <span class="ow">=</span> <span class="n">end</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">inMany</span> <span class="n">x</span> <span class="n">start</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creando-monadas">
<h2>Creando mónadas<a class="headerlink" href="#creando-monadas" title="Enlazar permanentemente con este título">¶</a></h2>
<img alt="kewl" class="align-center" src="../_images/spearhead.png" />
<p>En esta sección vamos a ver un ejemplo de como se crea un tipo, como se
identifica que se trata de una mónada y luego como darle una instancia
<tt class="docutils literal"><span class="pre">Monad</span></tt> apropiada. Normalmente no nos ponemos a crear una mónada por el
simple hecho de crear mónadas. En lugar de ello, solemos crear un tipo con el
propósito de modelar un aspecto de algún problema y luego si vemos que ese
tipo representa valores con un contexto y puede comportarse como una mónada,
le damos una instancia de <tt class="docutils literal"><span class="pre">Monad</span></tt>.</p>
<p>Como ya hemos visto, las listas se utilizan para representar valores
no deterministas. Una lista como <tt class="docutils literal"><span class="pre">[3,5,9]</span></tt> puede ser vista como un solo
valor no determinista que no puede decidir que valor ser. Cuando pasamos una
lista a una función con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>, simplemente crea todas las posibilidades
de tomar un elemento concreto de la lista y le aplica la función, de forma que
los resultados que produzca aparezcan en el resultado final.</p>
<p>Si vemos la lista <tt class="docutils literal"><span class="pre">[3,5,9]</span></tt> como los número <tt class="docutils literal"><span class="pre">3</span></tt>, <tt class="docutils literal"><span class="pre">5</span></tt> y <tt class="docutils literal"><span class="pre">9</span></tt> al mismo
tiempo, podemos darnos cuenta de que no tenemos ninguna información de la
probabilidad de que esos números aparezcan. ¿y si quisiéramos un modelar un
valor no determinista como <tt class="docutils literal"><span class="pre">[3,5,9]</span></tt>, pero que expresará también que <tt class="docutils literal"><span class="pre">3</span></tt>
tiene un 50% probabilidades de ocurrir y <tt class="docutils literal"><span class="pre">5</span></tt> y <tt class="docutils literal"><span class="pre">9</span></tt> tienen un 25% de
probabilidades? Es una pregunta muy larga, lo se, pero vamos a buscar una
respuesta.</p>
<p>Digamos que cada elemento de la lista va acompañado de otro valor, la
probabilidad de que ocurra. Podría tener sentido representarlo así:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">[(3,0.5),(5,0.25),(9,0.25)]</span>
</pre></div>
</div>
<p>En las matemáticas, las probabilidades no se suelen representar con
porcentajes sino con valores reales que van desde el 0 hasta el 1. Un 0
significa que no hay ninguna posibilidad de que ocurra un suceso mientras que
un 1 representa que el suceso va ocurrir sí o sí. Los número en coma flotante
pueden ser muy eficientes ya que tienden a perder precisión, así que Haskell
nos ofrece un tipo de dato para los números racionales de forma que no pierda
precisión. Este tipo se llama <tt class="docutils literal"><span class="pre">Rational</span></tt> y reside en el módulo
<tt class="docutils literal"><span class="pre">Data.Ratio</span></tt>. Para crear un número del tipo <tt class="docutils literal"><span class="pre">Rational</span></tt> lo escribimos en
forma de fracción. Separamos el numerador y el denominador por <tt class="docutils literal"><span class="pre">%</span></tt>. Aquí
tienes unos ejemplos:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; 1%4</span>
<span class="go">1 % 4</span>
<span class="go">ghci&gt; 1%2 + 1%2</span>
<span class="go">1 % 1</span>
<span class="go">ghci&gt; 1%3 + 5%4</span>
<span class="go">19 % 12</span>
</pre></div>
</div>
<p>La primera línea representa un cuarto. En la segunda línea sumamos dos
medios y obtenemos la unidad y en la tercera línea sumamos un tercero a
cinco cuartos y obtenemos diecinueve docenas de huevos. Vamos a utilizar
número <tt class="docutils literal"><span class="pre">Rational</span></tt> en lugar de números en coma flotante para representar las
probabilidades.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; [(3,1%2),(5,1%4),(9,1%4)]</span>
<span class="go">[(3,1 % 2),(5,1 % 4),(9,1 % 4)]</span>
</pre></div>
</div>
<p>Vale, <tt class="docutils literal"><span class="pre">3</span></tt> tiene la mitad de posibilidades de ocurrir y <tt class="docutils literal"><span class="pre">5</span></tt> y <tt class="docutils literal"><span class="pre">9</span></tt> tienen
un cuarto de posibilidades de salir. Muy bonito.</p>
<p>Tomamos las listas y les añadimos un contexto adicional, así que esto también
representa valores en cierto contexto. Antes de continuar, vamos representar
esto con <tt class="docutils literal"><span class="pre">newtype</span></tt> porque algo me dice que vamos a crear alguna instancias.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Ratio</span>

<span class="kr">newtype</span> <span class="kt">Prob</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">{</span> <span class="n">getProb</span> <span class="ow">::</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="kt">Rational</span><span class="p">)]</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Show</span>
</pre></div>
</div>
<p>Muy bien ¿Esto es un funtor? Bueno, la lista es un funtor, así que
probablemente esto sea un funtor también ya que solo hemos añadido algo más
de contexto. Cuando mapeamos una función sobre una lista, la aplicamos a todos
los elementos. Ahora también aplicaremos la función a todos los elementos,
solo que mantendremos las probabilidades intactas.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Prob</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">))</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Extraemos el valor del <tt class="docutils literal"><span class="pre">newtype</span></tt> utilizando un ajuste de patrones, aplicamos
la función <tt class="docutils literal"><span class="pre">f</span></tt> a los valores mientras nos aseguramos de mantener constantes
las probabilidades. Vamos a ver si funciona:</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; fmap negate (Prob [(3,1%2),(5,1%4),(9,1%4)])</span>
<span class="go">Prob {getProb = [(-3,1 % 2),(-5,1 % 4),(-9,1 % 4)]}</span>
</pre></div>
</div>
<p>Otra cosa que tenemos que tener en cuenta es que todas estas probabilidades
deben sumar <tt class="docutils literal"><span class="pre">1</span></tt>. Si todo esto son cosas que pueden ocurrir, no tiene sentido
que la suma de sus probabilidades sea distinta de <tt class="docutils literal"><span class="pre">1</span></tt>. Una moneda que al
lanzarla salga un 75% de las veces cruz y un 50% de las veces caras es algo
que solo podría en otro extraño universo.</p>
<p>Ahora, la gran pregunta, ¿es una mónada? Dado que las listas son mónadas,
parece que esto puede también puede ser una mónada. Primero vamos a pensar
en <tt class="docutils literal"><span class="pre">return</span></tt> ¿Cómo funciona con las listas? Toma un valor y crea una lista
unitaria que lo contenga ¿Qué sucederá aquí? Bueno, como se supone que es el
contexto mínimo por defecto, también creará una lista unitaria ¿Qué hay de la
probabilidad? Bueno, <tt class="docutils literal"><span class="pre">return</span> <span class="pre">x</span></tt> se supone que siempre crea un valor monádico
capaz de albergar <tt class="docutils literal"><span class="pre">x</span></tt> como resultado, así que no tiene sentido que su
probabilidad sea <tt class="docutils literal"><span class="pre">0</span></tt>. Como siempre devuelve el mismo resultado, su
probabilidad debe ser <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>¿Qué pasa con <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt>? Parece algo complicado, así que vamos a utilizar el
hecho de que <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></tt> siempre sea igual a <tt class="docutils literal"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></tt> para todas
las mónadas y centrarnos en como unir una lista de probabilidades que contiene
listas de probabilidades. Como ejemplo vamos a considerar una lista donde
existe un 25% de probabilidades de que ocurra <tt class="docutils literal"><span class="pre">'a'</span></tt> o <tt class="docutils literal"><span class="pre">'b'</span></tt>. Tanto <tt class="docutils literal"><span class="pre">'a'</span></tt>
como <tt class="docutils literal"><span class="pre">'b'</span></tt> tienen la misma probabilidad de ocurrir. También existe un 75% de
probabilidades de que salga <tt class="docutils literal"><span class="pre">'c'</span></tt> o <tt class="docutils literal"><span class="pre">'d'</span></tt>. Tanto <tt class="docutils literal"><span class="pre">'c'</span></tt> como <tt class="docutils literal"><span class="pre">'d'</span></tt>
tienen la misma probabilidad de ocurrir. Aquí tienes una imagen que representa
este posible escenario.</p>
<img alt="Probabilidades" class="align-left" src="../_images/prob.png" />
<p>¿Cuáles son las probabilidades de cada uno de estos valores ocurra? Si
dibujamos todas estas probabilidades como cajas, cada una con una
probabilidad, ¿cuáles serían estas probabilidades? Para calcularlas, todo
lo que tenemos que hacer es multiplicar la probabilidad con la probabilidad
que lo contenga. <tt class="docutils literal"><span class="pre">'a'</span></tt> tendrá una probabilidad de un octavo, al igual que
<tt class="docutils literal"><span class="pre">'b'</span></tt>, ya que si multiplicamos un medio por un cuarto obtenemos un octavo.
<tt class="docutils literal"><span class="pre">'c'</span></tt> ocurrirá tres octavos de las veces porque si multiplicamos un medio
por tres cuartos obtenemos tres octavos. <tt class="docutils literal"><span class="pre">'d'</span></tt> ocurrirá tres octavos. Si
sumamos todas las probabilidades dará uno como resultado.</p>
<p>Así se representaría la situación actual:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">thisSituation</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="p">(</span><span class="kt">Prob</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">thisSituation</span> <span class="ow">=</span> <span class="kt">Prob</span>
    <span class="p">[(</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span> <span class="p">,</span> <span class="mi">1</span><span class="o">%</span><span class="mi">4</span> <span class="p">)</span>
    <span class="p">,(</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span> <span class="p">,</span> <span class="mi">3</span><span class="o">%</span><span class="mi">4</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>Fíjate que el tipo es <tt class="docutils literal"><span class="pre">Prob</span> <span class="pre">(Pron</span> <span class="pre">Char)</span></tt>. Así que ahora que hemos averiguado
como unir varias listas de probabilidades anidadas, solo tenemos que escribir
el código y utilizarlo para implementar <tt class="docutils literal"><span class="pre">&gt;&gt;=</span></tt> como <tt class="docutils literal"><span class="pre">join</span> <span class="pre">(fmap</span> <span class="pre">f</span> <span class="pre">m)</span></tt> y
ya tendremos nuestra mónada lista. Aquí tenemos la función <tt class="docutils literal"><span class="pre">flattern</span></tt>, tiene
este nombre porque alguien ya utilizo antes que nosotros el nombre <tt class="docutils literal"><span class="pre">join</span></tt>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">flatten</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Prob</span> <span class="n">a</span>
<span class="nf">flatten</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="o">$</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="n">multAll</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">multAll</span> <span class="p">(</span><span class="kt">Prob</span> <span class="n">innerxs</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="o">*</span><span class="n">r</span><span class="p">))</span> <span class="n">innerxs</span>
</pre></div>
</div>
<p>La función <tt class="docutils literal"><span class="pre">multAll</span></tt> toma un dupla con una lista de probabilidades y una
probabilidad <tt class="docutils literal"><span class="pre">p</span></tt> y produce una nueva lista de probabilidades en las que
las probabilidades de todos los elementos han sido multiplicadas por <tt class="docutils literal"><span class="pre">p</span></tt>.
Mapeamos <tt class="docutils literal"><span class="pre">multAll</span></tt> sobre cada dupla de la lista anidada y luego la aplanamos
con <tt class="docutils literal"><span class="pre">concat</span></tt>.</p>
<p>Ahora que ya tenemos todo lo que necesitamos podemos escribir la instancia de
<tt class="docutils literal"><span class="pre">Monad</span></tt>.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Prob</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">flatten</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">fail</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="kt">[]</span>
</pre></div>
</div>
<img alt="Cavalgando" class="align-right" src="../_images/ride.png" />
<p>Como ya hemos hecho todo el trabajo sucio, la instancia es muy simple. También
hemos definido la función <tt class="docutils literal"><span class="pre">fail</span></tt>, que al igual que la instancia de la
listas, devuelve una lista vacía. Así que si ocurre un fallo en un ajuste de
patrones dentro de una expresión <tt class="docutils literal"><span class="pre">do</span></tt>, ocurrirá un fallo en el contexto en
si mismo.</p>
<p>Es importante también comprobar si se cumple la leyes de las mónadas. La
primera ley dice que <tt class="docutils literal"><span class="pre">return</span> <span class="pre">x</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></tt> debe ser igual que <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>. Una prueba
rigurosa sería algo tediosa, pero podemos ver que si tomamos un valor y lo
introducimos en contexto mínimo por defecto con <tt class="docutils literal"><span class="pre">return</span></tt> y luego mapeamos
una función con <tt class="docutils literal"><span class="pre">fmap</span></tt> sobre este valor para después aplanar la lista de
probabilidades resultante, cada probabilidad que produzca la función será
multiplicada por <tt class="docutils literal"><span class="pre">1%1</span></tt>, así que el contexto no se verá afectado. El
razonamiento por el cual <tt class="docutils literal"><span class="pre">m</span> <span class="pre">&gt;&gt;=</span> <span class="pre">return</span></tt> es igual a <tt class="docutils literal"><span class="pre">m</span></tt> es similar. La
tercera ley dice que <tt class="docutils literal"><span class="pre">f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">(g</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h)</span></tt> debe ser igual a <tt class="docutils literal"><span class="pre">(f</span> <span class="pre">&lt;=&lt;</span> <span class="pre">g)</span> <span class="pre">&lt;=&lt;</span> <span class="pre">h</span></tt>.
Esta ley también se cumple ya que mantenemos la mónada lista como base de esta
nueva mónada y por que la multiplicación es asociativa. <tt class="docutils literal"><span class="pre">1%2</span> <span class="pre">*</span> <span class="pre">(1%3</span> <span class="pre">*</span> <span class="pre">1%5)</span></tt>
es igual que <tt class="docutils literal"><span class="pre">(1%2</span> <span class="pre">*</span> <span class="pre">1%3)</span> <span class="pre">*</span> <span class="pre">1%5</span></tt>.</p>
<p>Ahora que tenemos una mónada, ¿qué podemos hacer con ella? Bueno, nos puede
ayudar a hacer cálculos con probabilidades. Podemos tratar eventos
probabilísticos como valores con un cierto contexto y la mónada probabilidad
se encargará de que las probabilidades se reflejen en el resultado final.</p>
<p>Digamos que tenemos dos monedas normales y una moneda trucada que siempre
saca cruz nueve de cada diez veces. Si lanzamos todas estas monedas a la vez,
¿cuáles son las probabilidad de que todas ellas sean cruz? Primero, vamos
a crear unas listas de probabilidades para las monedas normales y para la
trucada:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Coin</span> <span class="ow">=</span> <span class="kt">Heads</span> <span class="o">|</span> <span class="kt">Tails</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="nf">coin</span><span class="p">,</span> <span class="n">loadedCoin</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="kt">Coin</span>
<span class="nf">coin</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="kt">Heads</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">),(</span><span class="kt">Tails</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">2</span><span class="p">)]</span>

<span class="nf">loadedCoin</span> <span class="ow">=</span> <span class="kt">Prob</span> <span class="p">[(</span><span class="kt">Heads</span><span class="p">,</span><span class="mi">1</span><span class="o">%</span><span class="mi">10</span><span class="p">),(</span><span class="kt">Tails</span><span class="p">,</span><span class="mi">9</span><span class="o">%</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>
</div>
<p>Luego creamos la acción de lanzar las monedas:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">all</span><span class="p">)</span>

<span class="nf">flipThree</span> <span class="ow">::</span> <span class="kt">Prob</span> <span class="kt">Bool</span>
<span class="nf">flipThree</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">coin</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">coin</span>
    <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">loadedCoin</span>
    <span class="n">return</span> <span class="p">(</span><span class="n">all</span> <span class="p">(</span><span class="o">==</span><span class="kt">Tails</span><span class="p">)</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<p>Vemos que las probabilidades de que todas ellas sean cara no son muy buenas,
incluso aunque tengamos una moneda trucada.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="go">ghci&gt; getProb flipThree</span>
<span class="go">[(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),</span>
<span class="go"> (False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]</span>
</pre></div>
</div>
<p>Las tres serán cruz nueve veces de cuarenta lanzamientos, lo cual es menos
del 25%. Podemos ver que la mónada no sabe como unir todos los valores iguales
a <tt class="xref docutils literal"><span class="pre">False</span></tt>, donde no todas las tres monedas fueron cruz. No es un gran
problema, ya que podemos crear una función que tome elemento a elemento y
vaya sumando las probabilidades del mismo suceso. Ya tienes algo que hacer.</p>
<p>En esta sección hemos pasado de tener una pregunta (¿qué pasaría si añadimos
información sobre la probabilidad de un elemento?) a crear un tipo,
identificando una mónada y finalmente creando una instancia para trabajar con
ella. Creo que hemos hecho bastante. A esta alturas ya deberíamos tener una
buena idea que son las mónadas y como trabajar con ellas.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="Zippers.html" title="Zippers"
             >siguiente</a></li>
        <li class="right" >
          <a href="Monadas.html" title="Un puñado de mónadas"
             >anterior</a> |</li>
        <li><a href="../index.html">Índice</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    </div>
  </body>
</html>